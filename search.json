[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Machine learning with scikit-learn in Python",
    "section": "",
    "text": "Machine learning with scikit-learn in Python\n\nposit::conf(2025)\nby Tiffany Timbers and Katie Burak\n\nüóìÔ∏è September 16, 2025  ‚è∞ 09:00 - 17:00 üè® ROOM TBD ‚úçÔ∏è pos.it/conf\n\n\n\n\nTime\nActivity\n\n\n\n\n09:00 - 10:30\nSession 1\n\n\n10:30 - 11:00\nCoffee break\n\n\n11:00 - 12:30\nSession 2\n\n\n12:30 - 13:30\nLunch break\n\n\n13:30 - 15:00\nSession 3\n\n\n15:00 - 15:30\nCoffee break\n\n\n15:30 - 17:00\nSession 4\n\n\n\n\n This work is licensed under a Creative Commons Attribution 4.0 International License."
  },
  {
    "objectID": "materials/slides/regression.html#session-learning-objectives",
    "href": "materials/slides/regression.html#session-learning-objectives",
    "title": "Regression",
    "section": "Session learning objectives",
    "text": "Session learning objectives\n\nRecognize situations where a regression analysis would be appropriate for making predictions.\nExplain the K-nearest neighbors (K-NN) regression algorithm and describe how it differs from K-NN classification.\nDescribe the advantages and disadvantages of K-nearest neighbors and linear regression.\nUse Python to fit linear regression models on training data.\nEvaluate the linear regression model on test data.\nDescribe how linear regression is affected by outliers and multicollinearity.\nLearn how to apply LASSO regression (L1 regularization) for feature selection and regularization to improve model performance.",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#the-regression-problem",
    "href": "materials/slides/regression.html#the-regression-problem",
    "title": "Regression",
    "section": "The regression problem",
    "text": "The regression problem\n\nPredictive problem\nUse past information to predict future observations\nPredict numerical values instead of categorical values\n\nExamples:\n\nRace time in the Boston marathon\nsize of a house to predict its sale price\n\nRegression Methods\nIn this workshop:\n\nK-nearest neighbors (brief overview)\nLinear regression\nL1 regularization\n\nClassification similarities to regression\nConcepts from classification map over to the setting of regression\n\nPredict a new observation‚Äôs response variable based on past observations\nSplit the data into training and test sets\nUse cross-validation to evaluate different choices of model parameters\n\nDifference\nPredicting numerical variables instead of categorical variables",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#explore-a-data-set",
    "href": "materials/slides/regression.html#explore-a-data-set",
    "title": "Regression",
    "section": "Explore a data set",
    "text": "Explore a data set\n932 real estate transactions in Sacramento, California\n\nCan we use the size of a house in the Sacramento, CA area to predict its sale price?\n\nData and package setup\n\nimport altair as alt\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom sklearn.model_selection import GridSearchCV, train_test_split\nfrom sklearn.compose import make_column_transformer\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn import set_config\n\n# Output dataframes instead of arrays\nset_config(transform_output='pandas')\n\nsacramento = pd.read_csv('data/sacramento.csv')\nprint(sacramento)\n\n                city     zip  beds  baths  sqft         type   price  \\\n0         SACRAMENTO  z95838     2    1.0   836  Residential   59222   \n1         SACRAMENTO  z95823     3    1.0  1167  Residential   68212   \n..               ...     ...   ...    ...   ...          ...     ...   \n930        ELK_GROVE  z95758     4    2.0  1685  Residential  235301   \n931  EL_DORADO_HILLS  z95762     3    2.0  1362  Residential  235738   \n\n      latitude   longitude  \n0    38.631913 -121.434879  \n1    38.478902 -121.431028  \n..         ...         ...  \n930  38.417000 -121.397424  \n931  38.655245 -121.075915  \n\n[932 rows x 9 columns]\n\n\nPrice vs Sq.Ft",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#sample-of-data",
    "href": "materials/slides/regression.html#sample-of-data",
    "title": "Regression",
    "section": "Sample of data",
    "text": "Sample of data\n\n# look at a small sample of data\nnp.random.seed(10)\n\nsmall_sacramento = sacramento.sample(n=30)\nprint(small_sacramento)\n\n           city     zip  beds  baths  sqft         type   price   latitude  \\\n538   ELK_GROVE  z95758     3    3.0  2503  Residential  484500  38.409689   \n304     ROCKLIN  z95765     4    2.0  2607  Residential  402000  38.805749   \n..          ...     ...   ...    ...   ...          ...     ...        ...   \n559  SACRAMENTO  z95817     2    1.0  1080  Residential   65000  38.544162   \n917  SACRAMENTO  z95834     3    2.0  1665  Residential  224000  38.631026   \n\n      longitude  \n538 -121.446059  \n304 -121.280931  \n..          ...  \n559 -121.460652  \n917 -121.501879  \n\n[30 rows x 9 columns]\n\n\nSample: K-NN Example\n\n\nHouse price of 2000\n\n\n\n\n\n\n\n\n\n5 closest neighbors",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#make-and-visualize-prediction",
    "href": "materials/slides/regression.html#make-and-visualize-prediction",
    "title": "Regression",
    "section": "Make and visualize prediction",
    "text": "Make and visualize prediction\n\nsmall_sacramento['dist'] = (2000 - small_sacramento['sqft']).abs()\nnearest_neighbors = small_sacramento.nsmallest(5, 'dist')\nprediction = nearest_neighbors['price'].mean()\nprint(prediction)\n\n280739.2",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#k-nn-regression-in-scikit-learn",
    "href": "materials/slides/regression.html#k-nn-regression-in-scikit-learn",
    "title": "Regression",
    "section": "K-NN regression in scikit-learn",
    "text": "K-NN regression in scikit-learn\nWe won‚Äôt be covering K-NN regression in detail, as the process is very similar to K-NN classification. The main differences are summarized below:\n\n\n\n\n\n\n\n\nFeature\nK-NN Classification\nK-NN Regression\n\n\n\n\nTarget Type\nCategorical (e.g., ‚ÄòA‚Äô, ‚ÄòB‚Äô)\nContinuous (e.g., 3.5, 27.0)\n\n\nPrediction Logic\nMajority vote\nMean (or weighted average)\n\n\nscikit-learn Class\nKNeighborsClassifier\nKNeighborsRegressor\n\n\nOutput\nClass label\nNumeric value\n\n\nUse Case\nClassification problems\nRegression problems\n\n\nMetrics\nAccuracy, Precision, Recall etc.\nRMS(P)E (details to follow)",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#splitting-the-data",
    "href": "materials/slides/regression.html#splitting-the-data",
    "title": "Regression",
    "section": "Splitting the data",
    "text": "Splitting the data\n\nnp.random.seed(1)\n\nsacramento_train, sacramento_test = train_test_split(\n    sacramento, train_size=0.75\n)\n\n\n\n\n\n\n\nNote\n\n\nWe are not specifying the stratify argument. The train_test_split() function cannot stratify on a quantitative variable\n\n\n\nMetric: RMS(P)E\nRoot Mean Square (Prediction) Error\n\\[\\text{RMSPE} = \\sqrt{\\frac{1}{n}\\sum\\limits_{i=1}^{n}(y_i - \\hat{y}_i)^2}\\]\nwhere:\n\n\\(n\\) is the number of observations,\n\\(y_i\\) is the observed value for the \\(i^\\text{th}\\) observation, and\n\\(\\hat{y}_i\\) is the forecasted/predicted value for the \\(i^\\text{th}\\) observation.\n\nMetric: Visualize\n\n\n\n\n\n\n\n\nRMSPE vs RMSE\nRoot Mean Square (Prediction) Error\n\nRMSPE: the error calculated on the non-training dataset\nRMSE: the error calcualted on the training dataset\n\nThis notation is a statistics distinction, you will most likely see RMSPE written as RMSE.\nChoosing \\(k\\)\nAs we did previously, we can use cross-validation and select the value of \\(k\\) that yields the lowest RMSE to choose the best model.",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#evaluating-on-the-test-set",
    "href": "materials/slides/regression.html#evaluating-on-the-test-set",
    "title": "Regression",
    "section": "Evaluating on the test set",
    "text": "Evaluating on the test set\n\nThen we retrain the K-NN regression model on the entire training data set using best \\(k\\).\n\n\nfrom sklearn.metrics import mean_squared_error\n\nsacramento_test['predicted'] = sacr_gridsearch.predict(sacramento_test)\nRMSPE = mean_squared_error(\n    y_true=sacramento_test['price'], y_pred=sacramento_test['predicted']\n) ** (1 / 2)\n\nRMSPE\n\n87498.86808211416\n\n\n\nThe code for running cross-validation to get sacr_gridsearch is included at the end of the slides for reference.\n\nFinal best K model\nPredicted values of house price (orange line) for the final K-NN regression model.\n\n\n\n\n\n\n\n\n\nK-NN regression supports multiple predictors - see the end of the slides for Python code demonstrating multivariable K-NN regression.",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#strengths-and-limitations-of-k-nn-regression",
    "href": "materials/slides/regression.html#strengths-and-limitations-of-k-nn-regression",
    "title": "Regression",
    "section": "Strengths and limitations of K-NN regression",
    "text": "Strengths and limitations of K-NN regression\nStrengths:\n\nsimple, intuitive algorithm\nrequires few assumptions about what the data must look like\nworks well with non-linear relationships (i.e., if the relationship is not a straight line)\n\nWeaknesses:\n\nvery slow as the training data gets larger\nmay not perform well with a large number of predictors\nmay not predict well beyond the range of values input in your training data",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#linear-regression",
    "href": "materials/slides/regression.html#linear-regression",
    "title": "Regression",
    "section": "Linear Regression",
    "text": "Linear Regression\n\nAddresses the limitations from KNN regression\nProvides an interpretable mathematical equation that describes the relationship between the predictor and response variables\nCreates a straight line of best fit through the training data\n\n\n\n\n\n\n\nNote\n\n\nLogistic regression is the linear model we can use for binary classification\n\n\n\nSacramento real estate\n\nimport pandas as pd\n\nsacramento = pd.read_csv('data/sacramento.csv')\n\nnp.random.seed(42)\nsmall_sacramento = sacramento.sample(n=30)\n\nprint(small_sacramento)\n\n           city     zip  beds  baths  sqft         type   price   latitude  \\\n829  SACRAMENTO  z95824     3    1.0  1161  Residential  109000  38.511893   \n70    ELK_GROVE  z95624     4    2.0  1715  Residential  199500  38.440760   \n..          ...     ...   ...    ...   ...          ...     ...        ...   \n909  SACRAMENTO  z95828     3    1.0   888  Residential  216021  38.508217   \n265  SACRAMENTO  z95835     4    3.0  2030  Residential  270000  38.671807   \n\n      longitude  \n829 -121.457676  \n70  -121.385792  \n..          ...  \n909 -121.411207  \n265 -121.498274  \n\n[30 rows x 9 columns]\n\n\nSacramento real estate: best fit line\n\n\n\n\n\n\n\n\n\n\n\nThe equation for the line is:\n\\[\\text{house sale price} = \\beta_0 + \\beta_1 \\cdot (\\text{house size})+\\varepsilon,\\] where\n\n\\(\\beta_0\\) is the vertical intercept of the line (the price when house size is 0)\n\\(\\beta_1\\) is the slope of the line (how quickly the price increases as you increase house size)\n\\(\\varepsilon\\) is the random error term\n\n\nSacramento real estate: Prediction\n\n\n\n\n\n\n\n\nEstimating a line\n\n\n\n\n\n\n\n\nWhat makes the best line?\nTo define the best line we need to know how to measure the distance of the points to the line!\nWhich of the following criteria would you choose to define ‚Äúdistance of a point to the line‚Äù?\n\n\nFigure by Dr.¬†Joel Ostblom\n\nLeast squares\nLeast Squares method minimizes the sum of the squares of the residuals. The residuals are the difference between the observed value of the response (\\(y_i\\)) and the predicted value of the response (\\(\\hat{y}_i\\)):\n\\[r_i = y_i-\\hat{y}_i\\]\n\n\n\n\n\n\n\n\n\nThe residuals are the vertical distances of each point to the estimated line",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#sum-of-squared-errors",
    "href": "materials/slides/regression.html#sum-of-squared-errors",
    "title": "Regression",
    "section": "Sum of squared errors",
    "text": "Sum of squared errors\nWhen estimating the regression equation, we minimize the sum of squared errors (SSE), defined as\n\\[SSE = \\sum_{i=1}^n (y_i-\\hat{y_i})^2=\\sum_{i=1}^n r_i^2.\\]",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#linear-regression-in-python",
    "href": "materials/slides/regression.html#linear-regression-in-python",
    "title": "Regression",
    "section": "Linear regression in Python",
    "text": "Linear regression in Python\nThe scikit-learn pattern still applies:\n\nCreate a training and test set\nInstantiate a model\nFit the model on training\nUse model on testing set\n\nLinear regression: Train test split\n\nimport numpy as np\nimport altair as alt\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn import set_config\n\n# Output dataframes instead of arrays\nset_config(transform_output='pandas')\n\nnp.random.seed(1)\n\nsacramento = pd.read_csv('data/sacramento.csv')\n\nsacramento_train, sacramento_test = train_test_split(\n    sacramento, train_size=0.75\n)\n\nLinear regression: Fit the model\n\n# fit the linear regression model\nlm = LinearRegression()\nlm.fit(\n    sacramento_train[['sqft']],  # A single-column data frame\n    sacramento_train['price'],  # A series\n)\n\n# make a dataframe containing slope and intercept coefficients\nresults_df = pd.DataFrame({'slope': [lm.coef_[0]], 'intercept': [lm.intercept_]})\nprint(results_df)\n\n        slope     intercept\n0  137.285652  15642.309105\n\n\n\n\\(\\text{house sale price} =\\) 137.29 \\(+\\) 15642.31 \\(\\cdot (\\text{house size}).\\)\nLinear regression: Predictions\n\n# make predictions\nsacramento_test[\"predicted\"] = lm.predict(sacramento_test[[\"sqft\"]])\n\n# calculate RMSPE\nRMSPE = mean_squared_error(\n    y_true=sacramento_test[\"price\"],\n    y_pred=sacramento_test[\"predicted\"]\n)**(1/2)\n\nRMSPE\n\n85376.59691629931\n\n\nLinear regression: Plot\n\n\n\n\n\n\n\n\nStandarization\n\nWe did not need to standarize like we did for KNN.\nIn linear regression, if we standarize, we convert all the units to unit-less standard deviations\nStandarization in linear regression does not change the fit of the model\n\nIt will, however, change the coefficients!",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#comparing-simple-linear-and-k-nn-regression",
    "href": "materials/slides/regression.html#comparing-simple-linear-and-k-nn-regression",
    "title": "Regression",
    "section": "Comparing simple linear and K-NN regression",
    "text": "Comparing simple linear and K-NN regression",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#multiple-linear-regression",
    "href": "materials/slides/regression.html#multiple-linear-regression",
    "title": "Regression",
    "section": "Multiple linear regression",
    "text": "Multiple linear regression\n\nMore predictor variables! (More does not always mean better‚Ä¶)\nWhen \\(p\\), the number of variables, is greater than 1, we have multiple linear regression.\n\n\nNote: We will talk about categorical predictors later in the workshop\n\nSacramento real estate: 2 predictors\n\nmlm = LinearRegression()\nmlm.fit(sacramento_train[['sqft', 'beds']], sacramento_train['price'])\n\nsacramento_test['predicted'] = mlm.predict(sacramento_test[['sqft', 'beds']])\n\nSacramento real estate: Coefficients\n\nmlm.coef_\n\narray([   154.59235377, -20333.43213798])\n\n\n\nmlm.intercept_\n\nnp.float64(53180.26906624224)\n\n\n\\[\\text{house sale price} = 53180.27 + 154.59\\cdot(\\text{house size}) -20333.43\\cdot(\\text{bedrooms}),\\] where:\n\nIntercept (\\(\\hat{\\beta}_0=53180.27\\)): Predicted sale price when house size = 0 and bedrooms = 0 (not meaningful in reality, but needed for the equation).\nHouse size (\\(\\hat{\\beta}_1=154.59\\)): Holding bedrooms constant, each extra unit of size (e.g., square foot) increases the price by $154.59 on average.\nNumber of bedrooms (\\(\\hat{\\beta}_2=-20333.43\\)): Holding size constant, each additional bedroom reduces price by about $20,333.\n\nMore variables make it harder to visualize\n\n\n        \n        \n        \n\n\n                            \n                                            \n\n\nSacramento real estate: mlm rmspe\n\nlm_mult_test_RMSPE = mean_squared_error(\n    y_true=sacramento_test['price'], y_pred=sacramento_test['predicted']\n) ** (1 / 2)\n\nlm_mult_test_RMSPE\n\n82331.04630202598",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#outliers-and-multicollinearity",
    "href": "materials/slides/regression.html#outliers-and-multicollinearity",
    "title": "Regression",
    "section": "Outliers and Multicollinearity",
    "text": "Outliers and Multicollinearity\n\nOutliers: extreme values that can move the best fit line\nMulticollinearity: variables that are highly correlated to one another\n\nOutliers\n\n\nSubset\n\n\n\n\n\n\n\n\n\nFull data\n\n\n\n\n\n\n\n\n\nMulticollinearity\n\nMulticollinearity means that some (or all) of the explanatory variables are linearly related!\nWhen this happens, the coefficient estimates are very ‚Äúunstable‚Äù and the contribution of one variable gets mixed with that of another variable correlated with it.\nEssentially, the plane of best fit has regression coefficients that are very sensitive to the exact values in the data.",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#feature-selection",
    "href": "materials/slides/regression.html#feature-selection",
    "title": "Regression",
    "section": "Feature selection",
    "text": "Feature selection\n\nIn modern datasets, we often have many features (sometimes more than the number of observations).\nNot all features are informative or relevant.\nIncluding irrelevant predictors can lead to:\n\nOverfitting\nMulticollinearity\nPoor generalization to new data\n\nWe need methods that can automatically select features while fitting the model‚Ä¶",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#l1-regularization",
    "href": "materials/slides/regression.html#l1-regularization",
    "title": "Regression",
    "section": "L1-regularization",
    "text": "L1-regularization\n\nL1-regularization, often referred to as LASSO (Least Absolute Shrinkage and Selection Operator), adds an L1 penalty to the least squares loss:\n\n\\[\n\\hat{\\boldsymbol{\\beta}} = \\arg\\min_{\\boldsymbol{\\beta}} \\left\\{\n\\sum_{i=1}^n (y_i - \\mathbf{x}_i^\\top \\boldsymbol{\\beta})^2 + \\lambda \\sum_{j=1}^p |\\beta_j|\n\\right\\}\n\\]\n\n\\(\\lambda \\geq 0\\) is a tuning parameter that controls the strength of the penalty\nWith the L1 penalty, many coefficients get set equal to zero.\nThus, LASSO performs variable selection and regularization.\n\n\n\n\n\n\n\nNote\n\n\nStandardization is necessary in penalized regression because penalty terms are scale-sensitive.",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#l1-regularization-in-scikit-learn",
    "href": "materials/slides/regression.html#l1-regularization-in-scikit-learn",
    "title": "Regression",
    "section": "L1-regularization in scikit-learn",
    "text": "L1-regularization in scikit-learn\n\nfrom sklearn.linear_model import Lasso\n\n# Example: Use only numeric columns for X \nfeatures = ['beds', 'baths', 'sqft']\n\nX = sacramento_train[features]\ny = sacramento_train['price']\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=2025)\n\nsacr_preprocessor = make_column_transformer(\n    (StandardScaler(), features),\n    remainder= 'drop'\n)\n\nsacr_pipeline = make_pipeline(\n    sacr_preprocessor,\n    Lasso(alpha=2000.0, max_iter=10000) # fixing alpha for now\n)\n\n# Fit the pipeline on training data\nsacr_pipeline.fit(X_train, y_train)\n\nlasso_model = sacr_pipeline.named_steps['lasso']\n\ncoefs = lasso_model.coef_\n\n# Count non-zero coefficients\nnum_selected = np.sum(coefs != 0)\nprint(f\"Number of features selected by Lasso: {num_selected}\")\n\n# List selected features\nselected_features = [feature for feature, coef in zip(features, coefs) if coef != 0]\nprint(\"Selected features:\", selected_features)\n\nNumber of features selected by Lasso: 2\nSelected features: ['beds', 'sqft']",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#choosing-the-shrinkage-parameter",
    "href": "materials/slides/regression.html#choosing-the-shrinkage-parameter",
    "title": "Regression",
    "section": "Choosing the shrinkage parameter",
    "text": "Choosing the shrinkage parameter\n\nThe \\(\\alpha\\) parameter controls the strength of the L1 penalty:\n\nLarger \\(\\alpha\\) ‚Üí stronger regularization ‚Üí more coefficients shrunk to zero\nSmaller \\(\\alpha\\) ‚Üí less regularization ‚Üí more complex model\n\nProper selection of \\(\\alpha\\) is critical for balancing bias and variance.\n\nTuning \\(\\alpha\\) with cross-validation\n\nJust like tuning \\(k\\) in KNN, we can select \\(\\alpha\\) by evaluating performance on validation sets.\nExample workflow with GridSearchCV:\n\n\npipeline = make_pipeline(\n    sacr_preprocessor,\n    Lasso(max_iter=10000)\n)\n\nparam_grid = {\n    'lasso__alpha': np.arange(1, 3000, 10.0)\n}\n\ngrid_search = GridSearchCV(\n    estimator=pipeline,\n    param_grid=param_grid,\n    cv=5,\n    scoring='neg_root_mean_squared_error'\n)\n\ngrid_search.fit(X_train, y_train)\n\nprint(\"Best alpha:\", grid_search.best_params_['lasso__alpha'])\nprint(\"Coefficients:\", coefs)\n\nBest alpha: 1891.0\nCoefficients: [-10065.94683829      0.         103554.95899024]",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#section",
    "href": "materials/slides/regression.html#section",
    "title": "Regression",
    "section": "",
    "text": "best_model = grid_search.best_estimator_\n\n# Predict on test set\ny_pred = best_model.predict(X_test)\n\n# Show first 5 predictions\nprint(\"First 5 predictions:\", y_pred[:5])\n\n# Evaluate model\nmse = mean_squared_error(y_test, y_pred)\nrmse = mse ** (1/2)\n\nprint(f\"Test RMSE: {rmse:.2f}\")\n\nFirst 5 predictions: [175748.55398861 254020.729447   143612.96210119 181557.39623021\n 474863.85674907]\nTest RMSE: 75838.23",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#clicker-questions",
    "href": "materials/slides/regression.html#clicker-questions",
    "title": "Regression",
    "section": "Clicker questions",
    "text": "Clicker questions\n\nhttps://www.menti.com/algmf2xzfs8g9\nAlternatively, go to menti.com and use code 1668 5101",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#additional-resources",
    "href": "materials/slides/regression.html#additional-resources",
    "title": "Regression",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nThe Regression I: K-nearest neighbors and Regression II: linear regression chapters of Data Science: A First Introduction (Python Edition) by Tiffany Timbers, Trevor Campbell, Melissa Lee, Joel Ostblom, Lindsey Heagy contains all the content presented here with a detailed narrative.\nThe scikit-learn website is an excellent reference for more details on, and advanced usage of, the functions and packages in this lesson. Aside from that, it also offers many useful tutorials to get you started.\nAn Introduction to Statistical Learning by Gareth James Daniela Witten Trevor Hastie, and Robert Tibshirani provides a great next stop in the process of learning about classification. Chapter 3 discusses lienar regression in more depth. As well as how it comares to K-nearest neighbors.",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#references",
    "href": "materials/slides/regression.html#references",
    "title": "Regression",
    "section": "References",
    "text": "References\nThomas Cover and Peter Hart. Nearest neighbor pattern classification. IEEE Transactions on Information Theory, 13(1):21‚Äì27, 1967.\nEvelyn Fix and Joseph Hodges. Discriminatory analysis. nonparametric discrimination: consistency properties. Technical Report, USAF School of Aviation Medicine, Randolph Field, Texas, 1951.",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/regression.html#code-for-cv-in-k-nn-regression",
    "href": "materials/slides/regression.html#code-for-cv-in-k-nn-regression",
    "title": "Regression",
    "section": "Code for CV in K-NN regression",
    "text": "Code for CV in K-NN regression\n\nfrom sklearn.neighbors import KNeighborsRegressor\n\n# preprocess the data, make the pipeline\nsacr_preprocessor = make_column_transformer((StandardScaler(), ['sqft']))\nsacr_pipeline = make_pipeline(sacr_preprocessor, KNeighborsRegressor())\n\n# create the 5-fold GridSearchCV object\nparam_grid = {\n    'kneighborsregressor__n_neighbors': range(1, 201, 3),\n}\nsacr_gridsearch = GridSearchCV(\n    estimator=sacr_pipeline,\n    param_grid=param_grid,\n    cv=5,\n    scoring='neg_root_mean_squared_error'\n)\n\n# fit the GridSearchCV object\nsacr_gridsearch.fit(\n    sacramento_train[['sqft']],  \n    sacramento_train['price']\n)\n\nsacr_gridsearch.best_params_\n\n# Retrieve the CV scores\nsacr_results = pd.DataFrame(sacr_gridsearch.cv_results_)\nsacr_results = sacr_results[\n    [\n        'param_kneighborsregressor__n_neighbors',\n        'mean_test_score'\n    ]\n].rename(columns={'param_kneighborsregressor__n_neighbors': 'n_neighbors'})\n\n\nbest_k_sacr = sacr_results[\"n_neighbors\"][sacr_results[\"mean_test_score\"].idxmin()]\nbest_cv_RMSPE = min(sacr_results[\"mean_test_score\"])\n\nMultivariable K-NN regression: Preprocessor\n\nsacr_preprocessor = make_column_transformer(\n    (StandardScaler(), ['sqft', 'beds'])\n)\nsacr_pipeline = make_pipeline(sacr_preprocessor, KNeighborsRegressor())\n\nMultivariable K-NN regression: CV\n\n# create the 5-fold GridSearchCV object\nparam_grid = {\n    'kneighborsregressor__n_neighbors': range(1, 50),\n}\n\nsacr_gridsearch = GridSearchCV(\n    estimator=sacr_pipeline,\n    param_grid=param_grid,\n    cv=5,\n    scoring='neg_root_mean_squared_error',\n)\n\nsacr_gridsearch.fit(\n    sacramento_train[['sqft', 'beds']], sacramento_train['price']\n)\n\nGridSearchCV(cv=5,\n             estimator=Pipeline(steps=[('columntransformer',\n                                        ColumnTransformer(transformers=[('standardscaler',\n                                                                         StandardScaler(),\n                                                                         ['sqft',\n                                                                          'beds'])])),\n                                       ('kneighborsregressor',\n                                        KNeighborsRegressor())]),\n             param_grid={'kneighborsregressor__n_neighbors': range(1, 50)},\n             scoring='neg_root_mean_squared_error')In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GridSearchCV?Documentation for GridSearchCViFitted\n        \n            \n                Parameters\n                \n\n\n\n\nestimator¬†\nPipeline(step...Regressor())])\n\n\n\nparam_grid¬†\n{'kneighborsregressor__n_neighbors': range(1, 50)}\n\n\n\nscoring¬†\n'neg_root_mean_squared_error'\n\n\n\nn_jobs¬†\nNone\n\n\n\nrefit¬†\nTrue\n\n\n\ncv¬†\n5\n\n\n\nverbose¬†\n0\n\n\n\npre_dispatch¬†\n'2*n_jobs'\n\n\n\nerror_score¬†\nnan\n\n\n\nreturn_train_score¬†\nFalse\n\n\n\n\n            \n        \n    best_estimator_: Pipelinecolumntransformer: ColumnTransformer?Documentation for columntransformer: ColumnTransformer\n        \n            \n                Parameters\n                \n\n\n\n\ntransformers¬†\n[('standardscaler', ...)]\n\n\n\nremainder¬†\n'drop'\n\n\n\nsparse_threshold¬†\n0.3\n\n\n\nn_jobs¬†\nNone\n\n\n\ntransformer_weights¬†\nNone\n\n\n\nverbose¬†\nFalse\n\n\n\nverbose_feature_names_out¬†\nTrue\n\n\n\nforce_int_remainder_cols¬†\n'deprecated'\n\n\n\n\n            \n        \n    standardscaler['sqft', 'beds']StandardScaler?Documentation for StandardScaler\n        \n            \n                Parameters\n                \n\n\n\n\ncopy¬†\nTrue\n\n\n\nwith_mean¬†\nTrue\n\n\n\nwith_std¬†\nTrue\n\n\n\n\n            \n        \n    KNeighborsRegressor?Documentation for KNeighborsRegressor\n        \n            \n                Parameters\n                \n\n\n\n\nn_neighbors¬†\n29\n\n\n\nweights¬†\n'uniform'\n\n\n\nalgorithm¬†\n'auto'\n\n\n\nleaf_size¬†\n30\n\n\n\np¬†\n2\n\n\n\nmetric¬†\n'minkowski'\n\n\n\nmetric_params¬†\nNone\n\n\n\nn_jobs¬†\nNone\n\n\n\n\n            \n        \n    \n\n\nMultivariable K-NN regression: Best K\n\n# retrieve the CV scores\nsacr_results = pd.DataFrame(sacr_gridsearch.cv_results_)\nsacr_results['mean_test_score'] = -sacr_results['mean_test_score']\nsacr_results = sacr_results[\n    [\n        'param_kneighborsregressor__n_neighbors',\n        'mean_test_score'\n    ]\n].rename(columns={'param_kneighborsregressor__n_neighbors': 'n_neighbors'})\n\n# show only the row of minimum RMSPE\nsacr_results.nsmallest(1, 'mean_test_score')\n\n\n\n\n\n\n\n\nn_neighbors\nmean_test_score\n\n\n\n\n28\n29\n85156.027067\n\n\n\n\n\n\n\nMultivariable K-NN regression: Best model\n\nbest_k_sacr_multi = sacr_results[\"n_neighbors\"][sacr_results[\"mean_test_score\"].idxmin()]\nmin_rmspe_sacr_multi = min(sacr_results[\"mean_test_score\"])\n\nBest K\n\nbest_k_sacr_multi\n\nnp.int64(29)\n\n\nBest RMSPE\n\nmin_rmspe_sacr_multi\n\n85156.02706746716\n\n\nMultivariable K-NN regression: Test data\n\nsacramento_test[\"predicted\"] = sacr_gridsearch.predict(sacramento_test)\nRMSPE_mult = mean_squared_error(\n    y_true=sacramento_test[\"price\"],\n    y_pred=sacramento_test[\"predicted\"]\n)**(1/2)\n\nRMSPE_mult\n\n85083.2902421959\n\n\nMultivariable K-NN regression: Visualize",
    "crumbs": [
      "Home",
      "Slides",
      "Regression"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#tree-based-methods",
    "href": "materials/slides/ensembles.html#tree-based-methods",
    "title": "Tree-based and ensemble models",
    "section": "Tree-based methods",
    "text": "Tree-based methods\n\n\n\n\n\n\n\nAlgorithms that stratifying or segmenting the predictor space into a number of simple regions.\nWe call these algorithms decision-tree methods because the decisions used to segment the predictor space can be summarized in a tree.\nDecision trees on their own, are very explainable and intuitive, but not very powerful at predicting.\nHowever, there are extensions of decision trees, such as random forest and boosted trees, which are very powerful at predicting. We will demonstrate two of these in this session.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#decision-trees",
    "href": "materials/slides/ensembles.html#decision-trees",
    "title": "Tree-based and ensemble models",
    "section": "Decision trees",
    "text": "Decision trees\n\nDecision Trees by Jared Wilber & Luc√≠a Santamar√≠a",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#classification-decision-trees",
    "href": "materials/slides/ensembles.html#classification-decision-trees",
    "title": "Tree-based and ensemble models",
    "section": "Classification Decision trees",
    "text": "Classification Decision trees\n\nUse recursive binary splitting to grow a classification tree (splitting of the predictor space into \\(J\\) distinct, non-overlapping regions).\nFor every observation that falls into the region \\(R_j\\) , we make the same prediction, which is the majority vote for the training observations in \\(R_j\\).\nWhere to split the predictor space is done in a top-down and greedy manner, and in practice for classification, the best split at any point in the algorithm is one that minimizes the Gini index (a measure of node purity).\nDecision trees are useful because they are very interpretable.\nA limitation of decision trees is that theyn tend to overfit, so in practice we use cross-validation to tune a hyperparameter, \\(\\alpha\\), to find the optimal, pruned tree.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#example-the-heart-data-set",
    "href": "materials/slides/ensembles.html#example-the-heart-data-set",
    "title": "Tree-based and ensemble models",
    "section": "Example: the heart data set",
    "text": "Example: the heart data set\n\nLet‚Äôs consider a situation where we‚Äôd like to be able to predict the presence of heart disease (AHD) in patients, based off 13 measured characteristics.\nThe heart data set contains a binary outcome for heart disease for patients who presented with chest pain.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#example-the-heart-data-set-contd",
    "href": "materials/slides/ensembles.html#example-the-heart-data-set-contd",
    "title": "Tree-based and ensemble models",
    "section": "Example: the heart data set (cont‚Äôd)",
    "text": "Example: the heart data set (cont‚Äôd)\nAn angiographic test was performed and a label for AHD of Yes was labelled to indicate the presence of heart disease, otherwise the label was No.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#do-we-have-a-class-imbalance",
    "href": "materials/slides/ensembles.html#do-we-have-a-class-imbalance",
    "title": "Tree-based and ensemble models",
    "section": "Do we have a class imbalance?",
    "text": "Do we have a class imbalance?\nIt‚Äôs always important to check this, as it may impact your splitting and/or modeling decisions.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#data-splitting",
    "href": "materials/slides/ensembles.html#data-splitting",
    "title": "Tree-based and ensemble models",
    "section": "Data splitting",
    "text": "Data splitting\nLet‚Äôs split the data into training and test sets:",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#categorical-variables",
    "href": "materials/slides/ensembles.html#categorical-variables",
    "title": "Tree-based and ensemble models",
    "section": "Categorical variables",
    "text": "Categorical variables\n\n\n\nThis is our first case of seeing categorical predictor variables, can we treat them the same as numerical ones? No!\nIn scikit-learn we must perform one-hot encoding\n\n\n\nSource: https://scales.arabpsychology.com/stats/how-can-i-perform-one-hot-encoding-in-r/",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#look-at-the-data-again",
    "href": "materials/slides/ensembles.html#look-at-the-data-again",
    "title": "Tree-based and ensemble models",
    "section": "Look at the data again",
    "text": "Look at the data again\nWhich columns do we need to standardize?\nWhich do we need to one-hot encode?",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#one-hot-encoding-pre-processing",
    "href": "materials/slides/ensembles.html#one-hot-encoding-pre-processing",
    "title": "Tree-based and ensemble models",
    "section": "One hot encoding & pre-processing",
    "text": "One hot encoding & pre-processing\n\n\n\n\n\n\n\nhandle_unknown = \"ignore\" handles the case where categories exist in the test data, which were missing in the training set. Specifically, it sets the value for those to 0 for all cases of the category.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#fitting-a-dummy-classifier",
    "href": "materials/slides/ensembles.html#fitting-a-dummy-classifier",
    "title": "Tree-based and ensemble models",
    "section": "Fitting a dummy classifier",
    "text": "Fitting a dummy classifier",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#put-the-mean-cross-validated-error-in-a-data-frame",
    "href": "materials/slides/ensembles.html#put-the-mean-cross-validated-error-in-a-data-frame",
    "title": "Tree-based and ensemble models",
    "section": "Put the mean cross-validated error in a data frame",
    "text": "Put the mean cross-validated error in a data frame",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#fitting-a-decision-tree",
    "href": "materials/slides/ensembles.html#fitting-a-decision-tree",
    "title": "Tree-based and ensemble models",
    "section": "Fitting a decision tree",
    "text": "Fitting a decision tree",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#add-the-mean-cross-validated-error-to-our-results-data-frame",
    "href": "materials/slides/ensembles.html#add-the-mean-cross-validated-error-to-our-results-data-frame",
    "title": "Tree-based and ensemble models",
    "section": "Add the mean cross-validated error to our results data frame",
    "text": "Add the mean cross-validated error to our results data frame",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#can-we-do-better",
    "href": "materials/slides/ensembles.html#can-we-do-better",
    "title": "Tree-based and ensemble models",
    "section": "Can we do better?",
    "text": "Can we do better?\n\nWe could tune some decision tree parameters (e.g., alpha, maximum tree depth, etc)‚Ä¶\nWe could also try a different tree-based method!\nThe Random Forest Algorithm by Jenny Yeon & Jared Wilber",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#the-random-forest-algorithm",
    "href": "materials/slides/ensembles.html#the-random-forest-algorithm",
    "title": "Tree-based and ensemble models",
    "section": "The Random Forest Algorithm",
    "text": "The Random Forest Algorithm\n\nBuild a number of decision trees on bootstrapped training samples.\nWhen building the trees from the bootstrapped samples, at each stage of splitting, the best splitting is computed using a randomly selected subset of the features.\nTake the majority votes across all the trees for the final prediction.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#random-forest-in-scikit-learn",
    "href": "materials/slides/ensembles.html#random-forest-in-scikit-learn",
    "title": "Tree-based and ensemble models",
    "section": "Random forest in scikit-learn",
    "text": "Random forest in scikit-learn",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#add-the-mean-cross-validated-error-to-our-results-data-frame-1",
    "href": "materials/slides/ensembles.html#add-the-mean-cross-validated-error-to-our-results-data-frame-1",
    "title": "Tree-based and ensemble models",
    "section": "Add the mean cross-validated error to our results data frame",
    "text": "Add the mean cross-validated error to our results data frame",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#can-we-do-better-1",
    "href": "materials/slides/ensembles.html#can-we-do-better-1",
    "title": "Tree-based and ensemble models",
    "section": "Can we do better?",
    "text": "Can we do better?\n\nRandom forest can be tuned a several important parameters, including:\n\nn_estimators: number of decision trees (higher = more complexity)\nmax_depth: max depth of each decision tree (higher = more complexity)\nmax_features: the number of features you get to look at each split (higher = more complexity)\n\nWe can use GridSearchCV to search for the optimal parameters for these, as we did for \\(K\\) in \\(K\\)-nearest neighbors.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#tuning-random-forest-in-scikit-learn",
    "href": "materials/slides/ensembles.html#tuning-random-forest-in-scikit-learn",
    "title": "Tree-based and ensemble models",
    "section": "Tuning random forest in scikit-learn",
    "text": "Tuning random forest in scikit-learn",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#comparing-to-our-other-models",
    "href": "materials/slides/ensembles.html#comparing-to-our-other-models",
    "title": "Tree-based and ensemble models",
    "section": "Comparing to our other models",
    "text": "Comparing to our other models\nHow did the tuned Random Forest compare against the other models we tried?",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#boosting",
    "href": "materials/slides/ensembles.html#boosting",
    "title": "Tree-based and ensemble models",
    "section": "Boosting",
    "text": "Boosting\n\nNo randomization.\nThe key idea is combining many simple models called weak learners, to create a strong learner.\nThey combine multiple shallow (depth 1 to 5) decision trees.\nThey build trees in a serial manner, where each tree tries to correct the mistakes of the previous one.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#tuning-boosted-classifiers-with-scikit-learn",
    "href": "materials/slides/ensembles.html#tuning-boosted-classifiers-with-scikit-learn",
    "title": "Tree-based and ensemble models",
    "section": "Tuning Boosted Classifiers with scikit-learn",
    "text": "Tuning Boosted Classifiers with scikit-learn\n\nHistGradientBoostingClassifier can be tuned a several important parameters, including:\n\nmax_iter: number of decision trees (higher = more complexity)\nmax_depth: max depth of each decision tree (higher = more complexity)\nlearning_rate: the shrinkage parameter which controls the rate at which boosting learns. Values between 0.01 or 0.001 are typical.\n\nWe can use GridSearchCV to search for the optimal parameters for these, as we did for the parameters in Random Forest.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#tuning-boosted-classifiers-with-scikit-learn-contd",
    "href": "materials/slides/ensembles.html#tuning-boosted-classifiers-with-scikit-learn-contd",
    "title": "Tree-based and ensemble models",
    "section": "Tuning Boosted Classifiers with scikit-learn (cont‚Äôd)",
    "text": "Tuning Boosted Classifiers with scikit-learn (cont‚Äôd)",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#histgradientboostingclassifier-results",
    "href": "materials/slides/ensembles.html#histgradientboostingclassifier-results",
    "title": "Tree-based and ensemble models",
    "section": "HistGradientBoostingClassifier results",
    "text": "HistGradientBoostingClassifier results\nHow did the HistGradientBoostingClassifier compare against the other models we tried?",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#how-do-we-choose-the-final-model",
    "href": "materials/slides/ensembles.html#how-do-we-choose-the-final-model",
    "title": "Tree-based and ensemble models",
    "section": "How do we choose the final model?",
    "text": "How do we choose the final model?\n\nRemember, what is your question or application?\nA good rule when models are not very different, what is the simplest model that does well?\nLook at other metrics that are important to you (not just the metric you used for tuning your model), remember precision & recall, for example.\nRemember - no peaking at the test set until you choose! And then, you should only look at the test set for one model!",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#precision-and-recall-on-the-tuned-random-forest-model",
    "href": "materials/slides/ensembles.html#precision-and-recall-on-the-tuned-random-forest-model",
    "title": "Tree-based and ensemble models",
    "section": "Precision and recall on the tuned random forest model",
    "text": "Precision and recall on the tuned random forest model",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#precision-and-recall-contd",
    "href": "materials/slides/ensembles.html#precision-and-recall-contd",
    "title": "Tree-based and ensemble models",
    "section": "Precision and recall cont‚Äôd",
    "text": "Precision and recall cont‚Äôd\n\nWhat do we think? Is this model ready for production in a diagnostic setting?\nHow could we improve it further?",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#feature-importances-key-points",
    "href": "materials/slides/ensembles.html#feature-importances-key-points",
    "title": "Tree-based and ensemble models",
    "section": "Feature importances: key points",
    "text": "Feature importances: key points\n\nDecision trees are very interpretable (decision rules!), however in ensemble models (e.g., Random Forest and Boosting) there are many trees - individual decision rules are not as meaningful‚Ä¶\nInstead, we can calculate feature importances as the total decrease in impurity for all splits involving that feature, weighted by the number of samples involved in those splits, normalized and averaged over all the trees.\nThese are calculated on the training set, as that is the set the model is trained on.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#feature-importances-notes-of-caution",
    "href": "materials/slides/ensembles.html#feature-importances-notes-of-caution",
    "title": "Tree-based and ensemble models",
    "section": "Feature importances: Notes of caution!",
    "text": "Feature importances: Notes of caution!\n\nFeature importances can be unreliable with both highly cardinal, and multicollinear features.\nUnlike the linear model coefficients, feature importances do not have a sign! They tell us about importance, but not an ‚Äúup or down‚Äù.\nIncreasing a feature may cause the prediction to first go up, and then go down.\nAlternatives to feature importance to understanding models exist, such as post-hoc explanations (sometimes called ‚Äúexplainable AI‚Äù, see Interpretable Machine Learning by Christoph Molnar for an introduction)",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#feature-importances-in-scikit-learn",
    "href": "materials/slides/ensembles.html#feature-importances-in-scikit-learn",
    "title": "Tree-based and ensemble models",
    "section": "Feature importances in scikit-learn",
    "text": "Feature importances in scikit-learn",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#feature-importances-in-scikit-learn-contd",
    "href": "materials/slides/ensembles.html#feature-importances-in-scikit-learn-contd",
    "title": "Tree-based and ensemble models",
    "section": "Feature importances in scikit-learn (cont‚Äôd)",
    "text": "Feature importances in scikit-learn (cont‚Äôd)",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#visualizing-the-results",
    "href": "materials/slides/ensembles.html#visualizing-the-results",
    "title": "Tree-based and ensemble models",
    "section": "Visualizing the results",
    "text": "Visualizing the results",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#visualizing-the-results-1",
    "href": "materials/slides/ensembles.html#visualizing-the-results-1",
    "title": "Tree-based and ensemble models",
    "section": "Visualizing the results",
    "text": "Visualizing the results",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#evaluating-on-the-test-set",
    "href": "materials/slides/ensembles.html#evaluating-on-the-test-set",
    "title": "Tree-based and ensemble models",
    "section": "Evaluating on the test set",
    "text": "Evaluating on the test set\nPredict on the test set:",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#evaluating-on-the-test-set-1",
    "href": "materials/slides/ensembles.html#evaluating-on-the-test-set-1",
    "title": "Tree-based and ensemble models",
    "section": "Evaluating on the test set",
    "text": "Evaluating on the test set\nExamine accuracy, precision and recall:",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#evaluating-on-the-test-set-2",
    "href": "materials/slides/ensembles.html#evaluating-on-the-test-set-2",
    "title": "Tree-based and ensemble models",
    "section": "Evaluating on the test set",
    "text": "Evaluating on the test set",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#keep-learning",
    "href": "materials/slides/ensembles.html#keep-learning",
    "title": "Tree-based and ensemble models",
    "section": "Keep learning!",
    "text": "Keep learning!\n\n\n https://python.datasciencebook.ca/\n\n https://www.statlearning.com/",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#local-installation",
    "href": "materials/slides/ensembles.html#local-installation",
    "title": "Tree-based and ensemble models",
    "section": "Local installation",
    "text": "Local installation\n\nUsing Docker: Data Science: A First Introduction (Python Edition) Installation Instructions\nUsing conda: UBC MDS Installation Instructions",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#additional-resources",
    "href": "materials/slides/ensembles.html#additional-resources",
    "title": "Tree-based and ensemble models",
    "section": "Additional resources",
    "text": "Additional resources\n\nThe UBC DSCI 573 (Feature and Model Selection notes) chapter of Data Science: A First Introduction (Python Edition) by Varada Kolhatkar and Joel Ostblom. These notes cover classification and regression metrics, advanced variable selection and more on ensembles.\nThe scikit-learn website is an excellent reference for more details on, and advanced usage of, the functions and packages in the past two chapters. Aside from that, it also offers many useful tutorials to get you started.\nAn Introduction to Statistical Learning {cite:p}james2013introduction provides a great next stop in the process of learning about classification. Chapter 4 discusses additional basic techniques for classification that we do not cover, such as logistic regression, linear discriminant analysis, and naive Bayes.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/ensembles.html#references",
    "href": "materials/slides/ensembles.html#references",
    "title": "Tree-based and ensemble models",
    "section": "References",
    "text": "References\nGareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani and Jonathan Taylor. An Introduction to Statistical Learning with Applications in Python. Springer, 1st edition, 2023. URL: https://www.statlearning.com/.\nKolhatkar, V., and Ostblom, J. (2024). UBC DSCI 573: Feature and Model Selection course notes. URL: https://ubc-mds.github.io/DSCI_573_feat-model-select\nPedregosa, F. et al., 2011. Scikit-learn: Machine learning in Python. Journal of machine learning research, 12(Oct), pp.2825‚Äì2830.",
    "crumbs": [
      "Home",
      "Slides",
      "Tree-based and ensemble models"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#section",
    "href": "materials/slides/classification1.html#section",
    "title": "Classification I: training & predicting",
    "section": "",
    "text": "Tiffany Timbers\nAssociate Prof.¬†of Teaching, Dept. of Statistics, UBC\n\n\n\n\nKatie Burak\nAssistant Prof.¬†of Teaching, Dept. of Statistics, UBC\n\n\n\n\n\nSource: https://visit.ubc.ca/plan-your-trip/",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#helpful-resources",
    "href": "materials/slides/classification1.html#helpful-resources",
    "title": "Classification I: training & predicting",
    "section": "Helpful resources",
    "text": "Helpful resources\n\nWorkshop material: https://posit-conf-2025.github.io/scikit-learn/\nhttps://python.datasciencebook.ca/\nscikit-learn docs\nKCDS ML course",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#session-learning-objectives",
    "href": "materials/slides/classification1.html#session-learning-objectives",
    "title": "Classification I: training & predicting",
    "section": "Session learning objectives",
    "text": "Session learning objectives\nBy the end of the session, learners will be able to do the following:\n\nRecognize situations where a simple classifier would be appropriate for making predictions.\nExplain the \\(K\\)-nearest neighbor classification algorithm.\nInterpret the output of a classifier.\nDescribe what a training data set is and how it is used in classification.\nGiven a dataset with two explanatory variables/predictors, use \\(K\\)-nearest neighbor classification in Python using the scikit-learn framework to predict the class of a single new observation.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#the-classification-problem",
    "href": "materials/slides/classification1.html#the-classification-problem",
    "title": "Classification I: training & predicting",
    "section": "The classification problem",
    "text": "The classification problem\n\npredicting a categorical class (sometimes called a label) for an observation given its other variables (sometimes called features)\n\n\nDiagnose a patient as healthy or sick\nTag an email as ‚Äúspam‚Äù or ‚Äúnot spam‚Äù\nPredict whether a purchase is fraudulent",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#training-set",
    "href": "materials/slides/classification1.html#training-set",
    "title": "Classification I: training & predicting",
    "section": "Training set",
    "text": "Training set\n\nObservations with known classes that we use as a basis for prediction\n\n\nAssign an observation without a known class (e.g., a new patient)\nTo a class (e.g., diseased or healthy)\n\nHow?\n\nBy similar it is to other observations for which we do know the class\n\n(e.g., previous patients with known diseases and symptoms)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#k-nearest-neighbors",
    "href": "materials/slides/classification1.html#k-nearest-neighbors",
    "title": "Classification I: training & predicting",
    "section": "K-nearest neighbors",
    "text": "K-nearest neighbors\n\nOne of many possible classification methods\n\nKNN, decision trees, support vector machines (SVMs), logistic regression, neural networks, and more;\n\n\n\nPredict observations based on other observations ‚Äúclose‚Äù to it",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#exploring-a-data-set",
    "href": "materials/slides/classification1.html#exploring-a-data-set",
    "title": "Classification I: training & predicting",
    "section": "Exploring a data set",
    "text": "Exploring a data set\nData:\n\ndigitized breast cancer image features, created by Dr.¬†William H. Wolberg, W. Nick Street, and Olvi L. Mangasarian\nEach row:\n\ndiagnosis (benign or malignant)\nseveral other measurements (nucleus texture, perimeter, area, and more)\n\nDiagnosis for each image was conducted by physicians.\n\nFormulate a predictive question:\n\nCan we use the tumor image measurements available to us to predict whether a future tumor image (with unknown diagnosis) shows a benign or malignant tumor?",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#loading-the-cancer-data",
    "href": "materials/slides/classification1.html#loading-the-cancer-data",
    "title": "Classification I: training & predicting",
    "section": "Loading the cancer data",
    "text": "Loading the cancer data\n\nimport pandas as pd\nimport altair as alt\n\ncancer = pd.read_csv(\"data/wdbc.csv\")\nprint(cancer)\n\n           ID Class    Radius   Texture  Perimeter      Area  Smoothness  \\\n0      842302     M  1.096100 -2.071512   1.268817  0.983510    1.567087   \n1      842517     M  1.828212 -0.353322   1.684473  1.907030   -0.826235   \n2    84300903     M  1.578499  0.455786   1.565126  1.557513    0.941382   \n..        ...   ...       ...       ...        ...       ...         ...   \n566    926954     M  0.701667  2.043775   0.672084  0.577445   -0.839745   \n567    927241     M  1.836725  2.334403   1.980781  1.733693    1.524426   \n568     92751     B -1.806811  1.220718  -1.812793 -1.346604   -3.109349   \n\n     Compactness  Concavity  Concave_Points  Symmetry  Fractal_Dimension  \n0       3.280628   2.650542        2.530249  2.215566           2.253764  \n1      -0.486643  -0.023825        0.547662  0.001391          -0.867889  \n2       1.052000   1.362280        2.035440  0.938859          -0.397658  \n..           ...        ...             ...       ...                ...  \n566    -0.038646   0.046547        0.105684 -0.808406          -0.894800  \n567     3.269267   3.294046        2.656528  2.135315           1.042778  \n568    -1.149741  -1.113893       -1.260710 -0.819349          -0.560539  \n\n[569 rows x 12 columns]\n\n\n\nthese values have been standardized (centered and scaled)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#describing-the-variables-in-the-cancer-data-set",
    "href": "materials/slides/classification1.html#describing-the-variables-in-the-cancer-data-set",
    "title": "Classification I: training & predicting",
    "section": "Describing the variables in the cancer data set",
    "text": "Describing the variables in the cancer data set\n\nID: identification number\nClass: the diagnosis (M = malignant or B = benign)\nRadius: the mean of distances from center to points on the perimeter\nTexture: the standard deviation of gray-scale values\nPerimeter: the length of the surrounding contour\nArea: the area inside the contour\nSmoothness: the local variation in radius lengths\nCompactness: the ratio of squared perimeter and area\nConcavity: severity of concave portions of the contour\nConcave Points: the number of concave portions of the contour\nSymmetry: how similar the nucleus is when mirrored\nFractal Dimension: a measurement of how ‚Äúrough‚Äù the perimeter is",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#dataframe-info",
    "href": "materials/slides/classification1.html#dataframe-info",
    "title": "Classification I: training & predicting",
    "section": "DataFrame; info",
    "text": "DataFrame; info\n\ncancer.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 569 entries, 0 to 568\nData columns (total 12 columns):\n #   Column             Non-Null Count  Dtype  \n---  ------             --------------  -----  \n 0   ID                 569 non-null    int64  \n 1   Class              569 non-null    object \n 2   Radius             569 non-null    float64\n 3   Texture            569 non-null    float64\n 4   Perimeter          569 non-null    float64\n 5   Area               569 non-null    float64\n 6   Smoothness         569 non-null    float64\n 7   Compactness        569 non-null    float64\n 8   Concavity          569 non-null    float64\n 9   Concave_Points     569 non-null    float64\n 10  Symmetry           569 non-null    float64\n 11  Fractal_Dimension  569 non-null    float64\ndtypes: float64(10), int64(1), object(1)\nmemory usage: 53.5+ KB",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#series-unique",
    "href": "materials/slides/classification1.html#series-unique",
    "title": "Classification I: training & predicting",
    "section": "Series; unique",
    "text": "Series; unique\n\ncancer[\"Class\"].unique()\n\narray(['M', 'B'], dtype=object)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#series-replace",
    "href": "materials/slides/classification1.html#series-replace",
    "title": "Classification I: training & predicting",
    "section": "Series; replace",
    "text": "Series; replace\n\ncancer[\"Class\"] = cancer[\"Class\"].replace({\n    \"M\" : \"Malignant\",\n    \"B\" : \"Benign\"\n})\n\ncancer[\"Class\"].unique()\n\narray(['Malignant', 'Benign'], dtype=object)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#exploring-the-cancer-data",
    "href": "materials/slides/classification1.html#exploring-the-cancer-data",
    "title": "Classification I: training & predicting",
    "section": "Exploring the cancer data",
    "text": "Exploring the cancer data\n\n\n\ncancer.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 569 entries, 0 to 568\nData columns (total 12 columns):\n #   Column             Non-Null Count  Dtype  \n---  ------             --------------  -----  \n 0   ID                 569 non-null    int64  \n 1   Class              569 non-null    object \n 2   Radius             569 non-null    float64\n 3   Texture            569 non-null    float64\n 4   Perimeter          569 non-null    float64\n 5   Area               569 non-null    float64\n 6   Smoothness         569 non-null    float64\n 7   Compactness        569 non-null    float64\n 8   Concavity          569 non-null    float64\n 9   Concave_Points     569 non-null    float64\n 10  Symmetry           569 non-null    float64\n 11  Fractal_Dimension  569 non-null    float64\ndtypes: float64(10), int64(1), object(1)\nmemory usage: 53.5+ KB\n\n\n\n\ncancer[\"Class\"].value_counts()\n\nClass\nBenign       357\nMalignant    212\nName: count, dtype: int64\n\n\n\ncancer[\"Class\"].value_counts(normalize=True)\n\nClass\nBenign       0.627417\nMalignant    0.372583\nName: proportion, dtype: float64",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#visualization-scatter",
    "href": "materials/slides/classification1.html#visualization-scatter",
    "title": "Classification I: training & predicting",
    "section": "Visualization; scatter",
    "text": "Visualization; scatter\n\nperim_concav = alt.Chart(cancer).mark_circle().encode(\n    x=alt.X(\"Perimeter\").title(\"Perimeter (standardized)\"),\n    y=alt.Y(\"Concavity\").title(\"Concavity (standardized)\"),\n    color=alt.Color(\"Class\").title(\"Diagnosis\")\n)\nperim_concav\n\n\n\n\n\n\n\n\nMalignant: upper right-hand corner\nBenign: lower left-hand corner",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#classification-with-k-nearest-neighbors",
    "href": "materials/slides/classification1.html#classification-with-k-nearest-neighbors",
    "title": "Classification I: training & predicting",
    "section": "Classification with K-nearest neighbors",
    "text": "Classification with K-nearest neighbors\n\nnew_point = [2, 4]\nattrs = [\"Perimeter\", \"Concavity\"]\n\npoints_df = pd.DataFrame(\n    {\"Perimeter\": new_point[0], \"Concavity\": new_point[1], \"Class\": [\"Unknown\"]}\n)\n\nperim_concav_with_new_point_df = pd.concat((cancer, points_df), ignore_index=True)\nprint(perim_concav_with_new_point_df.iloc[[-1]])\n\n     ID    Class  Radius  Texture  Perimeter  Area  Smoothness  Compactness  \\\n569 NaN  Unknown     NaN      NaN        2.0   NaN         NaN          NaN   \n\n     Concavity  Concave_Points  Symmetry  Fractal_Dimension  \n569        4.0             NaN       NaN                NaN  \n\n\n\nCompute the distance matrix between each pair from a vector array X and Y\n\n\nfrom sklearn.metrics.pairwise import euclidean_distances\n\n# distance of new point to all other points\nmy_distances = euclidean_distances(perim_concav_with_new_point_df[attrs])[len(cancer)][:-1]",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#distances-euclidean_distances",
    "href": "materials/slides/classification1.html#distances-euclidean_distances",
    "title": "Classification I: training & predicting",
    "section": "Distances (euclidean_distances())",
    "text": "Distances (euclidean_distances())\n\nlen(my_distances)\n\n569\n\n\n\n# distance of new point to all other points\nmy_distances\n\narray([1.5348178 , 4.03617694, 2.67332814, 3.32713588, 2.63979916,\n       3.93975767, 3.79946977, 4.45111808, 3.53679058, 3.24726821,\n       4.951685  , 4.1538876 , 2.54585424, 4.15425044, 3.11637861,\n       3.55044614, 4.59148187, 3.2419721 , 3.28753437, 4.80392314,\n       5.0725937 , 5.77909213, 2.95751989, 3.74039071, 3.43925614,\n       2.52875652, 3.77084705, 3.33265886, 3.38875698, 4.01548319,\n       2.29844791, 4.41639587, 2.37500289, 3.07980178, 3.68423234,\n       3.64538579, 3.96211289, 5.35324353, 5.15747872, 4.34753568,\n       5.22721626, 4.73904767, 2.52193106, 4.45490282, 4.66689367,\n       2.72752709, 6.12589249, 4.22308671, 4.99998799, 5.02870163,\n       5.6046947 , 5.35214561, 5.55043261, 3.00901521, 4.79823955,\n       5.48235796, 3.5095414 , 3.95297778, 5.63490804, 6.01390031,\n       5.87933291, 5.91132619, 3.03871581, 5.49969602, 4.39948134,\n       3.94696965, 5.86541424, 5.44232875, 3.5688574 , 5.25454378,\n       3.82344861, 5.25379158, 3.18218244, 4.62286207, 5.32774445,\n       4.16803695, 4.77170639, 3.116331  , 0.42493342, 5.19385448,\n       5.30482795, 4.27283113, 1.5738716 , 2.72530186, 5.28695027,\n       3.53135424, 4.07667556, 3.36046764, 5.02616064, 4.28105636,\n       5.08987644, 4.06173178, 5.23583761, 5.12196626, 3.41101552,\n       3.29340171, 5.45247337, 5.97564782, 5.33610215, 4.36938678,\n       4.5747129 , 6.48184167, 5.47542661, 5.36604536, 5.613812  ,\n       3.33949831, 5.01110652, 5.41189651, 0.55551675, 5.27565211,\n       5.58649812, 4.47802084, 2.21531998, 5.22162826, 5.76866374,\n       5.38532049, 5.19210935, 3.45558489, 2.82916109, 4.33700274,\n       5.43089315, 3.37958378, 1.08182567, 4.43471652, 4.67171757,\n       5.38180662, 4.95316036, 4.01361335, 4.05397523, 1.96649017,\n       5.38705743, 3.64469659, 4.05988238, 4.50756395, 3.76213679,\n       5.13050863, 5.3935035 , 5.43774287, 3.65660785, 5.31746273,\n       6.06709632, 4.19123548, 5.58505201, 5.07141526, 5.67437994,\n       5.3118164 , 3.95222274, 4.34990935, 4.48041652, 5.21967232,\n       5.27228063, 4.9856446 , 3.16033374, 5.64783765, 4.55625381,\n       5.28942169, 2.94556088, 4.65987123, 5.52821987, 5.87425544,\n       5.01479597, 3.6647416 , 2.00933283, 5.09508115, 3.48554243,\n       5.21089953, 5.63346732, 4.25659443, 2.60788505, 5.1235711 ,\n       5.26668135, 4.92430756, 3.0055466 , 5.62066384, 5.93265649,\n       6.22261986, 4.67391612, 3.14048344, 5.63516301, 5.56209059,\n       2.28238396, 1.99614747, 4.5827958 , 5.14142315, 4.75900602,\n       5.99489694, 4.18791744, 5.37081664, 5.51737366, 5.28279829,\n       3.24435641, 5.30255656, 6.07841571, 4.47920836, 3.41230971,\n       5.20804267, 3.95279728, 3.85020952, 3.75520252, 4.09873275,\n       5.25090776, 3.95571059, 1.02556995, 3.74838091, 4.78344684,\n       4.50775001, 5.84453971, 4.42820325, 4.58608769, 4.70991057,\n       3.06620895, 5.47795396, 2.25791126, 3.18980412, 4.20191625,\n       4.37716521, 5.0105848 , 5.37840319, 3.54661409, 3.71379989,\n       5.10911168, 4.64924355, 5.79426278, 3.99346608, 5.20629394,\n       4.8202891 , 5.87943181, 4.64980144, 5.05761654, 3.75592522,\n       2.93896634, 5.66720387, 5.81073384, 3.17472629, 5.91706868,\n       5.35505181, 2.72040037, 3.99349371, 4.22138008, 3.51876003,\n       5.02543159, 5.59640488, 4.19318547, 5.0057303 , 2.58704649,\n       5.436657  , 5.12633337, 4.09064801, 5.66613011, 5.33180539,\n       1.71335191, 5.52675358, 2.12125281, 3.70385664, 3.43324432,\n       4.3806353 , 2.89031145, 2.55719447, 1.68480579, 3.28838601,\n       3.22394667, 4.90458516, 4.04354139, 4.88035432, 4.15209961,\n       3.40503317, 5.21596945, 5.10091918, 5.20786877, 4.9990198 ,\n       5.43226346, 5.48087656, 2.3767069 , 5.94507697, 4.5211903 ,\n       5.11031365, 5.82862797, 4.18684585, 5.35268577, 5.02260746,\n       2.76808627, 5.54993437, 3.12307913, 2.97318351, 4.38259137,\n       5.6711251 , 5.00552683, 5.40036897, 4.81405276, 5.57564086,\n       3.86732996, 4.72192014, 4.94335599, 5.47527125, 5.51168283,\n       5.42911177, 5.76462356, 5.48649506, 5.21509314, 5.67912648,\n       2.40157339, 4.92425385, 2.26303009, 5.69991917, 5.4438214 ,\n       5.57975911, 5.60096199, 6.1393111 , 5.55874599, 5.58924375,\n       5.62058842, 5.31151692, 5.1926542 , 5.6562653 , 6.23036743,\n       5.6534404 , 5.61434666, 3.80439574, 4.23384145, 5.56434723,\n       5.24601934, 3.68571812, 5.21072769, 1.90607514, 5.50310111,\n       5.30800616, 5.31620585, 5.74411995, 3.54212369, 3.16475863,\n       3.87726006, 4.81132308, 5.78706455, 5.84246195, 5.64107847,\n       3.43286642, 5.19423698, 3.85344874, 5.73171579, 2.29795062,\n       4.53177935, 5.19744059, 5.26949039, 2.81144211, 5.34221365,\n       5.57907032, 5.66694907, 4.91027582, 5.53765451, 5.60939647,\n       5.71574716, 2.00610128, 1.64508773, 3.97190329, 5.36950242,\n       4.52016957, 4.52715816, 5.37106085, 5.6874369 , 5.81664449,\n       5.68607257, 5.21747136, 5.35277254, 4.5962934 , 5.34491444,\n       3.89468209, 3.06847474, 5.23307852, 3.64878701, 2.06129256,\n       3.12501267, 5.00993253, 2.69057385, 3.2072275 , 5.26156013,\n       4.50595937, 3.67124149, 5.44150361, 5.06129902, 4.07858682,\n       4.96929894, 5.48405295, 4.84004697, 5.02207388, 5.01255365,\n       4.49141632, 4.95776003, 5.31116114, 4.74060439, 2.826814  ,\n       5.76396494, 6.20275637, 3.15987858, 1.59685768, 5.19525058,\n       5.21526538, 4.57871804, 4.80968212, 5.58105375, 5.46288376,\n       1.2972468 , 5.47224066, 5.15663081, 5.2604016 , 5.48496181,\n       5.34176328, 4.6689632 , 4.95661351, 3.72705942, 5.36077755,\n       5.52742781, 5.53221228, 5.71326651, 4.60752105, 4.87268565,\n       5.47286534, 5.89021125, 3.55992932, 5.40790439, 5.76402146,\n       5.20077264, 3.72751151, 5.00184656, 4.43321448, 5.95746714,\n       5.99801562, 5.26310755, 5.51782159, 5.7224917 , 5.51340204,\n       2.3124617 , 4.80399256, 2.45412403, 3.19080856, 5.05656702,\n       4.22394203, 5.43823889, 5.11692072, 5.38685852, 5.28621747,\n       4.84268126, 3.78545419, 5.4249681 , 5.73311162, 3.864998  ,\n       5.13322811, 3.13380247, 4.95722975, 4.43807879, 3.14362623,\n       4.79413756, 3.08367712, 5.30108059, 4.66354759, 5.3452239 ,\n       5.25742829, 5.00824137, 5.30251499, 5.50604417, 5.89508861,\n       4.0359228 , 1.98568574, 5.08294291, 5.43529775, 5.06510952,\n       4.4364945 , 4.3738675 , 5.91565644, 2.59125613, 4.65623267,\n       5.75301228, 5.48445557, 4.77751754, 5.73632325, 5.32328468,\n       4.98354112, 4.89768611, 5.28065632, 5.22420762, 2.63344333,\n       5.39567051, 5.19629894, 4.90482811, 5.03639886, 3.93947738,\n       3.96686285, 4.85329884, 2.34089893, 5.30309605, 4.85559729,\n       5.5309169 , 4.67995816, 3.75864018, 5.62983122, 5.4130801 ,\n       4.6341703 , 4.7487875 , 5.27707904, 3.33910207, 2.37201494,\n       4.48871851, 3.9471973 , 5.00585064, 3.04870175, 5.07434752,\n       4.79884848, 4.79972507, 5.41633547, 4.66063335, 2.98017132,\n       5.02270071, 5.05194873, 3.93259786, 4.50489852, 4.53936557,\n       5.35824937, 3.24923179, 3.36951055, 5.06570933, 5.20763998,\n       5.74945417, 2.4422538 , 5.79929781, 4.92446715, 5.78256826,\n       5.95832482, 5.08135275, 5.37836918, 4.36770317, 5.30961783,\n       5.18642487, 5.3174709 , 5.35493406, 3.21253802, 5.29920646,\n       2.50107618, 3.80249905, 5.25928058, 6.37734031, 5.48039131,\n       5.05783739, 4.26631233, 4.97127178, 5.26423305, 5.09946287,\n       5.22502766, 5.87042063, 5.50586936, 5.82652706, 5.73627569,\n       5.91148802, 5.33015146, 5.43981718, 5.70454323, 4.95160691,\n       5.34062637, 5.93732182, 6.1113282 , 4.23339133, 4.606416  ,\n       4.98378665, 5.86739997, 2.45102755, 1.13686605, 2.05527356,\n       3.32995444, 4.17051001, 0.70621597, 6.37881593])",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#k-nearest-neighbors-classification",
    "href": "materials/slides/classification1.html#k-nearest-neighbors-classification",
    "title": "Classification I: training & predicting",
    "section": "K-nearest neighbors; classification",
    "text": "K-nearest neighbors; classification\n\nfind the \\(K\\) ‚Äúnearest‚Äù or ‚Äúmost similar‚Äù observations in our training set\npredict new observation based on closest points",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#knn-example-new-point",
    "href": "materials/slides/classification1.html#knn-example-new-point",
    "title": "Classification I: training & predicting",
    "section": "KNN Example: new point",
    "text": "KNN Example: new point\n\nperim_concav_with_new_point = (\n    alt.Chart(perim_concav_with_new_point_df)\n    .mark_point(opacity=0.6, filled=True, size=40)\n    .encode(\n        x=alt.X(\"Perimeter\").title(\"Perimeter (standardized)\"),\n        y=alt.Y(\"Concavity\").title(\"Concavity (standardized)\"),\n        color=alt.Color(\"Class\").title(\"Diagnosis\"),\n        shape=alt.Shape(\"Class\").scale(range=[\"circle\", \"circle\", \"diamond\"]),\n        size=alt.condition(\"datum.Class == 'Unknown'\", alt.value(100), alt.value(30)),\n        stroke=alt.condition(\"datum.Class == 'Unknown'\", alt.value(\"black\"), alt.value(None)),\n    )\n)\n\nperim_concav_with_new_point",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#knn-example-closest-point",
    "href": "materials/slides/classification1.html#knn-example-closest-point",
    "title": "Classification I: training & predicting",
    "section": "KNN example: closest point",
    "text": "KNN example: closest point\n\nif a point is close to another in the scatter plot, then the perimeter and concavity values are similar, and so we may expect that they would have the same diagnosis",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#knn-example-another-new-point",
    "href": "materials/slides/classification1.html#knn-example-another-new-point",
    "title": "Classification I: training & predicting",
    "section": "KNN Example: another new point",
    "text": "KNN Example: another new point",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#knn-improve-the-prediction-with-k",
    "href": "materials/slides/classification1.html#knn-improve-the-prediction-with-k",
    "title": "Classification I: training & predicting",
    "section": "KNN: improve the prediction with k",
    "text": "KNN: improve the prediction with k\nwe can consider several neighboring points, k=3",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#distance-between-points",
    "href": "materials/slides/classification1.html#distance-between-points",
    "title": "Classification I: training & predicting",
    "section": "Distance between points",
    "text": "Distance between points\n\\[\\mathrm{Distance} = \\sqrt{(a_x -b_x)^2 + (a_y - b_y)^2}\\]",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#distance-between-points-k5",
    "href": "materials/slides/classification1.html#distance-between-points-k5",
    "title": "Classification I: training & predicting",
    "section": "Distance between points: k=5",
    "text": "Distance between points: k=5\n\n3 of the 5 nearest neighbors to our new observation are malignant",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#more-than-two-explanatory-variables-distance-formula",
    "href": "materials/slides/classification1.html#more-than-two-explanatory-variables-distance-formula",
    "title": "Classification I: training & predicting",
    "section": "More than two explanatory variables: distance formula",
    "text": "More than two explanatory variables: distance formula\nThe distance formula becomes\n\\[\\mathrm{Distance} = \\sqrt{(a_{1} -b_{1})^2 + (a_{2} - b_{2})^2 + \\dots + (a_{m} - b_{m})^2}.\\]",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#more-than-two-explanatory-variables-visualize",
    "href": "materials/slides/classification1.html#more-than-two-explanatory-variables-visualize",
    "title": "Classification I: training & predicting",
    "section": "More than two explanatory variables: visualize",
    "text": "More than two explanatory variables: visualize",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#summary-of-k-nearest-neighbors-algorithm",
    "href": "materials/slides/classification1.html#summary-of-k-nearest-neighbors-algorithm",
    "title": "Classification I: training & predicting",
    "section": "Summary of K-nearest neighbors algorithm",
    "text": "Summary of K-nearest neighbors algorithm\nThe K-nearest neighbors algorithm works as follows:\n\nCompute the distance between the new observation and each observation in the training set\nFind the \\(K\\) rows corresponding to the \\(K\\) smallest distances\nClassify the new observation based on a majority vote of the neighbor classes",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#k-nearest-neighbors-with-scikit-learn",
    "href": "materials/slides/classification1.html#k-nearest-neighbors-with-scikit-learn",
    "title": "Classification I: training & predicting",
    "section": "K-nearest neighbors with scikit-learn",
    "text": "K-nearest neighbors with scikit-learn\n\nK-nearest neighbors algorithm is implemented in scikit-learn\n\n\nfrom sklearn import set_config\n\n# Output dataframes instead of arrays\nset_config(transform_output=\"pandas\")\n\nNow we can get started with sklearn and KNeighborsClassifier()\n\nfrom sklearn.neighbors import KNeighborsClassifier",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#review-cancer-data",
    "href": "materials/slides/classification1.html#review-cancer-data",
    "title": "Classification I: training & predicting",
    "section": "Review cancer data",
    "text": "Review cancer data\n\ncancer_train = cancer[[\"Class\", \"Perimeter\", \"Concavity\"]]\nprint(cancer_train)\n\n         Class  Perimeter  Concavity\n0    Malignant   1.268817   2.650542\n1    Malignant   1.684473  -0.023825\n2    Malignant   1.565126   1.362280\n..         ...        ...        ...\n566  Malignant   0.672084   0.046547\n567  Malignant   1.980781   3.294046\n568     Benign  -1.812793  -1.113893\n\n[569 rows x 3 columns]",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#scikit-learn-create-model-object",
    "href": "materials/slides/classification1.html#scikit-learn-create-model-object",
    "title": "Classification I: training & predicting",
    "section": "scikit-learn: Create Model Object",
    "text": "scikit-learn: Create Model Object\n\nfrom sklearn.neighbors import KNeighborsClassifier\n\nknn = KNeighborsClassifier(n_neighbors=5)\nknn\n\nKNeighborsClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.KNeighborsClassifier?Documentation for KNeighborsClassifieriNot fitted\n        \n            \n                Parameters\n                \n\n\n\n\nn_neighbors¬†\n5\n\n\n\nweights¬†\n'uniform'\n\n\n\nalgorithm¬†\n'auto'\n\n\n\nleaf_size¬†\n30\n\n\n\np¬†\n2\n\n\n\nmetric¬†\n'minkowski'\n\n\n\nmetric_params¬†\nNone\n\n\n\nn_jobs¬†\nNone",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#scikit-learn-fit-the-model",
    "href": "materials/slides/classification1.html#scikit-learn-fit-the-model",
    "title": "Classification I: training & predicting",
    "section": "scikit-learn: Fit the model",
    "text": "scikit-learn: Fit the model\n\nknn.fit(\n  X=cancer_train[[\"Perimeter\", \"Concavity\"]],\n  y=cancer_train[\"Class\"]\n)\n\nKNeighborsClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.KNeighborsClassifier?Documentation for KNeighborsClassifieriFitted\n        \n            \n                Parameters\n                \n\n\n\n\nn_neighbors¬†\n5\n\n\n\nweights¬†\n'uniform'\n\n\n\nalgorithm¬†\n'auto'\n\n\n\nleaf_size¬†\n30\n\n\n\np¬†\n2\n\n\n\nmetric¬†\n'minkowski'\n\n\n\nmetric_params¬†\nNone\n\n\n\nn_jobs¬†\nNone\n\n\n\n\n            \n        \n    \n\n\n\n\n\n\n\n\nNote\n\n\n\nWe do not re-assign the variable\nThe arguments are X and y (note the capitialization). This comes from matrix notation.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#scikit-learn-predict",
    "href": "materials/slides/classification1.html#scikit-learn-predict",
    "title": "Classification I: training & predicting",
    "section": "scikit-learn: Predict",
    "text": "scikit-learn: Predict\n\nnew_obs = pd.DataFrame({\"Perimeter\": [0], \"Concavity\": [3.5]})\nprint(new_obs)\n\n   Perimeter  Concavity\n0          0        3.5\n\n\n\nknn.predict(new_obs)\n\narray(['Malignant'], dtype=object)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#data-preprocessing-scaling",
    "href": "materials/slides/classification1.html#data-preprocessing-scaling",
    "title": "Classification I: training & predicting",
    "section": "Data preprocessing: Scaling",
    "text": "Data preprocessing: Scaling\nFor KNN:\n\nthe scale of each variable (i.e., its size and range of values) matters\ndistance based algorithm\n\nCompare these 2 scenarios:\n\nPerson A (200 lbs, 6ft tall) vs Person B (202 lbs, 6ft tall)\nPerson A (200 lbs, 6ft tall) vs Person B (200 lbs, 8ft tall)\n\nAll have a distance of 2",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#data-preprocessing-centering",
    "href": "materials/slides/classification1.html#data-preprocessing-centering",
    "title": "Classification I: training & predicting",
    "section": "Data preprocessing: Centering",
    "text": "Data preprocessing: Centering\nMany other models:\n\ncenter of each variable (e.g., its mean) matters as well\nDoes not matter as much in KNN:\nPerson A (200 lbs, 6ft tall) vs Person B (202 lbs, 6ft tall)\nPerson A (200 lbs, 6ft tall) vs Person B (200 lbs, 8ft tall)\n\nDifference in weight is in the 10s, difference in height is fractions of a foot.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#data-preprocessing-standardization",
    "href": "materials/slides/classification1.html#data-preprocessing-standardization",
    "title": "Classification I: training & predicting",
    "section": "Data preprocessing: Standardization",
    "text": "Data preprocessing: Standardization\n\nThe mean is used to center, the standard deviation is used to scale\nStandardization: transform the data such that the mean is 0, and a standard deviation is 1\n\n\nunscaled_cancer = pd.read_csv(\"data/wdbc_unscaled.csv\")[[\"Class\", \"Area\", \"Smoothness\"]]\nunscaled_cancer[\"Class\"] = unscaled_cancer[\"Class\"].replace({\n   \"M\" : \"Malignant\",\n   \"B\" : \"Benign\"\n})\nunscaled_cancer\n\n\n\n\n\n\n\n\nClass\nArea\nSmoothness\n\n\n\n\n0\nMalignant\n1001.0\n0.11840\n\n\n1\nMalignant\n1326.0\n0.08474\n\n\n2\nMalignant\n1203.0\n0.10960\n\n\n...\n...\n...\n...\n\n\n566\nMalignant\n858.1\n0.08455\n\n\n567\nMalignant\n1265.0\n0.11780\n\n\n568\nBenign\n181.0\n0.05263\n\n\n\n\n569 rows √ó 3 columns",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#scikit-learn-columntransformer",
    "href": "materials/slides/classification1.html#scikit-learn-columntransformer",
    "title": "Classification I: training & predicting",
    "section": "scikit-learn: ColumnTransformer",
    "text": "scikit-learn: ColumnTransformer\n\nscikit-learn has a preprocessing module\n\nStandardScaler(): scale our data\n\nmake_column_transformer: creates a ColumnTransformer to select columns\n\n\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.compose import make_column_transformer\n\npreprocessor = make_column_transformer(\n    (StandardScaler(), [\"Area\", \"Smoothness\"]),\n)\npreprocessor\n\nColumnTransformer(transformers=[('standardscaler', StandardScaler(),\n                                 ['Area', 'Smoothness'])])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.ColumnTransformer?Documentation for ColumnTransformeriNot fitted\n        \n            \n                Parameters\n                \n\n\n\n\ntransformers¬†\n[('standardscaler', ...)]\n\n\n\nremainder¬†\n'drop'\n\n\n\nsparse_threshold¬†\n0.3\n\n\n\nn_jobs¬†\nNone\n\n\n\ntransformer_weights¬†\nNone\n\n\n\nverbose¬†\nFalse\n\n\n\nverbose_feature_names_out¬†\nTrue\n\n\n\nforce_int_remainder_cols¬†\n'deprecated'\n\n\n\n\n            \n        \n    standardscaler['Area', 'Smoothness']StandardScaler?Documentation for StandardScaler\n        \n            \n                Parameters\n                \n\n\n\n\ncopy¬†\nTrue\n\n\n\nwith_mean¬†\nTrue\n\n\n\nwith_std¬†\nTrue",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#scikit-learn-select-numeric-columns",
    "href": "materials/slides/classification1.html#scikit-learn-select-numeric-columns",
    "title": "Classification I: training & predicting",
    "section": "scikit-learn: Select numeric columns",
    "text": "scikit-learn: Select numeric columns\n\nfrom sklearn.compose import make_column_selector\n\npreprocessor = make_column_transformer(\n    (StandardScaler(), make_column_selector(dtype_include=\"number\")),\n)\npreprocessor\n\nColumnTransformer(transformers=[('standardscaler', StandardScaler(),\n                                 &lt;sklearn.compose._column_transformer.make_column_selector object at 0x7f2c7a74b110&gt;)])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.ColumnTransformer?Documentation for ColumnTransformeriNot fitted\n        \n            \n                Parameters\n                \n\n\n\n\ntransformers¬†\n[('standardscaler', ...)]\n\n\n\nremainder¬†\n'drop'\n\n\n\nsparse_threshold¬†\n0.3\n\n\n\nn_jobs¬†\nNone\n\n\n\ntransformer_weights¬†\nNone\n\n\n\nverbose¬†\nFalse\n\n\n\nverbose_feature_names_out¬†\nTrue\n\n\n\nforce_int_remainder_cols¬†\n'deprecated'\n\n\n\n\n            \n        \n    standardscaler&lt;sklearn.compose._column_transformer.make_column_selector object at 0x7f2c7a74b110&gt;StandardScaler?Documentation for StandardScaler\n        \n            \n                Parameters\n                \n\n\n\n\ncopy¬†\nTrue\n\n\n\nwith_mean¬†\nTrue\n\n\n\nwith_std¬†\nTrue",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#scikit-learn-transform",
    "href": "materials/slides/classification1.html#scikit-learn-transform",
    "title": "Classification I: training & predicting",
    "section": "scikit-learn: transform",
    "text": "scikit-learn: transform\nScale the data\n\npreprocessor.fit(unscaled_cancer)\nscaled_cancer = preprocessor.transform(unscaled_cancer)\n\nCompare unscaled vs scaled\n\n\n\nprint(unscaled_cancer)\n\n         Class    Area  Smoothness\n0    Malignant  1001.0     0.11840\n1    Malignant  1326.0     0.08474\n2    Malignant  1203.0     0.10960\n..         ...     ...         ...\n566  Malignant   858.1     0.08455\n567  Malignant  1265.0     0.11780\n568     Benign   181.0     0.05263\n\n[569 rows x 3 columns]\n\n\n\n\nprint(scaled_cancer)\n\n     standardscaler__Area  standardscaler__Smoothness\n0                0.984375                    1.568466\n1                1.908708                   -0.826962\n2                1.558884                    0.942210\n..                    ...                         ...\n566              0.577953                   -0.840484\n567              1.735218                    1.525767\n568             -1.347789                   -3.112085\n\n[569 rows x 2 columns]",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#visualize-unstandarized-vs-standarized-data",
    "href": "materials/slides/classification1.html#visualize-unstandarized-vs-standarized-data",
    "title": "Classification I: training & predicting",
    "section": "Visualize unstandarized vs standarized data",
    "text": "Visualize unstandarized vs standarized data",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#why-scikit-learn-pipelines",
    "href": "materials/slides/classification1.html#why-scikit-learn-pipelines",
    "title": "Classification I: training & predicting",
    "section": "Why scikit-learn pipelines?",
    "text": "Why scikit-learn pipelines?\n\nManually standarizing is error prone\nDoes not automatically account for new data\nPrevent data leakage by processing on training data to use on test data (later)\nNeed same mean and standarization from training to use on test / new data",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#balancing-class-imbalance",
    "href": "materials/slides/classification1.html#balancing-class-imbalance",
    "title": "Classification I: training & predicting",
    "section": "Balancing + class imbalance",
    "text": "Balancing + class imbalance\nWhat if we have class imbalance? i.e., if the response variable has a big difference in frequency counts between classes?\n\nrare_cancer = pd.concat((\n    cancer[cancer[\"Class\"] == \"Benign\"],\n    cancer[cancer[\"Class\"] == \"Malignant\"].head(3) # only 3 total\n))\nprint(rare_cancer)\n\n          ID      Class    Radius   Texture  Perimeter      Area  Smoothness  \\\n19   8510426     Benign -0.166653 -1.146154  -0.185565 -0.251735    0.101657   \n20   8510653     Benign -0.297184 -0.832276  -0.260877 -0.383301    0.792066   \n21   8510824     Benign -1.311926 -1.592558  -1.301661 -1.082620    0.429441   \n..       ...        ...       ...       ...        ...       ...         ...   \n0     842302  Malignant  1.096100 -2.071512   1.268817  0.983510    1.567087   \n1     842517  Malignant  1.828212 -0.353322   1.684473  1.907030   -0.826235   \n2   84300903  Malignant  1.578499  0.455786   1.565126  1.557513    0.941382   \n\n    Compactness  Concavity  Concave_Points  Symmetry  Fractal_Dimension  \\\n19    -0.436466  -0.277965       -0.028584  0.267676          -0.727669   \n20     0.429044  -0.540886       -0.459223  0.566790           0.752425   \n21    -0.746429  -0.743094       -0.725698  0.012334           0.885562   \n..          ...        ...             ...       ...                ...   \n0      3.280628   2.650542        2.530249  2.215566           2.253764   \n1     -0.486643  -0.023825        0.547662  0.001391          -0.867889   \n2      1.052000   1.362280        2.035440  0.938859          -0.397658   \n\n    dist_from_new  \n19       3.852759  \n20       4.072405  \n21       4.546829  \n..            ...  \n0        1.951685  \n1        4.031378  \n2        2.650133  \n\n[360 rows x 13 columns]",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#visualizing-class-imbalance",
    "href": "materials/slides/classification1.html#visualizing-class-imbalance",
    "title": "Classification I: training & predicting",
    "section": "Visualizing class imbalance",
    "text": "Visualizing class imbalance\n\nrare_cancer[\"Class\"].value_counts()\n\nClass\nBenign       357\nMalignant      3\nName: count, dtype: int64",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#predicting-with-class-imbalance",
    "href": "materials/slides/classification1.html#predicting-with-class-imbalance",
    "title": "Classification I: training & predicting",
    "section": "Predicting with class imbalance",
    "text": "Predicting with class imbalance",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#upsampling",
    "href": "materials/slides/classification1.html#upsampling",
    "title": "Classification I: training & predicting",
    "section": "Upsampling",
    "text": "Upsampling\nRebalance the data by oversampling the rare class\n\nSeparate the classes out into their own data frames by filtering\nUse the .sample() method on the rare class data frame\n\nSample with replacement so the classes are the same size\n\nUse the .value_counts() method to see that our classes are now balanced",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#upsampling-code",
    "href": "materials/slides/classification1.html#upsampling-code",
    "title": "Classification I: training & predicting",
    "section": "Upsampling: code",
    "text": "Upsampling: code\nSet seed\n\nimport numpy as np\n\nnp.random.seed(42)\n\nUpsample the rare class\n\nmalignant_cancer = rare_cancer[rare_cancer[\"Class\"] == \"Malignant\"]\nbenign_cancer = rare_cancer[rare_cancer[\"Class\"] == \"Benign\"]\nmalignant_cancer_upsample = malignant_cancer.sample(\n    n=benign_cancer.shape[0], replace=True\n)\nupsampled_cancer = pd.concat((malignant_cancer_upsample, benign_cancer))\nupsampled_cancer[\"Class\"].value_counts()\n\nClass\nMalignant    357\nBenign       357\nName: count, dtype: int64",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#upsampling-re-train-knn-k7",
    "href": "materials/slides/classification1.html#upsampling-re-train-knn-k7",
    "title": "Classification I: training & predicting",
    "section": "Upsampling: Re-train KNN k=7",
    "text": "Upsampling: Re-train KNN k=7",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#missing-data",
    "href": "materials/slides/classification1.html#missing-data",
    "title": "Classification I: training & predicting",
    "section": "Missing data",
    "text": "Missing data\nAssume we are only looking at ‚Äúrandomly missing‚Äù data\n\nmissing_cancer = pd.read_csv(\"data/wdbc_missing.csv\")[\n    [\"Class\", \"Radius\", \"Texture\", \"Perimeter\"]\n]\nmissing_cancer[\"Class\"] = missing_cancer[\"Class\"].replace(\n    {\"M\": \"Malignant\", \"B\": \"Benign\"}\n)\nprint(missing_cancer)\n\n       Class    Radius   Texture  Perimeter\n0  Malignant       NaN       NaN   1.268817\n1  Malignant  1.828212 -0.353322   1.684473\n2  Malignant  1.578499       NaN   1.565126\n3  Malignant -0.768233  0.253509  -0.592166\n4  Malignant  1.748758 -1.150804   1.775011\n5  Malignant -0.475956 -0.834601  -0.386808\n6  Malignant  1.169878  0.160508   1.137124",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#missing-data-.dropna",
    "href": "materials/slides/classification1.html#missing-data-.dropna",
    "title": "Classification I: training & predicting",
    "section": "Missing data: .dropna()",
    "text": "Missing data: .dropna()\nKNN computes distances across all the features, it needs complete observations\n\n# drop incomplete observations\nno_missing_cancer = missing_cancer.dropna()\nprint(no_missing_cancer)\n\n       Class    Radius   Texture  Perimeter\n1  Malignant  1.828212 -0.353322   1.684473\n3  Malignant -0.768233  0.253509  -0.592166\n4  Malignant  1.748758 -1.150804   1.775011\n5  Malignant -0.475956 -0.834601  -0.386808\n6  Malignant  1.169878  0.160508   1.137124",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#missing-data-simpleimputer",
    "href": "materials/slides/classification1.html#missing-data-simpleimputer",
    "title": "Classification I: training & predicting",
    "section": "Missing data: SimpleImputer()",
    "text": "Missing data: SimpleImputer()\nWe can impute missing data (with the mean) if there‚Äôs too many missing values\n\nfrom sklearn.impute import SimpleImputer\n\npreprocessor = make_column_transformer(\n    (SimpleImputer(), [\"Radius\", \"Texture\", \"Perimeter\"]),\n    verbose_feature_names_out=False,\n)\npreprocessor\n\nColumnTransformer(transformers=[('simpleimputer', SimpleImputer(),\n                                 ['Radius', 'Texture', 'Perimeter'])],\n                  verbose_feature_names_out=False)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.ColumnTransformer?Documentation for ColumnTransformeriNot fitted\n        \n            \n                Parameters\n                \n\n\n\n\ntransformers¬†\n[('simpleimputer', ...)]\n\n\n\nremainder¬†\n'drop'\n\n\n\nsparse_threshold¬†\n0.3\n\n\n\nn_jobs¬†\nNone\n\n\n\ntransformer_weights¬†\nNone\n\n\n\nverbose¬†\nFalse\n\n\n\nverbose_feature_names_out¬†\nFalse\n\n\n\nforce_int_remainder_cols¬†\n'deprecated'\n\n\n\n\n            \n        \n    simpleimputer['Radius', 'Texture', 'Perimeter']SimpleImputer?Documentation for SimpleImputer\n        \n            \n                Parameters\n                \n\n\n\n\nmissing_values¬†\nnan\n\n\n\nstrategy¬†\n'mean'\n\n\n\nfill_value¬†\nNone\n\n\n\ncopy¬†\nTrue\n\n\n\nadd_indicator¬†\nFalse\n\n\n\nkeep_empty_features¬†\nFalse",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#imputed-data",
    "href": "materials/slides/classification1.html#imputed-data",
    "title": "Classification I: training & predicting",
    "section": "Imputed data",
    "text": "Imputed data\n\npreprocessor.fit(missing_cancer)\nimputed_cancer = preprocessor.transform(missing_cancer)\n\n\n\n\nprint(missing_cancer)\n\n       Class    Radius   Texture  Perimeter\n0  Malignant       NaN       NaN   1.268817\n1  Malignant  1.828212 -0.353322   1.684473\n2  Malignant  1.578499       NaN   1.565126\n3  Malignant -0.768233  0.253509  -0.592166\n4  Malignant  1.748758 -1.150804   1.775011\n5  Malignant -0.475956 -0.834601  -0.386808\n6  Malignant  1.169878  0.160508   1.137124\n\n\n\n\nprint(imputed_cancer)\n\n     Radius   Texture  Perimeter\n0  0.846860 -0.384942   1.268817\n1  1.828212 -0.353322   1.684473\n2  1.578499 -0.384942   1.565126\n3 -0.768233  0.253509  -0.592166\n4  1.748758 -1.150804   1.775011\n5 -0.475956 -0.834601  -0.386808\n6  1.169878  0.160508   1.137124",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#put-it-all-together-preprocessor",
    "href": "materials/slides/classification1.html#put-it-all-together-preprocessor",
    "title": "Classification I: training & predicting",
    "section": "Put it all together: Preprocessor",
    "text": "Put it all together: Preprocessor\n\n# load the unscaled cancer data, make Class readable\nunscaled_cancer = pd.read_csv(\"data/wdbc_unscaled.csv\")\nunscaled_cancer[\"Class\"] = unscaled_cancer[\"Class\"].replace(\n    {\"M\": \"Malignant\", \"B\": \"Benign\"}\n)\n\n# create the K-NN model\nknn = KNeighborsClassifier(n_neighbors=7)\n\n# create the centering / scaling preprocessor\npreprocessor = make_column_transformer(\n    (StandardScaler(), [\"Area\", \"Smoothness\"]),\n    # more column transformers here\n)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#put-it-all-together-pipeline",
    "href": "materials/slides/classification1.html#put-it-all-together-pipeline",
    "title": "Classification I: training & predicting",
    "section": "Put it all together: Pipeline",
    "text": "Put it all together: Pipeline\n\nfrom sklearn.pipeline import make_pipeline\n\nknn_pipeline = make_pipeline(preprocessor, knn)\nknn_pipeline.fit(\n    X=unscaled_cancer,\n    y=unscaled_cancer[\"Class\"]\n)\nknn_pipeline\n\nPipeline(steps=[('columntransformer',\n                 ColumnTransformer(transformers=[('standardscaler',\n                                                  StandardScaler(),\n                                                  ['Area', 'Smoothness'])])),\n                ('kneighborsclassifier', KNeighborsClassifier(n_neighbors=7))])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.Pipeline?Documentation for PipelineiFitted\n        \n            \n                Parameters\n                \n\n\n\n\nsteps¬†\n[('columntransformer', ...), ('kneighborsclassifier', ...)]\n\n\n\ntransform_input¬†\nNone\n\n\n\nmemory¬†\nNone\n\n\n\nverbose¬†\nFalse\n\n\n\n\n            \n        \n    columntransformer: ColumnTransformer?Documentation for columntransformer: ColumnTransformer\n        \n            \n                Parameters\n                \n\n\n\n\ntransformers¬†\n[('standardscaler', ...)]\n\n\n\nremainder¬†\n'drop'\n\n\n\nsparse_threshold¬†\n0.3\n\n\n\nn_jobs¬†\nNone\n\n\n\ntransformer_weights¬†\nNone\n\n\n\nverbose¬†\nFalse\n\n\n\nverbose_feature_names_out¬†\nTrue\n\n\n\nforce_int_remainder_cols¬†\n'deprecated'\n\n\n\n\n            \n        \n    standardscaler['Area', 'Smoothness']StandardScaler?Documentation for StandardScaler\n        \n            \n                Parameters\n                \n\n\n\n\ncopy¬†\nTrue\n\n\n\nwith_mean¬†\nTrue\n\n\n\nwith_std¬†\nTrue\n\n\n\n\n            \n        \n    KNeighborsClassifier?Documentation for KNeighborsClassifier\n        \n            \n                Parameters\n                \n\n\n\n\nn_neighbors¬†\n7\n\n\n\nweights¬†\n'uniform'\n\n\n\nalgorithm¬†\n'auto'\n\n\n\nleaf_size¬†\n30\n\n\n\np¬†\n2\n\n\n\nmetric¬†\n'minkowski'\n\n\n\nmetric_params¬†\nNone\n\n\n\nn_jobs¬†\nNone",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#put-it-all-together-predict",
    "href": "materials/slides/classification1.html#put-it-all-together-predict",
    "title": "Classification I: training & predicting",
    "section": "Put it all together: Predict",
    "text": "Put it all together: Predict\n\nnew_observation = pd.DataFrame(\n    {\"Area\": [500, 1500], \"Smoothness\": [0.075, 0.1]}\n)\nprediction = knn_pipeline.predict(new_observation)\nprediction\n\narray(['Benign', 'Malignant'], dtype=object)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#prediction-area",
    "href": "materials/slides/classification1.html#prediction-area",
    "title": "Classification I: training & predicting",
    "section": "Prediction Area",
    "text": "Prediction Area\nModel prediction area.\n\n\n\n\n\n\n\n\n\nPoints are on original unscaled data\nArea is using the pipeline model",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#reference-code",
    "href": "materials/slides/classification1.html#reference-code",
    "title": "Classification I: training & predicting",
    "section": "Reference Code",
    "text": "Reference Code\n\n\n\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.compose import (\n    make_column_transformer,\n)\n\n\n# load the unscaled cancer data\nunscaled_cancer = pd.read_csv(\n    \"data/wdbc_unscaled.csv\"\n)\n\n# make Class readable\nunscaled_cancer[\"Class\"] = unscaled_cancer[\n    \"Class\"\n].replace({\"M\": \"Malignant\", \"B\": \"Benign\"})\n\n\n\n# create the K-NN model\nknn = KNeighborsClassifier(n_neighbors=7)\n\n# create the centering / scaling preprocessor\npreprocessor = make_column_transformer(\n    (StandardScaler(), ['Area', 'Smoothness']),\n    # more column transformers here\n)\n\nknn_pipeline = make_pipeline(preprocessor, knn)\nknn_pipeline.fit(X=unscaled_cancer, y=unscaled_cancer['Class'])\nknn_pipeline\n\nnew_observation = pd.DataFrame(\n    {\n        'Area': [500, 1500],\n        'Smoothness': [0.075, 0.1],\n    }\n)\nprediction = knn_pipeline.predict(new_observation)\nprediction\n\narray(['Benign', 'Malignant'], dtype=object)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#clicker-questions",
    "href": "materials/slides/classification1.html#clicker-questions",
    "title": "Classification I: training & predicting",
    "section": "Clicker questions",
    "text": "Clicker questions\n\nhttps://www.menti.com/alpi9oanfsf9\nAlternatively, go to menti.com and use code 8481 0955",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#additional-resources",
    "href": "materials/slides/classification1.html#additional-resources",
    "title": "Classification I: training & predicting",
    "section": "Additional resources",
    "text": "Additional resources\n\nThe Classification I: training & predicting chapter of Data Science: A First Introduction (Python Edition) by Tiffany Timbers, Trevor Campbell, Melissa Lee, Joel Ostblom, Lindsey Heagy contains all the content presented here with a detailed narrative.\nThe scikit-learn website is an excellent reference for more details on, and advanced usage of, the functions and packages in this lesson. Aside from that, it also offers many useful tutorials to get you started.\nAn Introduction to Statistical Learning by Gareth James Daniela Witten Trevor Hastie, and Robert Tibshirani provides a great next stop in the process of learning about classification. Chapter 4 discusses additional basic techniques for classification that we do not cover, such as logistic regression, linear discriminant analysis, and naive Bayes.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/slides/classification1.html#references",
    "href": "materials/slides/classification1.html#references",
    "title": "Classification I: training & predicting",
    "section": "References",
    "text": "References\nLars Buitinck, Gilles Louppe, Mathieu Blondel, Fabian Pedregosa, Andreas Mueller, Olivier Grisel, Vlad Niculae, Peter Prettenhofer, Alexandre Gramfort, Jaques Grobler, Robert Layton, Jake VanderPlas, Arnaud Joly, Brian Holt, and Ga√´l Varoquaux. API design for machine learning software: experiences from the scikit-learn project. In ECML PKDD Workshop: Languages for Data Mining and Machine Learning, 108‚Äì122. 2013.\nThomas Cover and Peter Hart. Nearest neighbor pattern classification. IEEE Transactions on Information Theory, 13(1):21‚Äì27, 1967.\nEvelyn Fix and Joseph Hodges. Discriminatory analysis. nonparametric discrimination: consistency properties. Technical Report, USAF School of Aviation Medicine, Randolph Field, Texas, 1951.\nWilliam Nick Street, William Wolberg, and Olvi Mangasarian. Nuclear feature extraction for breast tumor diagnosis. In International Symposium on Electronic Imaging: Science and Technology. 1993.\nStanford Health Care. What is cancer? 2021. URL: https://stanfordhealthcare.org/medical-conditions/cancer/cancer.html.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification I: training & predicting"
    ]
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification1/py_worksheet_classification1.html",
    "href": "materials/worksheets/py_worksheet_classification1/py_worksheet_classification1.html",
    "title": "Worksheet Classification (Part I)",
    "section": "",
    "text": "After completing this workshop session, you will be able to:\n\nRecognize situations where a simple classifier would be appropriate for making predictions.\nExplain the \\(K\\)-nearest neighbour classification algorithm.\nInterpret the output of a classifier.\nCompute, by hand, the distance between points when there are two explanatory variables/predictors.\nDescribe what a training data set is and how it is used in classification.\nGiven a dataset with two explanatory variables/predictors, use \\(K\\)-nearest neighbour classification in Python using the scikit-learn framework to predict the class of a single new observation.\n\nThis worksheet covers parts of Chapter 5 of the online textbook. You should read this chapter to gain a better understanding of the assignment. Any place you see ___, you must fill in the function, variable, or data to complete the code. Substitute the raise NotImplementedError with your completed code and answers then proceed to run the cell.\n\n### Run this cell before continuing\nimport random\n\nimport altair as alt\nimport pandas as pd\nfrom sklearn.compose import make_column_transformer\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.metrics.pairwise import euclidean_distances\nfrom sklearn import set_config\n\n# Simplify working with large datasets in Altair\nalt.data_transformers.disable_max_rows()\n\n# Output dataframes instead of arrays\nset_config(transform_output=\"pandas\")"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification1/py_worksheet_classification1.html#learning-goals",
    "href": "materials/worksheets/py_worksheet_classification1/py_worksheet_classification1.html#learning-goals",
    "title": "Worksheet Classification (Part I)",
    "section": "",
    "text": "After completing this workshop session, you will be able to:\n\nRecognize situations where a simple classifier would be appropriate for making predictions.\nExplain the \\(K\\)-nearest neighbour classification algorithm.\nInterpret the output of a classifier.\nCompute, by hand, the distance between points when there are two explanatory variables/predictors.\nDescribe what a training data set is and how it is used in classification.\nGiven a dataset with two explanatory variables/predictors, use \\(K\\)-nearest neighbour classification in Python using the scikit-learn framework to predict the class of a single new observation.\n\nThis worksheet covers parts of Chapter 5 of the online textbook. You should read this chapter to gain a better understanding of the assignment. Any place you see ___, you must fill in the function, variable, or data to complete the code. Substitute the raise NotImplementedError with your completed code and answers then proceed to run the cell.\n\n### Run this cell before continuing\nimport random\n\nimport altair as alt\nimport pandas as pd\nfrom sklearn.compose import make_column_transformer\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.metrics.pairwise import euclidean_distances\nfrom sklearn import set_config\n\n# Simplify working with large datasets in Altair\nalt.data_transformers.disable_max_rows()\n\n# Output dataframes instead of arrays\nset_config(transform_output=\"pandas\")"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification1/py_worksheet_classification1.html#breast-cancer-data-set",
    "href": "materials/worksheets/py_worksheet_classification1/py_worksheet_classification1.html#breast-cancer-data-set",
    "title": "Worksheet Classification (Part I)",
    "section": "1. Breast Cancer Data Set",
    "text": "1. Breast Cancer Data Set\nWe will work with the breast cancer data from this from the accompanying textbook chapter.\n\nNote that the breast cancer data in this worksheet have been standardized (centred and scaled) for you already. We will implement these steps in future worksheet later, but for now, know the data has been standardized. Therefore the variables are unitless and hence why we have zero and negative values for variables like Radius.\n\nQuestion 1.0  {points: 1}\nRead the clean-wdbc-data.csv file (found in the data directory) using the pd.read_csv function into the notebook and store it as a data frame. Name it cancer.\n\n# your code here\nraise NotImplementedError\ncancer\n\n\n---------------------------------------------------------------------------\nNotImplementedError                       Traceback (most recent call last)\nCell In[2], line 2\n      1 # your code here\n----&gt; 2 raise NotImplementedError\n      3 cancer\n\nNotImplementedError: \n\n\n\n\nfrom hashlib import sha1\nassert sha1(str(type(cancer is None)).encode(\"utf-8\")+b\"1edfa\").hexdigest() == \"f89107c5738f5567ac4ce7e619af326d8dc7e7e4\", \"type of cancer is None is not bool. cancer is None should be a bool\"\nassert sha1(str(cancer is None).encode(\"utf-8\")+b\"1edfa\").hexdigest() == \"71bbe216c3f112174b74da6122dd837cb4abaafa\", \"boolean value of cancer is None is not correct\"\n\nassert sha1(str(type(cancer)).encode(\"utf-8\")+b\"1edfb\").hexdigest() == \"5f4717efa0f9568127506afdab187398929a3f76\", \"type of type(cancer) is not correct\"\n\nassert sha1(str(type(cancer.shape)).encode(\"utf-8\")+b\"1edfc\").hexdigest() == \"6790c026fc62f7f025cc5dfb65b5589e70c94f24\", \"type of cancer.shape is not tuple. cancer.shape should be a tuple\"\nassert sha1(str(len(cancer.shape)).encode(\"utf-8\")+b\"1edfc\").hexdigest() == \"e400bacf4406589a930f6cb04146f55ae09adbe1\", \"length of cancer.shape is not correct\"\nassert sha1(str(sorted(map(str, cancer.shape))).encode(\"utf-8\")+b\"1edfc\").hexdigest() == \"bc58412175f96aad1b5f00e35cbf014630e9667a\", \"values of cancer.shape are not correct\"\nassert sha1(str(cancer.shape).encode(\"utf-8\")+b\"1edfc\").hexdigest() == \"03f45e6b2934a9d89a82761d8cd384e41a96882e\", \"order of elements of cancer.shape is not correct\"\n\nassert sha1(str(type(sum(cancer.Area))).encode(\"utf-8\")+b\"1edfd\").hexdigest() == \"8459034dfcce3dc398256d3235e7ea1c0a6eab66\", \"type of sum(cancer.Area) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(cancer.Area), 2)).encode(\"utf-8\")+b\"1edfd\").hexdigest() == \"578eeb3cce10656ea3740570a63c462e74b5bee3\", \"value of sum(cancer.Area) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(cancer.columns.values)).encode(\"utf-8\")+b\"1edfe\").hexdigest() == \"ec1b028616e5bf668b318569d326edbe4fa5792d\", \"type of cancer.columns.values is not correct\"\nassert sha1(str(cancer.columns.values).encode(\"utf-8\")+b\"1edfe\").hexdigest() == \"46e462ccc418670863709af1c7c6c89e4aa501be\", \"value of cancer.columns.values is not correct\"\n\nassert sha1(str(type(cancer['Class'].dtype)).encode(\"utf-8\")+b\"1edff\").hexdigest() == \"0c82f629a8e37cf9fc16959e34213e0fa89a6a68\", \"type of cancer['Class'].dtype is not correct\"\nassert sha1(str(cancer['Class'].dtype).encode(\"utf-8\")+b\"1edff\").hexdigest() == \"852a6171a68036a67ec486822760a69c8cd61e0d\", \"value of cancer['Class'].dtype is not correct\"\n\nprint('Success!')\n\nSuccess!\n\n\nQuestion 1.1 True or False:  {points: 1}\nAfter looking at the first six rows of the cancer data fame, suppose we asked you to predict the variable ‚Äúarea‚Äù for a new observation. Is this a classification problem?\nAssign your answer to an object called answer1_1. Make sure the correct answer is a boolean. i.e.¬†True or False.\n\n# your code here\nraise NotImplementedError\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer1_1)).encode(\"utf-8\")+b\"3524b\").hexdigest() == \"96e967f4261014f1a2a76ba5f230d7b7e85abe83\", \"type of answer1_1 is not bool. answer1_1 should be a bool\"\nassert sha1(str(answer1_1).encode(\"utf-8\")+b\"3524b\").hexdigest() == \"88e4fbb75d430084961a28b324179d14f4999b12\", \"boolean value of answer1_1 is not correct\"\n\nprint('Success!')\n\nQuestion 1.2  {points: 1}\nCreate a scatterplot of the data with Symmetry on the x-axis and Radius on the y-axis. Modify your aesthetics by colouring for Class. As you create this plot, ensure you follow the guidelines for creating effective visualizations. In particular, note in the chart axis titles whether the data is standardized or not and add a suitable opacity level to the graphical mark. You should also replace the values in the dataframe‚Äôs Class column from 'M' to 'Malignant' and from 'B' to 'Benign'.\nAssign your plot to an object called cancer_plot.\n\ncancer[\"Class\"] = cancer[\"Class\"].replace({\n    'M' : 'Malignant',\n    'B' : 'Benign'\n})\ncancer_plot = alt.Chart(cancer).mark_point(opacity=0.5).encode(\n    x=alt.X(\"Symmetry\").title(\"Standardized symmetry\"),\n    y=alt.Y(\"Radius\").title(\"Standardized radius\"),\n    color=alt.Color(\"Class\").title(\"Diagnosis\")\n)\ncancer_plot\n\n\nfrom hashlib import sha1\nassert sha1(str(type(cancer['Class'].unique())).encode(\"utf-8\")+b\"7038e\").hexdigest() == \"2c870d7a3657b742557d66961de4a4891ee76aa2\", \"type of cancer['Class'].unique() is not correct\"\nassert sha1(str(cancer['Class'].unique()).encode(\"utf-8\")+b\"7038e\").hexdigest() == \"7be82206c225ab0f0a4ffad7c1488a64143481f7\", \"value of cancer['Class'].unique() is not correct\"\n\nassert sha1(str(type(cancer_plot is None)).encode(\"utf-8\")+b\"7038f\").hexdigest() == \"5f05f0c0e171e12d0d2b2a22d2789f0d9a8e342e\", \"type of cancer_plot is None is not bool. cancer_plot is None should be a bool\"\nassert sha1(str(cancer_plot is None).encode(\"utf-8\")+b\"7038f\").hexdigest() == \"515f1ad42fa781dff7c9975c8ded7f317ce95332\", \"boolean value of cancer_plot is None is not correct\"\n\nassert sha1(str(type(cancer_plot.encoding.x['shorthand'])).encode(\"utf-8\")+b\"70390\").hexdigest() == \"1b054e65bf0aac12e848da1d2afa2b12a5226b61\", \"type of cancer_plot.encoding.x['shorthand'] is not str. cancer_plot.encoding.x['shorthand'] should be an str\"\nassert sha1(str(len(cancer_plot.encoding.x['shorthand'])).encode(\"utf-8\")+b\"70390\").hexdigest() == \"dd930b7fa9aa4d16b4d1a89c7a39089300827489\", \"length of cancer_plot.encoding.x['shorthand'] is not correct\"\nassert sha1(str(cancer_plot.encoding.x['shorthand'].lower()).encode(\"utf-8\")+b\"70390\").hexdigest() == \"dd17739f27d755296153ed0ec742286fd3b39cb2\", \"value of cancer_plot.encoding.x['shorthand'] is not correct\"\nassert sha1(str(cancer_plot.encoding.x['shorthand']).encode(\"utf-8\")+b\"70390\").hexdigest() == \"d4212b1d5679f4601309609b6ea38ffb2d4ed07c\", \"correct string value of cancer_plot.encoding.x['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(cancer_plot.encoding.y['shorthand'])).encode(\"utf-8\")+b\"70391\").hexdigest() == \"6fac44d279065f2a3f185c5a884fd9df6dd81cfb\", \"type of cancer_plot.encoding.y['shorthand'] is not str. cancer_plot.encoding.y['shorthand'] should be an str\"\nassert sha1(str(len(cancer_plot.encoding.y['shorthand'])).encode(\"utf-8\")+b\"70391\").hexdigest() == \"df067cfef2a7c5291dd0f9acc53fe92d50ccf1fe\", \"length of cancer_plot.encoding.y['shorthand'] is not correct\"\nassert sha1(str(cancer_plot.encoding.y['shorthand'].lower()).encode(\"utf-8\")+b\"70391\").hexdigest() == \"edf8bc4ede29cf991a36bb6d8b38713806753b47\", \"value of cancer_plot.encoding.y['shorthand'] is not correct\"\nassert sha1(str(cancer_plot.encoding.y['shorthand']).encode(\"utf-8\")+b\"70391\").hexdigest() == \"e3f5fd9a0d9f3c695791e536282f29ee7d2c6b4a\", \"correct string value of cancer_plot.encoding.y['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(cancer_plot.encoding.color['shorthand'])).encode(\"utf-8\")+b\"70392\").hexdigest() == \"a1514e0d638e7fa47039d17e310bba44e6a8ff2c\", \"type of cancer_plot.encoding.color['shorthand'] is not str. cancer_plot.encoding.color['shorthand'] should be an str\"\nassert sha1(str(len(cancer_plot.encoding.color['shorthand'])).encode(\"utf-8\")+b\"70392\").hexdigest() == \"a43d370b386a7d21c0ac8e73bdc942b85ee93cae\", \"length of cancer_plot.encoding.color['shorthand'] is not correct\"\nassert sha1(str(cancer_plot.encoding.color['shorthand'].lower()).encode(\"utf-8\")+b\"70392\").hexdigest() == \"a2e54ddb2a451b8647df9f5b9aae970b19620f66\", \"value of cancer_plot.encoding.color['shorthand'] is not correct\"\nassert sha1(str(cancer_plot.encoding.color['shorthand']).encode(\"utf-8\")+b\"70392\").hexdigest() == \"dfff632fd3104b75a651bf07567aa5d572835f70\", \"correct string value of cancer_plot.encoding.color['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(cancer_plot.mark)).encode(\"utf-8\")+b\"70393\").hexdigest() == \"e736aec18d8c2224b69bfe505db7d3968a4a2c7e\", \"type of cancer_plot.mark is not correct\"\nassert sha1(str(cancer_plot.mark).encode(\"utf-8\")+b\"70393\").hexdigest() == \"1746955c8bc53ef47b4cf0267c98ce50ce3b184a\", \"value of cancer_plot.mark is not correct\"\n\nassert sha1(str(type(isinstance(cancer_plot.encoding.color['title'], str))).encode(\"utf-8\")+b\"70394\").hexdigest() == \"40775fb7d185dcb2ad7acf54925bb5075bd50aca\", \"type of isinstance(cancer_plot.encoding.color['title'], str) is not bool. isinstance(cancer_plot.encoding.color['title'], str) should be a bool\"\nassert sha1(str(isinstance(cancer_plot.encoding.color['title'], str)).encode(\"utf-8\")+b\"70394\").hexdigest() == \"e42ecc8f1d08c9a9cbb062b31d6180e6271e740b\", \"boolean value of isinstance(cancer_plot.encoding.color['title'], str) is not correct\"\n\nassert sha1(str(type(isinstance(cancer_plot.encoding.x['title'], str))).encode(\"utf-8\")+b\"70395\").hexdigest() == \"711e00550c10a33b1b90544076b3b8d4a89d23bf\", \"type of isinstance(cancer_plot.encoding.x['title'], str) is not bool. isinstance(cancer_plot.encoding.x['title'], str) should be a bool\"\nassert sha1(str(isinstance(cancer_plot.encoding.x['title'], str)).encode(\"utf-8\")+b\"70395\").hexdigest() == \"b697a6b22f874c7f85b3e081a24d1b5cdd084659\", \"boolean value of isinstance(cancer_plot.encoding.x['title'], str) is not correct\"\n\nassert sha1(str(type(isinstance(cancer_plot.encoding.y['title'], str))).encode(\"utf-8\")+b\"70396\").hexdigest() == \"37f686ca3136e2e102714b66fd51cf3ef4703fc6\", \"type of isinstance(cancer_plot.encoding.y['title'], str) is not bool. isinstance(cancer_plot.encoding.y['title'], str) should be a bool\"\nassert sha1(str(isinstance(cancer_plot.encoding.y['title'], str)).encode(\"utf-8\")+b\"70396\").hexdigest() == \"d0eb5c4439424db54df14662a17296d7dc74ff3d\", \"boolean value of isinstance(cancer_plot.encoding.y['title'], str) is not correct\"\n\nprint('Success!')\n\nQuestion 1.3  {points: 1}\nJust by looking at the scatterplot above, how would you classify an observation with Symmetry = 1 and Radius = 1 (Benign or Malignant)?\nAssign your answer to an object called answer1_3. Make sure the correct answer is written fully. Remember to surround your answer with quotation marks (e.g.¬†‚ÄúBenign‚Äù / ‚ÄúMalignant‚Äù).\n\n# your code here\nraise NotImplementedError\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer1_3)).encode(\"utf-8\")+b\"192dd\").hexdigest() == \"c22b7e131d7091f92de118d328cf99ebfc373e56\", \"type of answer1_3 is not str. answer1_3 should be an str\"\nassert sha1(str(len(answer1_3)).encode(\"utf-8\")+b\"192dd\").hexdigest() == \"426e383fda7dfde77b6cbef2a70be0047a593331\", \"length of answer1_3 is not correct\"\nassert sha1(str(answer1_3.lower()).encode(\"utf-8\")+b\"192dd\").hexdigest() == \"04f0ffa0d0870e9e4d9a8bf7bb1ed255f9165a52\", \"value of answer1_3 is not correct\"\nassert sha1(str(answer1_3).encode(\"utf-8\")+b\"192dd\").hexdigest() == \"11394ec2da0fa66e3dd679f582c3d6024557dc1a\", \"correct string value of answer1_3 but incorrect case of letters\"\n\nprint('Success!')"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification1/py_worksheet_classification1.html#using-scikit-learn-to-perform-k-nearest-neighbours",
    "href": "materials/worksheets/py_worksheet_classification1/py_worksheet_classification1.html#using-scikit-learn-to-perform-k-nearest-neighbours",
    "title": "Worksheet Classification (Part I)",
    "section": "2. Using scikit-learn to perform k-nearest neighbours",
    "text": "2. Using scikit-learn to perform k-nearest neighbours\nNow that we understand how K-nearest neighbours (k-nn) classification works, let‚Äôs get familar with the scikit-learn Python package. The benefit of using scikit-learn is that it will keep our code simple, readable and accurate. Coding less and in a tidier format means that there is less chance for errors to occur.\nWe‚Äôll again focus on Radius and Symmetry as the two predictors. This time, we would like to predict the class of a new observation with Symmetry = 1 and Radius = 0. This one is a bit tricky to do visually from the plot below, and so is a motivating example for us to compute the prediction using k-nn with the scikit-learn package. Let‚Äôs use K = 7.\n\n# Run this to remind yourself what the data looks like\ncancer_plot\n\nQuestion 2.1  {points: 1}\nCreate a model for K-nearest neighbours classification by using the KNeighborsClassifier function. Specify that we want to set n_neighbors = 7.\nName your model specification knn_spec.\n\n# ___ = KNeighborsClassifier(n_neighbors=___)\n\n# your code here\nraise NotImplementedError\nknn_spec\n\n\nfrom hashlib import sha1\nassert sha1(str(type(knn_spec is None)).encode(\"utf-8\")+b\"2245\").hexdigest() == \"78a85e8a7790e4e7a7d20d518a6e9e23249aeb08\", \"type of knn_spec is None is not bool. knn_spec is None should be a bool\"\nassert sha1(str(knn_spec is None).encode(\"utf-8\")+b\"2245\").hexdigest() == \"b44afb32e99c75fdbfb62a424921d1a2fa6f12ee\", \"boolean value of knn_spec is None is not correct\"\n\nassert sha1(str(type(knn_spec.n_neighbors)).encode(\"utf-8\")+b\"2246\").hexdigest() == \"1458700d2adfd82356dfd982b7941979cbd45589\", \"type of knn_spec.n_neighbors is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(knn_spec.n_neighbors).encode(\"utf-8\")+b\"2246\").hexdigest() == \"22e82178737bce10c71283d1cf37544dd1dcbbb8\", \"value of knn_spec.n_neighbors is not correct\"\n\nassert sha1(str(type(knn_spec.algorithm)).encode(\"utf-8\")+b\"2247\").hexdigest() == \"c71db7d462b7abd56ce64492cec1d48ea9040224\", \"type of knn_spec.algorithm is not str. knn_spec.algorithm should be an str\"\nassert sha1(str(len(knn_spec.algorithm)).encode(\"utf-8\")+b\"2247\").hexdigest() == \"fc15a33f2e81ff2a1ebe2cdd52ca95582dc1df46\", \"length of knn_spec.algorithm is not correct\"\nassert sha1(str(knn_spec.algorithm.lower()).encode(\"utf-8\")+b\"2247\").hexdigest() == \"6fb8474d83ec0dc215e52cdc08b990751b7d94a9\", \"value of knn_spec.algorithm is not correct\"\nassert sha1(str(knn_spec.algorithm).encode(\"utf-8\")+b\"2247\").hexdigest() == \"6fb8474d83ec0dc215e52cdc08b990751b7d94a9\", \"correct string value of knn_spec.algorithm but incorrect case of letters\"\n\nprint('Success!')\n\nQuestion 2.2  {points: 1}\nTo train the model on the breast cancer dataset, pass knn_spec and the cancer dataset to the .fit function. Specify Class as your target variable and the Symmetry and Radius variables as your predictors. Name your fitted model as knn_fit.\n\n# X = ___[[\"Symmetry\", ___]]\n# y = ___[___]\n# ___ = ___.fit(___, ___)\n\n# your code here\nraise NotImplementedError\nknn_fit\n\n\nfrom hashlib import sha1\nassert sha1(str(type(knn_fit is None)).encode(\"utf-8\")+b\"2bff6\").hexdigest() == \"56a79c088e5ec5a42b96d6ea0d14cd8712fac03e\", \"type of knn_fit is None is not bool. knn_fit is None should be a bool\"\nassert sha1(str(knn_fit is None).encode(\"utf-8\")+b\"2bff6\").hexdigest() == \"268e8a79ae1936524d056ca5169d2c71a72e70a5\", \"boolean value of knn_fit is None is not correct\"\n\nassert sha1(str(type(type(knn_fit))).encode(\"utf-8\")+b\"2bff7\").hexdigest() == \"097a69bbecb57e7e121a5edde688e93d2fbf9d17\", \"type of type(knn_fit) is not correct\"\nassert sha1(str(type(knn_fit)).encode(\"utf-8\")+b\"2bff7\").hexdigest() == \"40872fc0b9fdb9d1467bfb606dfb31df50cfe4ea\", \"value of type(knn_fit) is not correct\"\n\nassert sha1(str(type(knn_fit.classes_)).encode(\"utf-8\")+b\"2bff8\").hexdigest() == \"cb4bb5ca40cc7954a382bfa33bd1532a3df2e583\", \"type of knn_fit.classes_ is not correct\"\nassert sha1(str(knn_fit.classes_).encode(\"utf-8\")+b\"2bff8\").hexdigest() == \"c422ff7ed5336560783f0ada3740882c912a4d97\", \"value of knn_fit.classes_ is not correct\"\n\nassert sha1(str(type(knn_fit.effective_metric_)).encode(\"utf-8\")+b\"2bff9\").hexdigest() == \"aa9d11a76326cf64bec451997ff4ae28ec4e2a9a\", \"type of knn_fit.effective_metric_ is not str. knn_fit.effective_metric_ should be an str\"\nassert sha1(str(len(knn_fit.effective_metric_)).encode(\"utf-8\")+b\"2bff9\").hexdigest() == \"6e6efca67ebf0603a534109614346757c0ef146d\", \"length of knn_fit.effective_metric_ is not correct\"\nassert sha1(str(knn_fit.effective_metric_.lower()).encode(\"utf-8\")+b\"2bff9\").hexdigest() == \"49892ddeb7ca1f1c4bf772ff4a585dd10249b813\", \"value of knn_fit.effective_metric_ is not correct\"\nassert sha1(str(knn_fit.effective_metric_).encode(\"utf-8\")+b\"2bff9\").hexdigest() == \"49892ddeb7ca1f1c4bf772ff4a585dd10249b813\", \"correct string value of knn_fit.effective_metric_ but incorrect case of letters\"\n\nassert sha1(str(type(knn_fit.n_features_in_)).encode(\"utf-8\")+b\"2bffa\").hexdigest() == \"08548a765b78a776a8b132bc9a51a75e1d960554\", \"type of knn_fit.n_features_in_ is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(knn_fit.n_features_in_).encode(\"utf-8\")+b\"2bffa\").hexdigest() == \"114d53a02f71bf2cea7abe3280555955b16647b8\", \"value of knn_fit.n_features_in_ is not correct\"\n\nassert sha1(str(type(X.columns.values)).encode(\"utf-8\")+b\"2bffb\").hexdigest() == \"bd7b6259f8053a315fca30986b168530209f266d\", \"type of X.columns.values is not correct\"\nassert sha1(str(X.columns.values).encode(\"utf-8\")+b\"2bffb\").hexdigest() == \"b7dfb165b13d0e67f16b09e1dc18733df42a65a0\", \"value of X.columns.values is not correct\"\n\nassert sha1(str(type(y.name)).encode(\"utf-8\")+b\"2bffc\").hexdigest() == \"e8b9e2753401141ac2885e2394f32cc9cffa348a\", \"type of y.name is not str. y.name should be an str\"\nassert sha1(str(len(y.name)).encode(\"utf-8\")+b\"2bffc\").hexdigest() == \"793a9c94797d9b5899e9865188980d72d080ac2d\", \"length of y.name is not correct\"\nassert sha1(str(y.name.lower()).encode(\"utf-8\")+b\"2bffc\").hexdigest() == \"bcffa9a693072729c80524aafde25fd6b259f4c3\", \"value of y.name is not correct\"\nassert sha1(str(y.name).encode(\"utf-8\")+b\"2bffc\").hexdigest() == \"788a47e28ae9d6cd3cbf4823a5d93017aa6addd9\", \"correct string value of y.name but incorrect case of letters\"\n\nassert sha1(str(type(sum(X.Symmetry))).encode(\"utf-8\")+b\"2bffd\").hexdigest() == \"903f7c4e29e57fe29f567ef056e34f51335aec78\", \"type of sum(X.Symmetry) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(X.Symmetry), 2)).encode(\"utf-8\")+b\"2bffd\").hexdigest() == \"9397d4f7e4087a12b928268b533b6f46554e7efa\", \"value of sum(X.Symmetry) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(sum(X.Radius))).encode(\"utf-8\")+b\"2bffe\").hexdigest() == \"d9df2ec2ea3462b25d7d591366163062bdb4021e\", \"type of sum(X.Radius) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(X.Radius), 2)).encode(\"utf-8\")+b\"2bffe\").hexdigest() == \"5bd565738755b0a3859dbce84dffc4a36fe6656e\", \"value of sum(X.Radius) is not correct (rounded to 2 decimal places)\"\n\nprint('Success!')\n\nQuestion 2.3 {points: 1}\nNow we will make our prediction on the Class of a new observation with a Symmetry of 1 and a Radius of 0. First, create a dataframe with these variables and values and call it new_obs. Next, use the .predict function to obtain our prediction by passing knn_fit and new_obs to it. Name your predicted class as class_prediction.\n\n# ___ = pd.DataFrame([[1, 0]], columns=[___, ___])\n# ___ = ___.predict(___)\n\n# your code here\nraise NotImplementedError\nclass_prediction\n\n\nfrom hashlib import sha1\nassert sha1(str(type(new_obs is None)).encode(\"utf-8\")+b\"cc461\").hexdigest() == \"ab0357cbb8bfe0c9949b6d69e4c245d2af0635c6\", \"type of new_obs is None is not bool. new_obs is None should be a bool\"\nassert sha1(str(new_obs is None).encode(\"utf-8\")+b\"cc461\").hexdigest() == \"a170f5d0292d586ae590d1baca2f13355fb1c178\", \"boolean value of new_obs is None is not correct\"\n\nassert sha1(str(type(new_obs)).encode(\"utf-8\")+b\"cc462\").hexdigest() == \"46dce56999c53d1950618cc8e55690c524892a78\", \"type of type(new_obs) is not correct\"\n\nassert sha1(str(type(new_obs.Symmetry.values)).encode(\"utf-8\")+b\"cc463\").hexdigest() == \"113c0758f0ab20fd6712d816469f64cbc4243a12\", \"type of new_obs.Symmetry.values is not correct\"\nassert sha1(str(new_obs.Symmetry.values).encode(\"utf-8\")+b\"cc463\").hexdigest() == \"a41abcf000cf506078cdf4e306ca8121772da0f6\", \"value of new_obs.Symmetry.values is not correct\"\n\nassert sha1(str(type(new_obs.Radius.values)).encode(\"utf-8\")+b\"cc464\").hexdigest() == \"ca2beddfd89352b63fc45c70ca25260e7271c928\", \"type of new_obs.Radius.values is not correct\"\nassert sha1(str(new_obs.Radius.values).encode(\"utf-8\")+b\"cc464\").hexdigest() == \"195b0a370675aea18bf01c541c099428f4e248bd\", \"value of new_obs.Radius.values is not correct\"\n\nassert sha1(str(type(class_prediction is None)).encode(\"utf-8\")+b\"cc465\").hexdigest() == \"1ebd9c72926a2430221b10ae35a374b95040d55f\", \"type of class_prediction is None is not bool. class_prediction is None should be a bool\"\nassert sha1(str(class_prediction is None).encode(\"utf-8\")+b\"cc465\").hexdigest() == \"883aa082b8853226ec339ff84fd4744558d7fd3b\", \"boolean value of class_prediction is None is not correct\"\n\nassert sha1(str(type(class_prediction)).encode(\"utf-8\")+b\"cc466\").hexdigest() == \"a0d1780e9e6b14b3a86e32b907408ae8253ceec5\", \"type of class_prediction is not correct\"\nassert sha1(str(class_prediction).encode(\"utf-8\")+b\"cc466\").hexdigest() == \"2704eb31133cad075ccb97f6c93ca707487c9642\", \"value of class_prediction is not correct\"\n\nprint('Success!')\n\nQuestion 2.4  {points: 1}\nLet‚Äôs perform K-nearest neighbour classification again, but with three predictors. Use the scikit-learn package and K = 7 to classify a new observation where we measure Symmetry = 1, Radius = 0 and Concavity = 1. Use the scaffolding from Questions 2.2 and 2.3 to help you.\n\nPass the same knn_spec from before to fit, but this time specify Symmetry, Radius, and Concavity as the predictors. Save the predictor as X_2 and the target as y_2. Store the output in knn_fit_2.\nStore the new observation values in an object called new_obs_2.\nStore the output of predict in an object called class_prediction_2.\n\n\n# your code here\nraise NotImplementedError\nclass_prediction_2\n\n\nfrom hashlib import sha1\nassert sha1(str(type(knn_fit_2 is None)).encode(\"utf-8\")+b\"1c52c\").hexdigest() == \"56fcaa2be4db81bcc9472911429b629cba6101f3\", \"type of knn_fit_2 is None is not bool. knn_fit_2 is None should be a bool\"\nassert sha1(str(knn_fit_2 is None).encode(\"utf-8\")+b\"1c52c\").hexdigest() == \"99533bc9488848c2608ec11993eb5cfe3033cdf5\", \"boolean value of knn_fit_2 is None is not correct\"\n\nassert sha1(str(type(knn_fit_2.kneighbors)).encode(\"utf-8\")+b\"1c52d\").hexdigest() == \"3f30af90ec8c1a811004f1225ae54fbd83681019\", \"type of knn_fit_2.kneighbors is not correct\"\nassert sha1(str(knn_fit_2.kneighbors).encode(\"utf-8\")+b\"1c52d\").hexdigest() == \"55cb84f4cc156f43e6f8f2b5aa8379f34d7d579d\", \"value of knn_fit_2.kneighbors is not correct\"\n\nassert sha1(str(type(knn_fit_2.effective_metric_)).encode(\"utf-8\")+b\"1c52e\").hexdigest() == \"4a071b6a39a1366f1c50cfff6bf5bafe83bd944b\", \"type of knn_fit_2.effective_metric_ is not str. knn_fit_2.effective_metric_ should be an str\"\nassert sha1(str(len(knn_fit_2.effective_metric_)).encode(\"utf-8\")+b\"1c52e\").hexdigest() == \"6949133fe0bc9d23f3f2391308a85eeac883a74a\", \"length of knn_fit_2.effective_metric_ is not correct\"\nassert sha1(str(knn_fit_2.effective_metric_.lower()).encode(\"utf-8\")+b\"1c52e\").hexdigest() == \"fed6a9fc14d942c80421836e802e4f459699e299\", \"value of knn_fit_2.effective_metric_ is not correct\"\nassert sha1(str(knn_fit_2.effective_metric_).encode(\"utf-8\")+b\"1c52e\").hexdigest() == \"fed6a9fc14d942c80421836e802e4f459699e299\", \"correct string value of knn_fit_2.effective_metric_ but incorrect case of letters\"\n\nassert sha1(str(type(type(knn_fit_2))).encode(\"utf-8\")+b\"1c52f\").hexdigest() == \"c0688283eb347b3a716716a2762a46dfa6000cbd\", \"type of type(knn_fit_2) is not correct\"\nassert sha1(str(type(knn_fit_2)).encode(\"utf-8\")+b\"1c52f\").hexdigest() == \"0704b8be28fd8da7859dd6fc8e5148535b75399d\", \"value of type(knn_fit_2) is not correct\"\n\nassert sha1(str(type(knn_fit_2.n_features_in_)).encode(\"utf-8\")+b\"1c530\").hexdigest() == \"3ac6a926c4de23bcae7e9a759aca7cd489f4cad2\", \"type of knn_fit_2.n_features_in_ is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(knn_fit_2.n_features_in_).encode(\"utf-8\")+b\"1c530\").hexdigest() == \"a032550f3adad26547a9e2adaae58acd93a5b36e\", \"value of knn_fit_2.n_features_in_ is not correct\"\n\nassert sha1(str(type(X_2.columns.values)).encode(\"utf-8\")+b\"1c531\").hexdigest() == \"a7b153af47464cec438aaac3a5398422f15c739c\", \"type of X_2.columns.values is not correct\"\nassert sha1(str(X_2.columns.values).encode(\"utf-8\")+b\"1c531\").hexdigest() == \"c3fd80e7a523addffb5f040e8560caf25c601447\", \"value of X_2.columns.values is not correct\"\n\nassert sha1(str(type(y_2.name)).encode(\"utf-8\")+b\"1c532\").hexdigest() == \"6ecd85411910b1c1e49f8fb6a6c446122031f3a3\", \"type of y_2.name is not str. y_2.name should be an str\"\nassert sha1(str(len(y_2.name)).encode(\"utf-8\")+b\"1c532\").hexdigest() == \"ebad5f09e153e6397258881e828d3d859c85154e\", \"length of y_2.name is not correct\"\nassert sha1(str(y_2.name.lower()).encode(\"utf-8\")+b\"1c532\").hexdigest() == \"7c29dd51d86bde999e3497b24a52324ffa88d80b\", \"value of y_2.name is not correct\"\nassert sha1(str(y_2.name).encode(\"utf-8\")+b\"1c532\").hexdigest() == \"ff10a06265a833d1274bee055d40fe11d6c1de8f\", \"correct string value of y_2.name but incorrect case of letters\"\n\nassert sha1(str(type(y_2.values)).encode(\"utf-8\")+b\"1c533\").hexdigest() == \"6701ed81a4e9d4e3d605bff672f33abc4cab49ab\", \"type of y_2.values is not correct\"\nassert sha1(str(y_2.values).encode(\"utf-8\")+b\"1c533\").hexdigest() == \"1eeb2c2596b3d6987df53c982b8921d368bfa856\", \"value of y_2.values is not correct\"\n\nassert sha1(str(type(sum(X_2.Symmetry))).encode(\"utf-8\")+b\"1c534\").hexdigest() == \"401b25657e3ccc6f373b04c3f73b718954f2f87f\", \"type of sum(X_2.Symmetry) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(X_2.Symmetry), 2)).encode(\"utf-8\")+b\"1c534\").hexdigest() == \"10b6bfc8d4273cf2cda252fff3ead0fcdb4a13cd\", \"value of sum(X_2.Symmetry) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(sum(X_2.Radius))).encode(\"utf-8\")+b\"1c535\").hexdigest() == \"bc045aaaa3e654827d701f1a154d82ce3bf159de\", \"type of sum(X_2.Radius) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(X_2.Radius), 2)).encode(\"utf-8\")+b\"1c535\").hexdigest() == \"ba710607201f7fb546dfbff2bbf8125c43eb507a\", \"value of sum(X_2.Radius) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(sum(X_2.Concavity))).encode(\"utf-8\")+b\"1c536\").hexdigest() == \"bdd5f789273332ff93a37a929e933342daf588ce\", \"type of sum(X_2.Concavity) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(X_2.Concavity), 2)).encode(\"utf-8\")+b\"1c536\").hexdigest() == \"c83ba58970a37bc501a808908479fa9f85081954\", \"value of sum(X_2.Concavity) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(new_obs_2 is None)).encode(\"utf-8\")+b\"1c537\").hexdigest() == \"0e6db0897dec3a5a0be1727ee2174838fed8392d\", \"type of new_obs_2 is None is not bool. new_obs_2 is None should be a bool\"\nassert sha1(str(new_obs_2 is None).encode(\"utf-8\")+b\"1c537\").hexdigest() == \"3bd0c39ffd477eef3d20295014e9603c292a36db\", \"boolean value of new_obs_2 is None is not correct\"\n\nassert sha1(str(type(new_obs_2)).encode(\"utf-8\")+b\"1c538\").hexdigest() == \"dbd7bddf2ba93297c398200c3aba22eee791cc2b\", \"type of type(new_obs_2) is not correct\"\n\nassert sha1(str(type(new_obs_2.Symmetry.values)).encode(\"utf-8\")+b\"1c539\").hexdigest() == \"f025231cf463eb1b53a6eb94ed504ae8eacbd2b3\", \"type of new_obs_2.Symmetry.values is not correct\"\nassert sha1(str(new_obs_2.Symmetry.values).encode(\"utf-8\")+b\"1c539\").hexdigest() == \"ee3ccc35dc76e76f3d3f26ce2af31aba1c00475d\", \"value of new_obs_2.Symmetry.values is not correct\"\n\nassert sha1(str(type(new_obs_2.Radius.values)).encode(\"utf-8\")+b\"1c53a\").hexdigest() == \"88a9bfa1595cca275e5f844a75c8fd0e7e660b85\", \"type of new_obs_2.Radius.values is not correct\"\nassert sha1(str(new_obs_2.Radius.values).encode(\"utf-8\")+b\"1c53a\").hexdigest() == \"71bc38e24dca943a89fdba0e143c0c93a97d9dbd\", \"value of new_obs_2.Radius.values is not correct\"\n\nassert sha1(str(type(new_obs_2.Concavity.values)).encode(\"utf-8\")+b\"1c53b\").hexdigest() == \"581e0fa5a3a53d9c88d6df38ab3e022f128d41bb\", \"type of new_obs_2.Concavity.values is not correct\"\nassert sha1(str(new_obs_2.Concavity.values).encode(\"utf-8\")+b\"1c53b\").hexdigest() == \"6366ed5e9216d5cf0dab850bfd420217af90487c\", \"value of new_obs_2.Concavity.values is not correct\"\n\nassert sha1(str(type(class_prediction_2 is None)).encode(\"utf-8\")+b\"1c53c\").hexdigest() == \"102656310fdb351c06ebfcd34be208a380387416\", \"type of class_prediction_2 is None is not bool. class_prediction_2 is None should be a bool\"\nassert sha1(str(class_prediction_2 is None).encode(\"utf-8\")+b\"1c53c\").hexdigest() == \"2a4bb29e14b26cb4fba6321e00f5ea7264414756\", \"boolean value of class_prediction_2 is None is not correct\"\n\nassert sha1(str(type(class_prediction_2)).encode(\"utf-8\")+b\"1c53d\").hexdigest() == \"0d077a418cd3754263e26adf0dd15e657d98c01a\", \"type of class_prediction_2 is not correct\"\nassert sha1(str(class_prediction_2).encode(\"utf-8\")+b\"1c53d\").hexdigest() == \"fa0463880a9a71ddc10bfae3b027f9f4a6da0038\", \"value of class_prediction_2 is not correct\"\n\nprint('Success!')\n\nQuestion 2.5 {points: 1}\nFinally, we will perform K-nearest neighbour classification again, using the scikit-learn package and K = 7 to classify a new observation where we use all the predictors in our data set (we give you the values in the code below).\nBut we first have to do one important thing: we need to remove the ID variable from the analysis (it‚Äôs not a numerical measurement that we should use for classification). Thankfully, scikit-learn provides a nice way of combining data preprocessing and training into a single consistent pipeline.\nWe will first create a preprocessor to remove the ID variable using the drop preprocessing step. Since we aren‚Äôt doing any preprocessing to other columns, we will set the remainder parameter to passthrough. Do so below using the provided scaffolding. Name the preprocessor object knn_preprocessor.\n\n# ___ = make_column_transformer(\n#     (\"drop\", [___]),\n#     remainder=___\n# )\n\n# your code here\nraise NotImplementedError\nknn_preprocessor\n\n\nfrom hashlib import sha1\nassert sha1(str(type(knn_preprocessor is None)).encode(\"utf-8\")+b\"c9190\").hexdigest() == \"1aa697ad8121d7a033d091dd1dde11fd9a9048c0\", \"type of knn_preprocessor is None is not bool. knn_preprocessor is None should be a bool\"\nassert sha1(str(knn_preprocessor is None).encode(\"utf-8\")+b\"c9190\").hexdigest() == \"fa97b74142ab349c61853efd4aed109620ea4419\", \"boolean value of knn_preprocessor is None is not correct\"\n\nassert sha1(str(type(type(knn_preprocessor))).encode(\"utf-8\")+b\"c9191\").hexdigest() == \"1109d30d9e1570f804f20d5d028ef6afce897841\", \"type of type(knn_preprocessor) is not correct\"\nassert sha1(str(type(knn_preprocessor)).encode(\"utf-8\")+b\"c9191\").hexdigest() == \"b7f41df01f0ad5de7c336fbe446f33229e39ffba\", \"value of type(knn_preprocessor) is not correct\"\n\nassert sha1(str(type(knn_preprocessor.get_feature_names_out)).encode(\"utf-8\")+b\"c9192\").hexdigest() == \"bb33b66fca24d58fe1cd06f2a2985674ee8f0698\", \"type of knn_preprocessor.get_feature_names_out is not correct\"\nassert sha1(str(knn_preprocessor.get_feature_names_out).encode(\"utf-8\")+b\"c9192\").hexdigest() == \"ee35e154ea1785364b8455f97248689b3f960199\", \"value of knn_preprocessor.get_feature_names_out is not correct\"\n\nprint('Success!')\n\nQuestion 2.6  {points: 1}\nCreate a pipeline that includes the new preprocessor (knn_preprocessor) and the model specification (knn_spec) using the scaffolding below. Name the pipeline object knn_pipeline.\n\n# ___ = make_pipeline(___, ___)\n\n# your code here\nraise NotImplementedError\nknn_pipeline\n\n\nfrom hashlib import sha1\nassert sha1(str(type(knn_pipeline is None)).encode(\"utf-8\")+b\"570b0\").hexdigest() == \"5229d62594055e066352668824c5c3908bb29f74\", \"type of knn_pipeline is None is not bool. knn_pipeline is None should be a bool\"\nassert sha1(str(knn_pipeline is None).encode(\"utf-8\")+b\"570b0\").hexdigest() == \"1d2994bb8a065a370b5d478a8087d37e3841c353\", \"boolean value of knn_pipeline is None is not correct\"\n\nassert sha1(str(type(type(knn_pipeline))).encode(\"utf-8\")+b\"570b1\").hexdigest() == \"4b6b2b6e8dcd91c384d5e7b3ffaa5df5ed5fac76\", \"type of type(knn_pipeline) is not correct\"\nassert sha1(str(type(knn_pipeline)).encode(\"utf-8\")+b\"570b1\").hexdigest() == \"7cff373362fd36faa9d06c119ebecf6820b812f0\", \"value of type(knn_pipeline) is not correct\"\n\nassert sha1(str(type(knn_pipeline.named_steps.kneighborsclassifier.n_neighbors)).encode(\"utf-8\")+b\"570b2\").hexdigest() == \"c0cf487b545aea403a76ddbbedba6f508f1e6b8f\", \"type of knn_pipeline.named_steps.kneighborsclassifier.n_neighbors is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(knn_pipeline.named_steps.kneighborsclassifier.n_neighbors).encode(\"utf-8\")+b\"570b2\").hexdigest() == \"0c675a0ab79e6e0c763779b13443212fca47db27\", \"value of knn_pipeline.named_steps.kneighborsclassifier.n_neighbors is not correct\"\n\nprint('Success!')\n\nQuestion 2.7 {points: 1}\nFinally, fit the pipeline and predict the class label for the new observation named new_obs_all. Name the fit object knn_fit_all, and the class prediction class_prediction_all. Name the new predictor as X_3 and the new target as y_3.\n\nnew_obs_all = pd.DataFrame(\n    [[None, 0, 0, 0, 0, 0.5, 0, 1, 0, 1, 0]],\n    columns=[\n        \"ID\",\n        \"Radius\",\n        \"Texture\",\n        \"Perimeter\",\n        \"Area\",\n        \"Smoothness\",\n        \"Compactness\",\n        \"Concavity\",\n        \"Concave_points\",\n        \"Symmetry\",\n        \"Fractal_dimension\",\n    ],\n)\n# X_3 = cancer.drop(columns=[___])\n# y_3 = cancer[___]\n# ___ = knn_pipeline.fit(___, ___)\n# ___ = knn_fit_all.____(____)\n\n# your code here\nraise NotImplementedError\nclass_prediction_all\n\n\nfrom hashlib import sha1\nassert sha1(str(type(class_prediction_all)).encode(\"utf-8\")+b\"bdab9\").hexdigest() == \"6a39e4695fdfb5df240814e4336bf420375f8ab0\", \"type of class_prediction_all is not correct\"\nassert sha1(str(class_prediction_all).encode(\"utf-8\")+b\"bdab9\").hexdigest() == \"f3a6c0bfa60af2a0f2398b36ffe3f27359ac2478\", \"value of class_prediction_all is not correct\"\n\nprint('Success!')"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html",
    "href": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html",
    "title": "Worksheet - Classification (Part II)",
    "section": "",
    "text": "After completing this workshop session, you will be able to:\n\nDescribe what a test data set is and how it is used in classification.\nUnderstand several ways of representing classifier performance: accuracy, precision, and recall, and the confusion matrix.\nUsing Python, evaluate classifier performance using a test data set and appropriate metrics.\nUsing Python, execute cross-validation in Python to choose the number of neighbours.\nIdentify when it is necessary to scale variables before classification and do this using Python\nIn a dataset with &gt; 2 attributes, perform k-nearest neighbour classification in Python using the scikit-learn package to predict the class of a test dataset.\nDescribe advantages and disadvantages of the k-nearest neighbour classification algorithm.\n\nThis worksheet covers parts of Chapter 6 of the online textbook. You can refer to and read this chapter to help you answer the worksheet. Any place you see ___, you must fill in the function, variable, or data to complete the code before running the cell.\n\n### Run this cell before continuing.\nimport altair as alt\nimport numpy as np\nimport pandas as pd\nfrom sklearn import set_config\nfrom sklearn.compose import make_column_transformer, ColumnTransformer\nfrom sklearn.metrics.pairwise import euclidean_distances\nfrom sklearn.model_selection import (\n    GridSearchCV,\n    RandomizedSearchCV,\n    cross_validate,\n    train_test_split,\n)\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import precision_score, recall_score\nfrom sklearn.metrics import ConfusionMatrixDisplay\n\n# Simplify working with large datasets in Altair\nalt.data_transformers.disable_max_rows()\n\n# Output dataframes instead of arrays\nset_config(transform_output=\"pandas\")"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#learning-goals",
    "href": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#learning-goals",
    "title": "Worksheet - Classification (Part II)",
    "section": "",
    "text": "After completing this workshop session, you will be able to:\n\nDescribe what a test data set is and how it is used in classification.\nUnderstand several ways of representing classifier performance: accuracy, precision, and recall, and the confusion matrix.\nUsing Python, evaluate classifier performance using a test data set and appropriate metrics.\nUsing Python, execute cross-validation in Python to choose the number of neighbours.\nIdentify when it is necessary to scale variables before classification and do this using Python\nIn a dataset with &gt; 2 attributes, perform k-nearest neighbour classification in Python using the scikit-learn package to predict the class of a test dataset.\nDescribe advantages and disadvantages of the k-nearest neighbour classification algorithm.\n\nThis worksheet covers parts of Chapter 6 of the online textbook. You can refer to and read this chapter to help you answer the worksheet. Any place you see ___, you must fill in the function, variable, or data to complete the code before running the cell.\n\n### Run this cell before continuing.\nimport altair as alt\nimport numpy as np\nimport pandas as pd\nfrom sklearn import set_config\nfrom sklearn.compose import make_column_transformer, ColumnTransformer\nfrom sklearn.metrics.pairwise import euclidean_distances\nfrom sklearn.model_selection import (\n    GridSearchCV,\n    RandomizedSearchCV,\n    cross_validate,\n    train_test_split,\n)\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import precision_score, recall_score\nfrom sklearn.metrics import ConfusionMatrixDisplay\n\n# Simplify working with large datasets in Altair\nalt.data_transformers.disable_max_rows()\n\n# Output dataframes instead of arrays\nset_config(transform_output=\"pandas\")"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#fruit-data-example",
    "href": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#fruit-data-example",
    "title": "Worksheet - Classification (Part II)",
    "section": "1. Fruit Data Example",
    "text": "1. Fruit Data Example\nIn the agricultural industry, cleaning, sorting, grading, and packaging food products are all necessary tasks in the post-harvest process. Products are classified based on appearance, size and shape, attributes which helps determine the quality of the food. Sorting can be done by humans, but it is tedious and time consuming. Automatic sorting could help save time and money. Images of the food products are captured and analysed to determine visual characteristics.\nThe dataset contains observations of fruit described with four features: (1) mass (in g), (2) width (in cm), (3) height (in cm), and (4) color score (on a scale from 0 - 1).\nTo get started building a classifier that can classfiy a fruit based on its appearance, use pd.read_csv to load the file fruit_data.csv (found in the data folder) from the previous tutorial into your notebook.\nAssign your data to an object called fruit_data.\n\n# Run this cell to read the data\nfruit_data = pd.read_csv(\"data/fruit_data.csv\")\n\nLet‚Äôs take a look at the first few observations in the fruit dataset. Run the cell below.\n\n# Run this cell to preview the data\nfruit_data.head()\n\nNow let‚Äôs investigate the class counts for each kind of fruit:\n\nfruit_data['fruit_name'].value_counts(normalize=False)\n\nWe can change to using normalize=True to get the class proportions:\n\nfruit_data['fruit_name'].value_counts(normalize=True)"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#randomness-and-setting-seeds",
    "href": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#randomness-and-setting-seeds",
    "title": "Worksheet - Classification (Part II)",
    "section": "Randomness and Setting Seeds",
    "text": "Randomness and Setting Seeds\nThis worksheet uses functions from the scikit-learn library, which not only allows us to perform K-nearest neighbour classification, but also allows us to evaluate how well our classification worked. In order to ensure that the steps in the worksheet are reproducible, we need to set a random_state or random seed, i.e., a numerical ‚Äústarting value,‚Äù which determines the sequence of random numbers Python will generate.\nBelow in many cells we have included an argument to set the random_state or np.random.seed. They are necessary to make sure the autotesting code functions properly. In your own analysis however, it is a better practice to set the random_state or random seed just once at the beginning of your script."
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#splitting-the-data-into-a-training-and-test-set",
    "href": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#splitting-the-data-into-a-training-and-test-set",
    "title": "Worksheet - Classification (Part II)",
    "section": "2. Splitting the data into a training and test set",
    "text": "2. Splitting the data into a training and test set\nIn this exercise, we will be partitioning fruit_data into a training (75%) and testing (25%) set using the scikit-learn package. After creating the test set, we will put the test set away in a lock box and not touch it again until we have found the best k-nn classifier we can make using the training set. We will use the variable fruit_name as our class label.\n\nQuestion 1\nTo create the training and test set, we would use the train_test_split function from scikit-learn package. Save the trained dataset and test dataset as fruit_train and fruit_test, respectively. To help you out, we have put a scaffold of the code in the cell below. Your job is to fill in the blanks with the correct values.\n\nNote: by default scikit-learn will not stratify the split by the label, so if we forget to set stratify to fruit_data['fruit_name'] it could be possible that we may not end up with an observation in the test set with the label ‚Äúmandarin‚Äù (because there are only 5 mandarin observations in the entire data set), and as a consequence, we would not be able to evaluate predictions on it‚Ä¶\n\n\n# Split data into a training and test set\n\n# fruit_train, fruit_test = train_test_split(____, \n#                                            test_size=____,\n#                                            stratify=____,\n#                                            random_state=____) # set the random state to be 2020\n\nfruit_train.head()\n\n\nfruit_test.head()\n\n\n# Run these tests to check your answer\n\n# Check training data \nassert isinstance(fruit_train, pd.DataFrame), \"`fruit_train` is not a pandas DataFrame\"\nassert fruit_train.shape == (44, 7), f\"Expected shape (44, 7), but got {fruit_train.shape}\"\nassert (fruit_train['fruit_name'] == 'mandarin').any(), \"`mandarin` not found in `fruit_name`\"\nnp.testing.assert_array_equal(np.array([14, 14, 12,  4]), fruit_train['fruit_name'].value_counts().values,\n                             err_msg='Some unexpected observations are in your training set.')\nassert fruit_train['fruit_name'].value_counts().index.tolist() == ['orange', 'apple', 'lemon', 'mandarin'], 'Some unexpected observations are in your training set.'\n\n# Check test data\nassert isinstance(fruit_test, pd.DataFrame), \"`fruit_test` is not a pandas DataFrame\"\nassert fruit_test.shape == (15, 7), f\"Expected shape (15, 7), but got {fruit_train.shape}\"\nassert (fruit_test['fruit_name'] == 'mandarin').any(), \"`mandarin` not found in `fruit_name`\"\nnp.testing.assert_array_equal(np.array([5, 5, 4, 1]), fruit_test['fruit_name'].value_counts().values,\n                             err_msg='Some unexpected observations are in your test set.')\nassert fruit_test['fruit_name'].value_counts().index.tolist() == ['apple', 'orange', 'lemon', 'mandarin'], 'Some unexpected observations are in your test set.'\n\nprint('Success!')\n\n\n\nQuestion 2\nK-nearest neighbors is sensitive to the scale of the predictors so we should do some preprocessing to standardize them. Remember that standardization is part of your training procedure, so you can‚Äôt use your test data to compute the centered / scaled values for each variable. Once we have created the standardization preprocessor, we can then later on apply it separately to both the training and test data sets.\nFor this worksheet, let‚Äôs see if mass, width, height and color_score can predict fruit_name.\nTo scale and center the data, first, pass the predictors to the make_column_transformer function to make the preprocessor. To help you out, we have put a scaffold of the code in the cell below. Your job is to fill in the blanks with the correct values.\nAssign your answer to an object called fruit_preprocessor.\n\n# Create a preprocessor using the training data\n\n# fruit_preprocessor = make_column_transformer(\n#     (____, ____,\n#     verbose_feature_names_out=____\n# )\n\nfruit_preprocessor\n\n\n# Run these tests to check your answer\n\nassert isinstance(fruit_preprocessor, ColumnTransformer), \"fruit_preprocessor is not a ColumnTransformer\"\nexpected_columns = {'mass', 'width', 'height', 'color_score'}\nactual_columns = set(fruit_preprocessor.transformers[0][2])\nassert actual_columns == expected_columns, f\"Expected columns {expected_columns}, but got {actual_columns}\"\nassert isinstance(fruit_preprocessor.transformers[0][1], StandardScaler), \"Transformer is not an instance of StandardScaler\"\n\nprint('Success!')\n\nNow that we have split the data, we can do things like exploratory data analysis and model fitting!!!\nA common way to explore the data when peforming classification is to create pairwise plots of the predictor variables, and color the points by the class label. Remember, that our model is sensitive to scale, and so we should also scale the data when visualizing it for modeling insights.\n\n# Run this cell to scale the data and create a pairwise scatter plot\n\n# Create a scaled version of the data\nfruit_preprocessor.fit(fruit_train)\nscaled_fruit_train = fruit_preprocessor.transform(fruit_train)\n\n# Create the scatterplot\nfruit_pairwise = alt.Chart(fruit_train).mark_point(filled=True, stroke='black', strokeWidth=0.5, size=75, opacity=0.9).encode(\n    x=alt.X(alt.repeat(\"column\"), type='quantitative'),\n    y=alt.Y(alt.repeat(\"row\"), type='quantitative'),\n    color=alt.Color(\"fruit_name:N\", scale=alt.Scale(range=['green', 'yellow', '#f26a02', '#ffd1a6'])),\n    shape=alt.Shape(\"fruit_name:N\", scale=alt.Scale(range=['circle', 'diamond', 'circle', 'square'])),\n).properties(\n    width=175,\n    height=175\n).repeat(\n    row=['mass', 'width', 'height', 'color_score'],\n    column=['color_score', 'height','width', 'mass']\n).interactive()\n\nfruit_pairwise"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#cross-validation-and-parameter-value-selection",
    "href": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#cross-validation-and-parameter-value-selection",
    "title": "Worksheet - Classification (Part II)",
    "section": "3. Cross-validation and parameter value selection",
    "text": "3. Cross-validation and parameter value selection\n\nQuestion 3\nWe want to pick the number of neighbours to maximize the performance of our classifier on data it hasn‚Äôt seen yet. One way to do this is to cross-validation. To do this in Python we should do the following:\n\nSetup a pipeline object that specifies the data and preprocessor, as well as the type of model we want to use,\nCreate a dictionary with the range of values we want to search through for the parameter(s)\nPass the pipline object, and parameter grid dictionary object to a GridSearchCV.\nRun fit on the GridSearchCV object to carryout the tuning process.\nUse pd.DataFrame to convert the output to a dataframe for convenience.\n\nPerform the above using to run 5-fold cross validation to choose \\(K\\) for K-nearest neighbors classification. Use the fruit_preprocessor object you created in question 2, and search across the values from 1 to 15 (incrementing by 1).\nAssign your final data frame to an object called fruit_vfold_score so you can check your work.\n\nnp.random.seed(2020)  # DO NOT REMOVE\n\n# # 1. Setup pipeline object\n# fruit_tune_pipeline = make_pipeline(____, \n#                                     ____)\n# \n# # 2. Define parameter grid\n# parameter_grid = {\n#     ____: range(____, ____, ____),\n# }\n# \n# # 3. Create `GridSearchCV` object\n# fruit_tune_grid = GridSearchCV(\n#     estimator=____,\n#     param_grid=____,\n#     cv=____\n# )\n# \n# # 4. Fit `GridSearchCV` object\n# fruit_tune_grid.fit(\n#     ____,\n#     ____\n# )\n# \n# # 5. Convert results to data frame\n# fruit_vfold_score = pd.DataFrame(____)\n# \nfruit_vfold_score.head()\n\n\nfruit_vfold_score['rank_test_score'].value_counts()\n\n\n# Run these tests to check your answer\n\nassert isinstance(fruit_vfold_score, pd.DataFrame), \"`fruit_test` is not a pandas DataFrame\"\nassert fruit_vfold_score.shape == (14, 13), f\"Expected shape (14, 13), but got {fruit_vfold_score.shape}\"\nexpected_columns = {'mean_fit_time', 'std_fit_time', 'mean_score_time', 'std_score_time',\n       'param_kneighborsclassifier__n_neighbors', 'params',\n       'split0_test_score', 'split1_test_score', 'split2_test_score',\n       'split3_test_score', 'mean_test_score', 'std_test_score',\n       'rank_test_score'}\nactual_columns = set(fruit_vfold_score.columns)\nassert actual_columns == expected_columns, f\"Expected columns {expected_columns}, but got {actual_columns}\"\n\nnp.testing.assert_array_equal(np.array([3, 2, 2, 1, 1, 1, 1, 1, 1, 1]), fruit_vfold_score['rank_test_score'].value_counts().values,\n                             err_msg='Something unexpected happened with the tuning of your classifier. Check your model and cross-validation specs.')\nassert fruit_vfold_score['rank_test_score'].value_counts().index.tolist() == [4, 1, 9, 3, 7, 8, 12, 11, 14, 13], 'Something unexpected happened with the tuning of your classifier. Check your model and cross-validation specs.'\n\nprint('Success!')\n\nTo make the results a bit easier to interpret, let‚Äôs select just the columns we are interested in:\n\nparam_kneighborsclassifier__n_neighbors\nmean_test_score\n\n\n# Run this cell to see a table of just the parameter values and\n# the mean cross-validation accuracy\n\nfruit_vfold_score[['param_kneighborsclassifier__n_neighbors',\n                  'mean_test_score']]\n\n\n\nVisualizing a parameter‚Äôs effect on model performance\nVisually inspecting the grid search results can help us find, and choose the best value for the number of neighbors parameter.\nBelow, we use altair (a Python visualization library) to create a line plot using the accuracies_grid dataframe with param_kneighborsclassifier__n_neighbors on the x-axis and the mean_test_score on the y-axis. Use point=True to include a point for each value of \\(K\\).\n\n# Run this cell to visualize the parameters vs mean cross-validation accuracy \n# as a line chart\n\naccuracy_versus_k_grid = alt.Chart(fruit_vfold_score).mark_line(point=True).encode(\n    x=alt.X(\"param_kneighborsclassifier__n_neighbors\")\n        .title(\"Neighbors\")\n        .scale(zero=False),\n    y=alt.Y(\"mean_test_score\")\n        .title(\"Mean Test Score\")\n        .scale(zero=False)\n)\n\naccuracy_versus_k_grid"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#understanding-prediction-errors",
    "href": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#understanding-prediction-errors",
    "title": "Worksheet - Classification (Part II)",
    "section": "6. Understanding prediction errors",
    "text": "6. Understanding prediction errors\nNow, let‚Äôs look at the confusion matrix for the classifier. This will show us a table comparing the predicted labels with the true labels.\nAlthough we can create a confusion matrix by using the crosstab function from pandas, with many observations, it can be difficult to interpret the confusion matrix when it is presented as a table like above. In these cases, we could instead use the ConfusionMatrixDisplay function of the scikit-learn package to visualize the confusion matrix as a heatmap. Please run the cell below to see the fruit confusion matrix as a heatmap.\n\nConfusionMatrixDisplay.from_estimator(\n    estimator=fruit_tune_grid,  # We are directly passing the pipeline and let sklearn do the predictions for us\n    X=fruit_train.drop(columns=['fruit_name']),\n    y=fruit_train['fruit_name']\n)\n\nWhat mistakes is it making? Revisit the pairwise scatter plot you created after question 2, can you guess why its making these mistakes? Do you have any ideas of what you could do to improve the model (hint, think about the data)?"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#model-generalizability",
    "href": "materials/worksheets/py_worksheet_classification2/py_worksheet_classification2.html#model-generalizability",
    "title": "Worksheet - Classification (Part II)",
    "section": "Model generalizability",
    "text": "Model generalizability\nOnce you have finished selecting your single, final model (and only then!) you may wish to estimate how well your model will generalize to unseen data. You have kept your test set for just that purpose, and that purpose alone.\n\nQuestion 4\nThe first step in assessing model generalizability is to use your model to predict labels for the test set observations. To do this with Python, use predict on the fruit_tune_grid object (that contains your trained model) to add a column named predicted to the fruit_test data frame. By default, scikit-learn will use the ‚Äúbest estimator‚Äù, here \\(K\\) with the highest accuracy, to do this. To help you out, we have put a scaffold of the code in the cell below. Your job is to fill in the blanks with the correct values.\nAssign your answer to an object called fruit_test_w_predictions.\n\n# Make a deep copy of `fruit_test` and name it `fruit_test_w_predictions`\nfruit_test_w_predictions = fruit_test.copy()\n\n# Use trained classifier to predict labels for test data\n\n# fruit_test_w_predictions['predicted'] = fruit_tune_grid.predict(\n#     ____)\n# )\n\nfruit_test_w_predictions.head()\n\n\n# Run these tests to check your answer\n\nassert isinstance(fruit_test_w_predictions, pd.DataFrame), '`fruit_test_w_predictions` is not a pandas DataFrame'\nassert fruit_test_w_predictions.shape == (15, 8), f\"Expected shape (15, 8), but got {fruit_test_w_predictions.shape}\"\nexpected_columns = {'fruit_label', 'fruit_name', 'fruit_subtype', 'mass', 'width', 'height', 'color_score', 'predicted'}\nactual_columns = set(fruit_test_w_predictions.columns)\nassert actual_columns == expected_columns, f\"Expected columns {expected_columns}, but got {actual_columns}\"\nnp.testing.assert_array_equal(np.array([5, 5, 4, 1]), fruit_test_w_predictions['predicted'].value_counts().values,\n                             err_msg='Some unexpected predictions were made from your classifier.')\nassert fruit_test_w_predictions['predicted'].value_counts().index.tolist() == ['apple', 'orange', 'lemon', 'mandarin'], 'Some unexpected predictions were made from your classifier.'\n\nprint('Success!')\n\n\n\nQuestion 5\nNext, we can calculate our prediction metrics on the test set, as well a compute and visualize a confusion matrix. We typically expect some drop in performance from what we observed in our training set (because we used that set to train the model), but ideally the model performs similarly.\nUse Python to calculate accuracy, weighted precision and weighted recall for the test set. To help you out, we have put a scaffold of the code in the cell below. Your job is to fill in the blanks with the correct values. Name your objects for accuracy, weighted precision and weighted recall accuracy, weighted_precision and weighted_recall, respectively.\n\nNote: given we have many categories, we want to know the weighted average precision and recall instead of calculating it for just one class.\n\n\n# Calculate accuracy for the test set\n\n# accuracy = fruit_tune_grid.score(\n#     X=____,\n#     y=____\n# )\n\naccuracy\ntype(accuracy)\n\n\n# Calculate weighted precision for the test set\n\n# weighted_precision = precision_score(\n#     y_true=____,\n#     y_pred=____,\n#     average='weighted'\n# )\n\nweighted_precision\n\n\n# Calculate weighted recall for the test set\n\n# weighted_recall = recall_score(\n#     y_true=____,\n#     y_pred=____,\n#     average='weighted'\n# )\n\nweighted_recall\n\n\n# Run these tests to check your answer\n\n# Check accuracy\nassert type(accuracy) == np.float64, '`accuracy` should be a single value, of type `numpy.float64`.'\nassert accuracy == 1, '`accuracy` value is incorrect'\n\n# Check weighted precision\nassert type(weighted_precision) == np.float64, '`weighted_precision` should be a single value, of type `numpy.float64`.'\nassert weighted_precision == 1, '`weighted_precision` value is incorrect'\n\n# Check weighted recall\nassert type(weighted_recall) == np.float64, '`weighted_recall` should be a single value, of type `numpy.float64`.'\nassert weighted_recall == 1, '`weighted_recall` value is incorrect'\n\nprint('Success!')\n\n\n# Visualize prediction performance as a confusion matrix\n\n# ConfusionMatrixDisplay.from_estimator(\n#     estimator=____\n#     X=____,\n#     y=____\n# )\n\nHmmm‚Ä¶ no mistakes on the test set‚Ä¶ Why might that be?"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html",
    "title": "Tree-based and ensemble models",
    "section": "",
    "text": "Code from the slides in an executable notebook."
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#example-the-heart-data-set",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#example-the-heart-data-set",
    "title": "Tree-based and ensemble models",
    "section": "Example: the heart data set",
    "text": "Example: the heart data set\n\nimport pandas as pd\nheart = pd.read_csv(\"data/Heart.csv\", index_col=0)\nheart.info()\n\n\nheart.head()"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#do-we-have-a-class-imbalance",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#do-we-have-a-class-imbalance",
    "title": "Tree-based and ensemble models",
    "section": "Do we have a class imbalance?",
    "text": "Do we have a class imbalance?\n\nheart['AHD'].value_counts(normalize=True)"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#data-splitting",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#data-splitting",
    "title": "Tree-based and ensemble models",
    "section": "Data splitting",
    "text": "Data splitting\n\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\n\nnp.random.seed(2024)\n\nheart_train, heart_test = train_test_split(\n    heart, train_size=0.8, stratify=heart[\"AHD\"]\n)\n\nX_train = heart_train.drop(columns=['AHD'])\ny_train = heart_train['AHD']\nX_test = heart_test.drop(columns=['AHD'])\ny_test = heart_test['AHD']"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#one-hot-encoding-pre-processing",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#one-hot-encoding-pre-processing",
    "title": "Tree-based and ensemble models",
    "section": "One hot encoding & pre-processing",
    "text": "One hot encoding & pre-processing\n\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder\nfrom sklearn.compose import make_column_transformer, make_column_selector\n\nnumeric_feats = ['Age', 'RestBP', 'Chol', 'RestECG', 'MaxHR', 'Oldpeak','Slope', 'Ca']\npassthrough_feats = ['Sex', 'Fbs', 'ExAng']\ncategorical_feats = ['ChestPain', 'Thal']\n\nheart_preprocessor = make_column_transformer(\n    (StandardScaler(), numeric_feats), \n    (\"passthrough\", passthrough_feats),     \n    (OneHotEncoder(handle_unknown = \"ignore\"), categorical_feats),     \n)"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#fitting-a-dummy-classifier",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#fitting-a-dummy-classifier",
    "title": "Tree-based and ensemble models",
    "section": "Fitting a dummy classifier",
    "text": "Fitting a dummy classifier\n\nfrom sklearn.dummy import DummyClassifier\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.model_selection import cross_validate\n\ndummy = DummyClassifier()\ndummy_pipeline = make_pipeline(heart_preprocessor, dummy)\ncv_10_dummy = pd.DataFrame(\n    cross_validate(\n        estimator=dummy_pipeline,\n        cv=10,\n        X=X_train,\n        y=y_train\n    )\n)\ncv_10_dummy_metrics = cv_10_dummy.agg([\"mean\", \"sem\"])\nresults = pd.DataFrame({'mean' : [cv_10_dummy_metrics.test_score.iloc[0]],\n  'sem' : [cv_10_dummy_metrics.test_score.iloc[1]]},\n  index = ['Dummy classifier']\n)\nresults"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#fitting-a-decision-tree",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#fitting-a-decision-tree",
    "title": "Tree-based and ensemble models",
    "section": "Fitting a decision tree",
    "text": "Fitting a decision tree\n\nfrom sklearn.tree import DecisionTreeClassifier\n\ndecision_tree = DecisionTreeClassifier(random_state=2026)\n\ndt_pipeline = make_pipeline(heart_preprocessor, decision_tree)\ncv_10_dt = pd.DataFrame(\n    cross_validate(\n        estimator=dt_pipeline,\n        cv=10,\n        X=X_train,\n        y=y_train\n    )\n)\ncv_10_dt_metrics = cv_10_dt.agg([\"mean\", \"sem\"])\nresults_dt = pd.DataFrame({'mean' : [cv_10_dt_metrics.test_score.iloc[0]],\n  'sem' : [cv_10_dt_metrics.test_score.iloc[1]]},\n  index = ['Decision tree']\n)\nresults = pd.concat([results, results_dt])\nresults"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#random-forest-in-scikit-learn-missing-values",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#random-forest-in-scikit-learn-missing-values",
    "title": "Tree-based and ensemble models",
    "section": "Random forest in scikit-learn & missing values",
    "text": "Random forest in scikit-learn & missing values\nHow many rows have missing observations:\n\nheart.isna().any(axis=1).sum()\n\nDrop rows with missing observations:\n\nheart_train_drop_na = heart_train.dropna()\n\nX_train_drop_na = heart_train_drop_na.drop(\n    columns=['AHD']\n)\ny_train_drop_na = heart_train_drop_na['AHD']"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#random-forest-in-scikit-learn",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#random-forest-in-scikit-learn",
    "title": "Tree-based and ensemble models",
    "section": "Random forest in scikit-learn",
    "text": "Random forest in scikit-learn\n\nfrom sklearn.ensemble import RandomForestClassifier\n\nrandom_forest = RandomForestClassifier(random_state=2026)\nrf_pipeline = make_pipeline(heart_preprocessor, random_forest)\ncv_10_rf = pd.DataFrame(\n    cross_validate(\n        estimator=rf_pipeline,\n        cv=10,\n        X=X_train_drop_na,\n        y=y_train_drop_na\n    )\n)\n\ncv_10_rf_metrics = cv_10_rf.agg([\"mean\", \"sem\"])\nresults_rf = pd.DataFrame({'mean' : [cv_10_rf_metrics.test_score.iloc[0]],\n  'sem' : [cv_10_rf_metrics.test_score.iloc[1]]},\n  index = ['Random forest']\n)\nresults = pd.concat([results, results_rf])\nresults"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#tuning-random-forest-in-scikit-learn",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#tuning-random-forest-in-scikit-learn",
    "title": "Tree-based and ensemble models",
    "section": "Tuning random forest in scikit-learn",
    "text": "Tuning random forest in scikit-learn\n\nfrom sklearn.model_selection import GridSearchCV\n\nrf_param_grid = {'randomforestclassifier__n_estimators': [200],\n              'randomforestclassifier__max_depth': [1, 3, 5, 7, 9],\n              'randomforestclassifier__max_features': [1, 2, 3, 4, 5, 6, 7]}\n\nrf_tune_grid = GridSearchCV(\n    estimator=rf_pipeline,\n    param_grid=rf_param_grid,\n    cv=10,\n    n_jobs=-1 # tells computer to use all available CPUs\n)\nrf_tune_grid.fit(\n    X_train_drop_na,\n    y_train_drop_na\n)\n\ncv_10_rf_tuned_metrics = pd.DataFrame(rf_tune_grid.cv_results_)\nresults_rf_tuned = pd.DataFrame({'mean' : rf_tune_grid.best_score_,\n  'sem' : pd.DataFrame(rf_tune_grid.cv_results_)['std_test_score'][6] / 10**(1/2)},\n  index = ['Random forest tuned']\n)\nresults = pd.concat([results, results_rf_tuned])\n\n\nresults"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#tuning-gradientboostingclassifier-with-scikit-learn",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#tuning-gradientboostingclassifier-with-scikit-learn",
    "title": "Tree-based and ensemble models",
    "section": "Tuning GradientBoostingClassifier with scikit-learn",
    "text": "Tuning GradientBoostingClassifier with scikit-learn\n\nfrom sklearn.ensemble import GradientBoostingClassifier\n\ngradient_boosted_classifier = GradientBoostingClassifier(random_state=2026)\ngb_pipeline = make_pipeline(heart_preprocessor, gradient_boosted_classifier)\ngb_param_grid = {'gradientboostingclassifier__n_estimators': [200],\n              'gradientboostingclassifier__max_depth': [1, 3, 5, 7, 9],\n              'gradientboostingclassifier__learning_rate': [0.001, 0.005, 0.01]}\ngb_tune_grid = GridSearchCV(\n    estimator=gb_pipeline,\n    param_grid=gb_param_grid,\n    cv=10,\n    n_jobs=-1 # tells computer to use all available CPUs\n)\ngb_tune_grid.fit(\n    X_train_drop_na,\n    y_train_drop_na\n)\n\ncv_10_gb_tuned_metrics = pd.DataFrame(gb_tune_grid.cv_results_)\nresults_gb_tuned = pd.DataFrame({'mean' : gb_tune_grid.best_score_,\n  'sem' : pd.DataFrame(gb_tune_grid.cv_results_)['std_test_score'][6] / 10**(1/2)},\n  index = ['Gradient boosted classifier tuned']\n)\nresults = pd.concat([results, results_gb_tuned])\n\n\nresults"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#precision-and-recall-on-the-tuned-random-forest-model",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#precision-and-recall-on-the-tuned-random-forest-model",
    "title": "Tree-based and ensemble models",
    "section": "Precision and recall on the tuned random forest model",
    "text": "Precision and recall on the tuned random forest model\n\nfrom sklearn.metrics import make_scorer, precision_score, recall_score\n\nscoring = {\n    'accuracy': 'accuracy',\n    'precision': make_scorer(precision_score, pos_label='Yes'),\n    'recall': make_scorer(recall_score, pos_label='Yes')\n}\n\nrf_tune_grid = GridSearchCV(\n    estimator=rf_pipeline,\n    param_grid=rf_param_grid,\n    cv=10,\n    n_jobs=-1,\n    scoring=scoring,\n    refit='accuracy'\n)\n\nrf_tune_grid.fit(X_train_drop_na, y_train_drop_na)\n\n\ncv_results = pd.DataFrame(rf_tune_grid.cv_results_)\n\nmean_precision = cv_results['mean_test_precision'].iloc[rf_tune_grid.best_index_]\nsem_precision = cv_results['std_test_precision'].iloc[rf_tune_grid.best_index_] / np.sqrt(10)\nmean_recall = cv_results['mean_test_recall'].iloc[rf_tune_grid.best_index_]\nsem_recall = cv_results['std_test_recall'].iloc[rf_tune_grid.best_index_] / np.sqrt(10)\n\nresults_rf_tuned = pd.DataFrame({\n    'mean': [rf_tune_grid.best_score_, mean_precision, mean_recall],\n    'sem': [cv_results['std_test_accuracy'].iloc[rf_tune_grid.best_index_] / np.sqrt(10), sem_precision, sem_recall],\n}, index=['accuracy', 'precision', 'recall'])\n\nresults_rf_tuned"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#feature-importances-in-scikit-learn",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#feature-importances-in-scikit-learn",
    "title": "Tree-based and ensemble models",
    "section": "Feature importances in scikit-learn",
    "text": "Feature importances in scikit-learn\n\n# Access the best pipeline\nbest_pipeline = rf_tune_grid.best_estimator_\n\n# Extract the trained RandomForestClassifier from the pipeline\nbest_rf = best_pipeline.named_steps['randomforestclassifier']\n\n# Extract feature names after preprocessing\n# Get the names of features from each transformer in the pipeline\nnumeric_features = numeric_feats\ncategorical_feature_names = best_pipeline.named_steps['columntransformer'].transformers_[2][1].get_feature_names_out(categorical_feats)\npassthrough_features = passthrough_feats\n\n# Combine all feature names into a single list\nfeature_names = np.concatenate([numeric_features, passthrough_features, categorical_feature_names])\n\n# Calculate feature importances\nfeature_importances = best_rf.feature_importances_\n\n# Create a DataFrame to display feature importances\nimportances_df = pd.DataFrame({\n    'Feature': feature_names,\n    'Importance': feature_importances\n})\n\n# Sort by importance (descending order)\nimportances_df = importances_df.sort_values(by='Importance', ascending=False)"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#visualizing-the-results",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#visualizing-the-results",
    "title": "Tree-based and ensemble models",
    "section": "Visualizing the results",
    "text": "Visualizing the results\n\nimport altair as alt\n\nbar_chart = alt.Chart(importances_df).mark_bar().encode(\n    x=alt.X('Importance:Q', title='Feature Importance'),\n    y=alt.Y('Feature:N', sort='-x', title='Feature'),\n    tooltip=['Feature', 'Importance']\n).properties(\n    title='Feature Importances from Random Forest Model',\n    width=600,\n    height=400\n)\nbar_chart"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#evaluating-on-the-test-set",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#evaluating-on-the-test-set",
    "title": "Tree-based and ensemble models",
    "section": "Evaluating on the test set",
    "text": "Evaluating on the test set\n\nheart_test_drop_na = heart_test.dropna()\nX_test_drop_na = heart_test_drop_na.drop(columns=['AHD'])\ny_test_drop_na = heart_test_drop_na['AHD']\n\nheart_test_drop_na[\"predicted\"] = rf_tune_grid.predict(\n    X_test_drop_na\n)\n\nAccuracy\n\nrf_tune_grid.score(\n    X_test_drop_na,\n    y_test_drop_na\n)\n\nPrecision\n\nprecision_score(\n    y_true=heart_test_drop_na[\"AHD\"],\n    y_pred=heart_test_drop_na[\"predicted\"],\n    pos_label='Yes'\n)\n\nRecall\n\nrecall_score(\n    y_true=heart_test_drop_na[\"AHD\"],\n    y_pred=heart_test_drop_na[\"predicted\"],\n    pos_label='Yes'\n)\n\nConfusion matrix\n\nconf_matrix = pd.crosstab(\n    heart_test_drop_na[\"AHD\"],\n    heart_test_drop_na[\"predicted\"]\n)\nprint(conf_matrix)"
  },
  {
    "objectID": "materials/worksheets/py_ensembles/ensembles-code.html#referencesgareth-james-daniela-witten-trevor-hastie-robert-tibshirani-and-jonathan-taylor.-an-introduction-to-statistical-learning-with-applications-in-python.-springer-1st-edition-2023.-url-httpswww.statlearning.com.kolhatkar-v.-and-ostblom-j.-2024.-ubc-dsci-573-feature-and-model-selection-course-notes.-url-httpsubc-mds.github.iodsci_573_feat-model-selectpedregosa-f.-et-al.-2011.-scikit-learn-machine-learning-in-python.-journal-of-machine-learning-research-12oct-pp.28252830.",
    "href": "materials/worksheets/py_ensembles/ensembles-code.html#referencesgareth-james-daniela-witten-trevor-hastie-robert-tibshirani-and-jonathan-taylor.-an-introduction-to-statistical-learning-with-applications-in-python.-springer-1st-edition-2023.-url-httpswww.statlearning.com.kolhatkar-v.-and-ostblom-j.-2024.-ubc-dsci-573-feature-and-model-selection-course-notes.-url-httpsubc-mds.github.iodsci_573_feat-model-selectpedregosa-f.-et-al.-2011.-scikit-learn-machine-learning-in-python.-journal-of-machine-learning-research-12oct-pp.28252830.",
    "title": "Tree-based and ensemble models",
    "section": "ReferencesGareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani and Jonathan Taylor. An Introduction to Statistical Learning with Applications in Python. Springer, 1st edition, 2023. URL: https://www.statlearning.com/.Kolhatkar, V., and Ostblom, J. (2024). UBC DSCI 573: Feature and Model Selection course notes. URL: https://ubc-mds.github.io/DSCI_573_feat-model-selectPedregosa, F. et al., 2011. Scikit-learn: Machine learning in Python. Journal of machine learning research, 12(Oct), pp.2825‚Äì2830.",
    "text": "ReferencesGareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani and Jonathan Taylor. An Introduction to Statistical Learning with Applications in Python. Springer, 1st edition, 2023. URL: https://www.statlearning.com/.Kolhatkar, V., and Ostblom, J. (2024). UBC DSCI 573: Feature and Model Selection course notes. URL: https://ubc-mds.github.io/DSCI_573_feat-model-selectPedregosa, F. et al., 2011. Scikit-learn: Machine learning in Python. Journal of machine learning research, 12(Oct), pp.2825‚Äì2830."
  },
  {
    "objectID": "materials/worksheets/py_worksheet_regression2/py_worksheet_regression2.html",
    "href": "materials/worksheets/py_worksheet_regression2/py_worksheet_regression2.html",
    "title": "Worksheet - Linear Regression",
    "section": "",
    "text": "Recognize situations where a simple regression analysis would be appropriate for making predictions.\nPerform ordinary least squares regression in Python using scikit-learn to predict the values for a test dataset.\nUse Python to fit simple and multivariable linear regression models on training data.\nEvaluate the linear regression model on test data.\n\nThis worksheet covers parts of Chapter 8 of the online textbook. You should read this chapter to gain a better understanding of this assignment. Any place you see ___, you must fill in the function, variable, or data to complete the code. Substitute the raise NotImplementedError with your completed code and answers then proceed to run the cell.\n\n### Run this cell before continuing.\nimport altair as alt\nimport numpy as np\nimport pandas as pd\nfrom sklearn import set_config\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error\n\n# Simplify working with large datasets in Altair\nalt.data_transformers.disable_max_rows()\n\n# Output dataframes instead of arrays\nset_config(transform_output=\"pandas\")"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_regression2/py_worksheet_regression2.html#learning-objectives",
    "href": "materials/worksheets/py_worksheet_regression2/py_worksheet_regression2.html#learning-objectives",
    "title": "Worksheet - Linear Regression",
    "section": "",
    "text": "Recognize situations where a simple regression analysis would be appropriate for making predictions.\nPerform ordinary least squares regression in Python using scikit-learn to predict the values for a test dataset.\nUse Python to fit simple and multivariable linear regression models on training data.\nEvaluate the linear regression model on test data.\n\nThis worksheet covers parts of Chapter 8 of the online textbook. You should read this chapter to gain a better understanding of this assignment. Any place you see ___, you must fill in the function, variable, or data to complete the code. Substitute the raise NotImplementedError with your completed code and answers then proceed to run the cell.\n\n### Run this cell before continuing.\nimport altair as alt\nimport numpy as np\nimport pandas as pd\nfrom sklearn import set_config\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error\n\n# Simplify working with large datasets in Altair\nalt.data_transformers.disable_max_rows()\n\n# Output dataframes instead of arrays\nset_config(transform_output=\"pandas\")"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_regression2/py_worksheet_regression2.html#marathon-training-with-linear-regression",
    "href": "materials/worksheets/py_worksheet_regression2/py_worksheet_regression2.html#marathon-training-with-linear-regression",
    "title": "Worksheet - Linear Regression",
    "section": "Marathon Training with Linear Regression!",
    "text": "Marathon Training with Linear Regression!\n\nSource: https://media.giphy.com/media/BDagLpxFIm3SM/giphy.gif\nQuestion: what features predict whether athletes will perform better than others? Specifically, we are interested in marathon runners, and looking at how the maximum distance ran per week during training predicts the time it takes a runner to end the race?\nThis time around, however, we will analyze the data using simple linear regression rather than \\(k\\)-nn regression. In the end, we will compare our results to what we found with \\(k\\)-nn regression.\nQuestion 1.0  {points: 1}\nLoad the marathon data from the data/ folder and assign it to an object called marathon.\n\n# your code here\nraise NotImplementedError\nmarathon\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon is None)).encode(\"utf-8\")+b\"739e2\").hexdigest() == \"6e92f9a4e4c3ee38226eb47ccf55024c5f32aa31\", \"type of marathon is None is not bool. marathon is None should be a bool\"\nassert sha1(str(marathon is None).encode(\"utf-8\")+b\"739e2\").hexdigest() == \"59296bffcfb7bcd365f6c79ebfd8e5a40df62b2f\", \"boolean value of marathon is None is not correct\"\n\nassert sha1(str(type(marathon)).encode(\"utf-8\")+b\"739e3\").hexdigest() == \"bff0380c6a360860e46c818fdc334b2bcfeb5adb\", \"type of type(marathon) is not correct\"\n\nassert sha1(str(type(marathon.shape)).encode(\"utf-8\")+b\"739e4\").hexdigest() == \"1eada99c236028fcff78fd6303354632c2cb5e62\", \"type of marathon.shape is not tuple. marathon.shape should be a tuple\"\nassert sha1(str(len(marathon.shape)).encode(\"utf-8\")+b\"739e4\").hexdigest() == \"2e34911a50836d3cf47d13ee702a774b05b66acf\", \"length of marathon.shape is not correct\"\nassert sha1(str(sorted(map(str, marathon.shape))).encode(\"utf-8\")+b\"739e4\").hexdigest() == \"07d7c57045b521db23e59bcd29a30b64f750e408\", \"values of marathon.shape are not correct\"\nassert sha1(str(marathon.shape).encode(\"utf-8\")+b\"739e4\").hexdigest() == \"c1b0dafb0e4d543a159d3cef1509b02336267aef\", \"order of elements of marathon.shape is not correct\"\n\nassert sha1(str(type(\"time_hrs\" in marathon.columns)).encode(\"utf-8\")+b\"739e5\").hexdigest() == \"b804c528bed5bf422960fd5c803d8d8689b2cdd6\", \"type of \\\"time_hrs\\\" in marathon.columns is not bool. \\\"time_hrs\\\" in marathon.columns should be a bool\"\nassert sha1(str(\"time_hrs\" in marathon.columns).encode(\"utf-8\")+b\"739e5\").hexdigest() == \"65ee06ccfc8ecf0d0497cf6b3322c74797040486\", \"boolean value of \\\"time_hrs\\\" in marathon.columns is not correct\"\n\nassert sha1(str(type(\"max\" in marathon.columns)).encode(\"utf-8\")+b\"739e6\").hexdigest() == \"73f7cbaa58ac0ae4fcf13fdb39b6a596d0a9e637\", \"type of \\\"max\\\" in marathon.columns is not bool. \\\"max\\\" in marathon.columns should be a bool\"\nassert sha1(str(\"max\" in marathon.columns).encode(\"utf-8\")+b\"739e6\").hexdigest() == \"11b4588727f7e1cd86d42c8e61e257ddf72cb9cf\", \"boolean value of \\\"max\\\" in marathon.columns is not correct\"\n\nassert sha1(str(type(round(sum(marathon['max']), 0))).encode(\"utf-8\")+b\"739e7\").hexdigest() == \"cb0dcf331ef1975fca37d4d6dc1e453b08bf2a33\", \"type of round(sum(marathon['max']), 0) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(round(sum(marathon['max']), 0), 2)).encode(\"utf-8\")+b\"739e7\").hexdigest() == \"0c743d369241ee5ae9d99436f698cf6105d89029\", \"value of round(sum(marathon['max']), 0) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(round(sum(marathon['time_hrs']), 0))).encode(\"utf-8\")+b\"739e8\").hexdigest() == \"bc74cad374cdd1f333d8f0dbdd3e8f40872b3827\", \"type of round(sum(marathon['time_hrs']), 0) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(round(sum(marathon['time_hrs']), 0), 2)).encode(\"utf-8\")+b\"739e8\").hexdigest() == \"014c3d62ed4ff997c449ec3c8c8a4ee9a2353073\", \"value of round(sum(marathon['time_hrs']), 0) is not correct (rounded to 2 decimal places)\"\n\nprint('Success!')\n\nQuestion 1.1  {points: 1}\nSimilar to what we have been doing, we will first split the dataset into the training and testing datasets, using 75% of the original data as the training data. Remember, we will be putting the test dataset away in a ‚Äòlock box‚Äô that we will comeback to later after we choose our final model. Assign your training dataset to an object named marathon_training and your testing dataset to an object named marathon_testing.\nNext, set the time_hrs as the target (y) and max as the feature (X). Store the features as X_train and X_test and targets as y_train and y_test respectively for the marathon_training and marathon_testing.\nAssign the objects to marathon_training, marathon_testing, X_train, y_train, X_test and y_test respectively.\n\n# ___, ___ = train_test_split(\n#     ___,\n#     test_size=___,\n#     random_state=2000,  # Do not change the random_state\n# )\n\n# X_train = ___[___]  # A single column data frame\n# y_train = ___[___]  # A series\n\n# X_test = ___[___]  # A single column data frame\n# y_test = ___[___]  # A series\n\n# your code here\nraise NotImplementedError\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon_training is None)).encode(\"utf-8\")+b\"4f6ad\").hexdigest() == \"f674e38d6fdcb566897037d6bd60a47404feeb21\", \"type of marathon_training is None is not bool. marathon_training is None should be a bool\"\nassert sha1(str(marathon_training is None).encode(\"utf-8\")+b\"4f6ad\").hexdigest() == \"6fa797429392a5d615e12d87d6c270c224b62e87\", \"boolean value of marathon_training is None is not correct\"\n\nassert sha1(str(type(marathon_training.shape)).encode(\"utf-8\")+b\"4f6ae\").hexdigest() == \"c65c0f879cf7d4bd9e072e641450bd00c675daa9\", \"type of marathon_training.shape is not tuple. marathon_training.shape should be a tuple\"\nassert sha1(str(len(marathon_training.shape)).encode(\"utf-8\")+b\"4f6ae\").hexdigest() == \"33b155dbfcff513325406a6efb32adad20db7a02\", \"length of marathon_training.shape is not correct\"\nassert sha1(str(sorted(map(str, marathon_training.shape))).encode(\"utf-8\")+b\"4f6ae\").hexdigest() == \"30d227d9ac1ed57ba85872a2a07b6117d273c251\", \"values of marathon_training.shape are not correct\"\nassert sha1(str(marathon_training.shape).encode(\"utf-8\")+b\"4f6ae\").hexdigest() == \"bb16852ef07255cdb14cab3907de9fdd370231a4\", \"order of elements of marathon_training.shape is not correct\"\n\nassert sha1(str(type(sum(marathon_training.age))).encode(\"utf-8\")+b\"4f6af\").hexdigest() == \"ba50b4a4b9e30582e162d71f7e94533f0cd2670e\", \"type of sum(marathon_training.age) is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(sum(marathon_training.age)).encode(\"utf-8\")+b\"4f6af\").hexdigest() == \"97e4849e109b18815b375aabbc4a675bf8b572f8\", \"value of sum(marathon_training.age) is not correct\"\n\nassert sha1(str(type(marathon_testing is None)).encode(\"utf-8\")+b\"4f6b0\").hexdigest() == \"874282999c909b82564d7ce122d4cc20808ae07d\", \"type of marathon_testing is None is not bool. marathon_testing is None should be a bool\"\nassert sha1(str(marathon_testing is None).encode(\"utf-8\")+b\"4f6b0\").hexdigest() == \"ca991e955d46513ca9dc43cb7faad1510405e6e2\", \"boolean value of marathon_testing is None is not correct\"\n\nassert sha1(str(type(marathon_testing.shape)).encode(\"utf-8\")+b\"4f6b1\").hexdigest() == \"3827f444c705a95782a04332415cd5d97f324216\", \"type of marathon_testing.shape is not tuple. marathon_testing.shape should be a tuple\"\nassert sha1(str(len(marathon_testing.shape)).encode(\"utf-8\")+b\"4f6b1\").hexdigest() == \"906078a9f2abf4de01fcf0daf6461d5788643f77\", \"length of marathon_testing.shape is not correct\"\nassert sha1(str(sorted(map(str, marathon_testing.shape))).encode(\"utf-8\")+b\"4f6b1\").hexdigest() == \"2cc1bdf059f9d6117e78f7d6f6e5821ec9fc1bdb\", \"values of marathon_testing.shape are not correct\"\nassert sha1(str(marathon_testing.shape).encode(\"utf-8\")+b\"4f6b1\").hexdigest() == \"5a1c8ea5fc9a728dee1c0b720c690e0a130064e2\", \"order of elements of marathon_testing.shape is not correct\"\n\nassert sha1(str(type(sum(marathon_testing.age))).encode(\"utf-8\")+b\"4f6b2\").hexdigest() == \"e7a8984d43f4d32c814e54d4358442ad0a96003c\", \"type of sum(marathon_testing.age) is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(sum(marathon_testing.age)).encode(\"utf-8\")+b\"4f6b2\").hexdigest() == \"34fa963b05468045a3dfe6fa84cff7cdcc47d488\", \"value of sum(marathon_testing.age) is not correct\"\n\nassert sha1(str(type(X_train.columns.values)).encode(\"utf-8\")+b\"4f6b3\").hexdigest() == \"58cab9eda29ff2b2d6749caed7393fbdc6843f76\", \"type of X_train.columns.values is not correct\"\nassert sha1(str(X_train.columns.values).encode(\"utf-8\")+b\"4f6b3\").hexdigest() == \"569ca1bdf2aee914b88e0cd7bf39a6fb4701d65a\", \"value of X_train.columns.values is not correct\"\n\nassert sha1(str(type(X_train.shape)).encode(\"utf-8\")+b\"4f6b4\").hexdigest() == \"c6004691c652e546af1b6b67844b4e846344c1d6\", \"type of X_train.shape is not tuple. X_train.shape should be a tuple\"\nassert sha1(str(len(X_train.shape)).encode(\"utf-8\")+b\"4f6b4\").hexdigest() == \"b5e0ccffd5b8cbe7ba6731bff5c23dab8c0f4590\", \"length of X_train.shape is not correct\"\nassert sha1(str(sorted(map(str, X_train.shape))).encode(\"utf-8\")+b\"4f6b4\").hexdigest() == \"1e3e3ec67d9ab5e7ee523bab8f560ee2549bc591\", \"values of X_train.shape are not correct\"\nassert sha1(str(X_train.shape).encode(\"utf-8\")+b\"4f6b4\").hexdigest() == \"010ca15c9c455f5f34e84a6483db2b38abbf6bc0\", \"order of elements of X_train.shape is not correct\"\n\nassert sha1(str(type(y_train.name)).encode(\"utf-8\")+b\"4f6b5\").hexdigest() == \"dffb93a65b9c15090a1dac65485392d02dd3b05e\", \"type of y_train.name is not str. y_train.name should be an str\"\nassert sha1(str(len(y_train.name)).encode(\"utf-8\")+b\"4f6b5\").hexdigest() == \"0def0bf84e8da55beab10cd1fbfd9f7fbd31a1cc\", \"length of y_train.name is not correct\"\nassert sha1(str(y_train.name.lower()).encode(\"utf-8\")+b\"4f6b5\").hexdigest() == \"9ede03ef4c98e99b336e0465df700ab86f738d01\", \"value of y_train.name is not correct\"\nassert sha1(str(y_train.name).encode(\"utf-8\")+b\"4f6b5\").hexdigest() == \"9ede03ef4c98e99b336e0465df700ab86f738d01\", \"correct string value of y_train.name but incorrect case of letters\"\n\nassert sha1(str(type(y_train.shape)).encode(\"utf-8\")+b\"4f6b6\").hexdigest() == \"14ef9f53aed59146615896c647d72fdee84a030d\", \"type of y_train.shape is not tuple. y_train.shape should be a tuple\"\nassert sha1(str(len(y_train.shape)).encode(\"utf-8\")+b\"4f6b6\").hexdigest() == \"bcfdddcab49f87ca8545d798e2d70e638926a45e\", \"length of y_train.shape is not correct\"\nassert sha1(str(sorted(map(str, y_train.shape))).encode(\"utf-8\")+b\"4f6b6\").hexdigest() == \"9149d98edddfb638a4de90d61ed99ae9884bb8a7\", \"values of y_train.shape are not correct\"\nassert sha1(str(y_train.shape).encode(\"utf-8\")+b\"4f6b6\").hexdigest() == \"b7502ed93b7fb6823b51c2982622b915a4fb1041\", \"order of elements of y_train.shape is not correct\"\n\nassert sha1(str(type(X_test.columns.values)).encode(\"utf-8\")+b\"4f6b7\").hexdigest() == \"4474a8a8bfdfc8b012d956db8931980b76744722\", \"type of X_test.columns.values is not correct\"\nassert sha1(str(X_test.columns.values).encode(\"utf-8\")+b\"4f6b7\").hexdigest() == \"b2549900463f19a702b41da70c671104c0e8b682\", \"value of X_test.columns.values is not correct\"\n\nassert sha1(str(type(X_test.shape)).encode(\"utf-8\")+b\"4f6b8\").hexdigest() == \"4c2da79bd29e66ef3fbb291d5188459fc5c4706f\", \"type of X_test.shape is not tuple. X_test.shape should be a tuple\"\nassert sha1(str(len(X_test.shape)).encode(\"utf-8\")+b\"4f6b8\").hexdigest() == \"ecd604671069f62e45124763ec88fc80d7b82498\", \"length of X_test.shape is not correct\"\nassert sha1(str(sorted(map(str, X_test.shape))).encode(\"utf-8\")+b\"4f6b8\").hexdigest() == \"3bf5695fc56458e4405a6f88a4f5506f5d901cb8\", \"values of X_test.shape are not correct\"\nassert sha1(str(X_test.shape).encode(\"utf-8\")+b\"4f6b8\").hexdigest() == \"352788e35c8d809802def81e35c175258a93bd69\", \"order of elements of X_test.shape is not correct\"\n\nassert sha1(str(type(y_test.name)).encode(\"utf-8\")+b\"4f6b9\").hexdigest() == \"4b81d94ef69cd62c1396789593bbee6e8a5fa1a5\", \"type of y_test.name is not str. y_test.name should be an str\"\nassert sha1(str(len(y_test.name)).encode(\"utf-8\")+b\"4f6b9\").hexdigest() == \"f9f25f4c81c55229317166657fe150f016b21d38\", \"length of y_test.name is not correct\"\nassert sha1(str(y_test.name.lower()).encode(\"utf-8\")+b\"4f6b9\").hexdigest() == \"b708b2f0439fe252df818bf470eee84eb19da428\", \"value of y_test.name is not correct\"\nassert sha1(str(y_test.name).encode(\"utf-8\")+b\"4f6b9\").hexdigest() == \"b708b2f0439fe252df818bf470eee84eb19da428\", \"correct string value of y_test.name but incorrect case of letters\"\n\nassert sha1(str(type(y_test.shape)).encode(\"utf-8\")+b\"4f6ba\").hexdigest() == \"f18361d9de35bec90f44b45ee43725ea9777275c\", \"type of y_test.shape is not tuple. y_test.shape should be a tuple\"\nassert sha1(str(len(y_test.shape)).encode(\"utf-8\")+b\"4f6ba\").hexdigest() == \"e2309e5b908c5857ae791835ba17a8025f1c4312\", \"length of y_test.shape is not correct\"\nassert sha1(str(sorted(map(str, y_test.shape))).encode(\"utf-8\")+b\"4f6ba\").hexdigest() == \"89c5cd5a88c20980c89973a438767b9f8a88ce3e\", \"values of y_test.shape are not correct\"\nassert sha1(str(y_test.shape).encode(\"utf-8\")+b\"4f6ba\").hexdigest() == \"78ec5b8e1118ac59272fb5d5fdde68b526f3e166\", \"order of elements of y_test.shape is not correct\"\n\nprint('Success!')\n\nQuestion 1.2  {points: 1}\nUsing only the observations in the training dataset, create a scatterplot to assess the relationship between race time (time_hrs) and maximum distance ran per week during training (max). Put time_hrs on the y-axis and max on the x-axis. Use mark_point and remember to do whatever is necessary to make this an effective visualization, including addressing overplotting in a suitable manner.\nAssign this plot to an object called marathon_scatter.\n\n# your code here\nraise NotImplementedError\nmarathon_scatter\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon_scatter is None)).encode(\"utf-8\")+b\"6986b\").hexdigest() == \"be72f6a83cd9482319f43f4b049fdd940e1f4c6d\", \"type of marathon_scatter is None is not bool. marathon_scatter is None should be a bool\"\nassert sha1(str(marathon_scatter is None).encode(\"utf-8\")+b\"6986b\").hexdigest() == \"79682770c2f1c151e70550446c11cc299f292dd9\", \"boolean value of marathon_scatter is None is not correct\"\n\nassert sha1(str(type(marathon_scatter.encoding.x['shorthand'])).encode(\"utf-8\")+b\"6986c\").hexdigest() == \"6d3c30ce678b314024b4d80b82e5ed9697c02ce0\", \"type of marathon_scatter.encoding.x['shorthand'] is not str. marathon_scatter.encoding.x['shorthand'] should be an str\"\nassert sha1(str(len(marathon_scatter.encoding.x['shorthand'])).encode(\"utf-8\")+b\"6986c\").hexdigest() == \"0d12f86dda5f48bc1e5d3675345950ca7a48c4e7\", \"length of marathon_scatter.encoding.x['shorthand'] is not correct\"\nassert sha1(str(marathon_scatter.encoding.x['shorthand'].lower()).encode(\"utf-8\")+b\"6986c\").hexdigest() == \"8630293695025e3d22cab897d7c35cb472b47b6a\", \"value of marathon_scatter.encoding.x['shorthand'] is not correct\"\nassert sha1(str(marathon_scatter.encoding.x['shorthand']).encode(\"utf-8\")+b\"6986c\").hexdigest() == \"8630293695025e3d22cab897d7c35cb472b47b6a\", \"correct string value of marathon_scatter.encoding.x['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(marathon_scatter.encoding.y['shorthand'])).encode(\"utf-8\")+b\"6986d\").hexdigest() == \"2d41e0469437832c726023d3cf4e14159bd09b4c\", \"type of marathon_scatter.encoding.y['shorthand'] is not str. marathon_scatter.encoding.y['shorthand'] should be an str\"\nassert sha1(str(len(marathon_scatter.encoding.y['shorthand'])).encode(\"utf-8\")+b\"6986d\").hexdigest() == \"d931044a5378994c5f2df4ddb4637dbabf5d23f6\", \"length of marathon_scatter.encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_scatter.encoding.y['shorthand'].lower()).encode(\"utf-8\")+b\"6986d\").hexdigest() == \"c3e46f0aece8b220b81d7e8ea490b10e5265e671\", \"value of marathon_scatter.encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_scatter.encoding.y['shorthand']).encode(\"utf-8\")+b\"6986d\").hexdigest() == \"c3e46f0aece8b220b81d7e8ea490b10e5265e671\", \"correct string value of marathon_scatter.encoding.y['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(marathon_scatter.mark.type)).encode(\"utf-8\")+b\"6986e\").hexdigest() == \"25bf70dd77143087753edd66a74bdbdab609b641\", \"type of marathon_scatter.mark.type is not str. marathon_scatter.mark.type should be an str\"\nassert sha1(str(len(marathon_scatter.mark.type)).encode(\"utf-8\")+b\"6986e\").hexdigest() == \"64843ac47bf38de071408c16ebd821f565913dc5\", \"length of marathon_scatter.mark.type is not correct\"\nassert sha1(str(marathon_scatter.mark.type.lower()).encode(\"utf-8\")+b\"6986e\").hexdigest() == \"0c5b2e8e01caf2686729e9e986b2e067d2f5f42c\", \"value of marathon_scatter.mark.type is not correct\"\nassert sha1(str(marathon_scatter.mark.type).encode(\"utf-8\")+b\"6986e\").hexdigest() == \"0c5b2e8e01caf2686729e9e986b2e067d2f5f42c\", \"correct string value of marathon_scatter.mark.type but incorrect case of letters\"\n\nassert sha1(str(type(marathon_scatter.data.shape[0])).encode(\"utf-8\")+b\"6986f\").hexdigest() == \"fb072f8df94e039c392391cbcbafbdcbb5f6b693\", \"type of marathon_scatter.data.shape[0] is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(marathon_scatter.data.shape[0]).encode(\"utf-8\")+b\"6986f\").hexdigest() == \"b7c9c137f9bca9116ce605daa01dcd1c0edf9ec4\", \"value of marathon_scatter.data.shape[0] is not correct\"\n\nassert sha1(str(type('opacity' in marathon_scatter.mark.to_dict())).encode(\"utf-8\")+b\"69870\").hexdigest() == \"dd9e9a03b10d76cac8120e773139b76b99491ff9\", \"type of 'opacity' in marathon_scatter.mark.to_dict() is not bool. 'opacity' in marathon_scatter.mark.to_dict() should be a bool\"\nassert sha1(str('opacity' in marathon_scatter.mark.to_dict()).encode(\"utf-8\")+b\"69870\").hexdigest() == \"3c374d1e3da1cbd8cdef7d942941642f04285685\", \"boolean value of 'opacity' in marathon_scatter.mark.to_dict() is not correct\"\n\nassert sha1(str(type(isinstance(marathon_scatter.encoding.x['title'], str))).encode(\"utf-8\")+b\"69871\").hexdigest() == \"e02db54bd87fbf96616612a56f8acf8cf441d515\", \"type of isinstance(marathon_scatter.encoding.x['title'], str) is not bool. isinstance(marathon_scatter.encoding.x['title'], str) should be a bool\"\nassert sha1(str(isinstance(marathon_scatter.encoding.x['title'], str)).encode(\"utf-8\")+b\"69871\").hexdigest() == \"acd2e62da16b691eb93e82f53cbf50df9822ab62\", \"boolean value of isinstance(marathon_scatter.encoding.x['title'], str) is not correct\"\n\nassert sha1(str(type(isinstance(marathon_scatter.encoding.y['title'], str))).encode(\"utf-8\")+b\"69872\").hexdigest() == \"8295031153ea95799755569e0f06ae54b3f3b979\", \"type of isinstance(marathon_scatter.encoding.y['title'], str) is not bool. isinstance(marathon_scatter.encoding.y['title'], str) should be a bool\"\nassert sha1(str(isinstance(marathon_scatter.encoding.y['title'], str)).encode(\"utf-8\")+b\"69872\").hexdigest() == \"db51f97f3427306d46b9eb73b81474c0e722baa9\", \"boolean value of isinstance(marathon_scatter.encoding.y['title'], str) is not correct\"\n\nprint('Success!')\n\nQuestion 1.3  {points: 1}\nNow that we have looked at our training data, the next step is to build a linear regression model.\nInstead of using the KNeighborsRegressor function, we will be using the LinearRegression function to let scikit-learn know we want to perform a linear regression.\nAssign your answer to an object named lm.\n\n# lm = _____()\n\n# your code here\nraise NotImplementedError\nlm\n\n\nfrom hashlib import sha1\nassert sha1(str(type(lm is None)).encode(\"utf-8\")+b\"72c66\").hexdigest() == \"e97b0813818ca802348d6ece9741f60284f4097b\", \"type of lm is None is not bool. lm is None should be a bool\"\nassert sha1(str(lm is None).encode(\"utf-8\")+b\"72c66\").hexdigest() == \"3ce1f42f1c88457c878430a27cbeb6f909b0785c\", \"boolean value of lm is None is not correct\"\n\nassert sha1(str(type(type(lm))).encode(\"utf-8\")+b\"72c67\").hexdigest() == \"1d32ce0e00e2e0a8dd67995b0fad71c00083aa05\", \"type of type(lm) is not correct\"\nassert sha1(str(type(lm)).encode(\"utf-8\")+b\"72c67\").hexdigest() == \"c91e4bde80d303487c49aae5c34b1f381a58f9c1\", \"value of type(lm) is not correct\"\n\nprint('Success!')\n\nQuestion 1.3.1 {points: 1}\nAfter we have created our linear regression model, the next step is to fit the training dataset.\nAssign your answer to an object named lm_fit.\n\n# ___ = ___.fit(___, ___)\n\n# your code here\nraise NotImplementedError\nlm_fit\n\n\nfrom hashlib import sha1\nassert sha1(str(type(lm_fit is None)).encode(\"utf-8\")+b\"ad3bc\").hexdigest() == \"1def08aec5fd67069ff460655ea29adfcd0cb743\", \"type of lm_fit is None is not bool. lm_fit is None should be a bool\"\nassert sha1(str(lm_fit is None).encode(\"utf-8\")+b\"ad3bc\").hexdigest() == \"fa8f0226d403f32ba484b227d8cc4455061bc019\", \"boolean value of lm_fit is None is not correct\"\n\nassert sha1(str(type(type(lm_fit))).encode(\"utf-8\")+b\"ad3bd\").hexdigest() == \"4366e1fb6059f520d285ba77171d1b1744923f34\", \"type of type(lm_fit) is not correct\"\nassert sha1(str(type(lm_fit)).encode(\"utf-8\")+b\"ad3bd\").hexdigest() == \"86f605051db98874d8cf0eb9c0db6fd94496091f\", \"value of type(lm_fit) is not correct\"\n\nassert sha1(str(type(lm_fit.coef_)).encode(\"utf-8\")+b\"ad3be\").hexdigest() == \"228ee7178527d0f2e5cff2853156700111ed8d69\", \"type of lm_fit.coef_ is not correct\"\nassert sha1(str(lm_fit.coef_).encode(\"utf-8\")+b\"ad3be\").hexdigest() == \"dfde7db1fb226af0937f0a18a269f587a6be23e6\", \"value of lm_fit.coef_ is not correct\"\n\nprint('Success!')\n\nQuestion 1.4  {points: 1}\nNow, let‚Äôs visualize the model predictions as a straight line overlaid on the training data. Use the predict function of lm to create predictions for the marathon_training data. Then, add the column of predictions to the marathon_training data frame using the assign function. Name the resulting data frame marathon_preds and the new column predictions.\nNext, create a scatterplot with the marathon time (y-axis) against the maximum distance run per week (x-axis) from marathon_preds. Use mark_circle with an opacity of 0.4 to avoid overplotting. Assign your plot to a variable called marathon_plot. Plot the predictions as a black line over the data points. Remember the fundamentals of effective visualizations such as having a human-readable axes titles.\nName your plot marathon_plot.\n\n# marathon_preds = ____.assign(\n#     predictions= _____.predict(____)\n# )\n# scatterplot = ___\n#\n# marathon_plot = scatterplot + ___.mark_line(___).encode(___)\n\n# your code here\nraise NotImplementedError\nmarathon_plot\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon_preds is None)).encode(\"utf-8\")+b\"e4358\").hexdigest() == \"bc2dd580b40ad4a5e8f6594b34d9ed807fc56664\", \"type of marathon_preds is None is not bool. marathon_preds is None should be a bool\"\nassert sha1(str(marathon_preds is None).encode(\"utf-8\")+b\"e4358\").hexdigest() == \"02df6a309e4c0c99b29a5ebbbf4dc40df215e117\", \"boolean value of marathon_preds is None is not correct\"\n\nassert sha1(str(type(marathon_preds)).encode(\"utf-8\")+b\"e4359\").hexdigest() == \"65a340844bf360cea4cd1679e420c55d09e7829e\", \"type of type(marathon_preds) is not correct\"\n\nassert sha1(str(type(marathon_preds.shape)).encode(\"utf-8\")+b\"e435a\").hexdigest() == \"94b8396ef806348aa6e6d9b48d968db839e0de43\", \"type of marathon_preds.shape is not tuple. marathon_preds.shape should be a tuple\"\nassert sha1(str(len(marathon_preds.shape)).encode(\"utf-8\")+b\"e435a\").hexdigest() == \"80b67edab105b410e9f659d46edd8aafd252ea78\", \"length of marathon_preds.shape is not correct\"\nassert sha1(str(sorted(map(str, marathon_preds.shape))).encode(\"utf-8\")+b\"e435a\").hexdigest() == \"c199087afcc62232805f8ca370d7d5302e4062f1\", \"values of marathon_preds.shape are not correct\"\nassert sha1(str(marathon_preds.shape).encode(\"utf-8\")+b\"e435a\").hexdigest() == \"75a932b02b8b81bcd148774ce58e3466adaa9909\", \"order of elements of marathon_preds.shape is not correct\"\n\nassert sha1(str(type(\"predictions\" in marathon_preds.columns)).encode(\"utf-8\")+b\"e435b\").hexdigest() == \"7b0e6ae601f0ebf430c4e607354a84912f34ebc0\", \"type of \\\"predictions\\\" in marathon_preds.columns is not bool. \\\"predictions\\\" in marathon_preds.columns should be a bool\"\nassert sha1(str(\"predictions\" in marathon_preds.columns).encode(\"utf-8\")+b\"e435b\").hexdigest() == \"d146815eae7ededa977915471ab4ffbe2dd98791\", \"boolean value of \\\"predictions\\\" in marathon_preds.columns is not correct\"\n\nassert sha1(str(type(sum(marathon_preds.predictions))).encode(\"utf-8\")+b\"e435c\").hexdigest() == \"3531d0a530b71a74d474021791451f589648ab04\", \"type of sum(marathon_preds.predictions) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(marathon_preds.predictions), 2)).encode(\"utf-8\")+b\"e435c\").hexdigest() == \"6c69e3cb1469494214b9c3c30df43792dcd4283e\", \"value of sum(marathon_preds.predictions) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(sum(marathon_preds.time_hrs))).encode(\"utf-8\")+b\"e435d\").hexdigest() == \"f6d32fcdfb7d338ca64c10d130c219848d79c187\", \"type of sum(marathon_preds.time_hrs) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(marathon_preds.time_hrs), 2)).encode(\"utf-8\")+b\"e435d\").hexdigest() == \"2f02cb1ab8ae3a31440a49ce11b661ff8fe9147e\", \"value of sum(marathon_preds.time_hrs) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(marathon_plot is None)).encode(\"utf-8\")+b\"e435e\").hexdigest() == \"6895d3cddb99e4147ba45a6c81bc4ddc364e23c2\", \"type of marathon_plot is None is not bool. marathon_plot is None should be a bool\"\nassert sha1(str(marathon_plot is None).encode(\"utf-8\")+b\"e435e\").hexdigest() == \"5390df15c8c3f55e9daedb39794d57638e99efee\", \"boolean value of marathon_plot is None is not correct\"\n\nassert sha1(str(type(len(marathon_plot.layer))).encode(\"utf-8\")+b\"e435f\").hexdigest() == \"e97a9a1e7ad3c233095b4ba0008121bc6a74261d\", \"type of len(marathon_plot.layer) is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(len(marathon_plot.layer)).encode(\"utf-8\")+b\"e435f\").hexdigest() == \"2b20945255b0f2a7695411e709eafe5b6b888d2f\", \"value of len(marathon_plot.layer) is not correct\"\n\nassert sha1(str(type(marathon_plot.layer[0].mark)).encode(\"utf-8\")+b\"e4360\").hexdigest() == \"94d874e6d384f6f20dee36b57d02ee0e9d835e2d\", \"type of marathon_plot.layer[0].mark is not correct\"\nassert sha1(str(marathon_plot.layer[0].mark).encode(\"utf-8\")+b\"e4360\").hexdigest() == \"a944ff98b1e615df7fa19be2866a054377367251\", \"value of marathon_plot.layer[0].mark is not correct\"\n\nassert sha1(str(type(marathon_plot.layer[1].mark)).encode(\"utf-8\")+b\"e4361\").hexdigest() == \"71a33d1d974bc8658efed76d2ca77308b690d2fd\", \"type of marathon_plot.layer[1].mark is not correct\"\nassert sha1(str(marathon_plot.layer[1].mark).encode(\"utf-8\")+b\"e4361\").hexdigest() == \"a277cc73edf5fe1ef0dbef797094351e1114f778\", \"value of marathon_plot.layer[1].mark is not correct\"\n\nassert sha1(str(type(marathon_plot.layer[0].encoding.x['shorthand'])).encode(\"utf-8\")+b\"e4362\").hexdigest() == \"d8ab0ac01648e3309ae4d80e94515a5364bb5499\", \"type of marathon_plot.layer[0].encoding.x['shorthand'] is not str. marathon_plot.layer[0].encoding.x['shorthand'] should be an str\"\nassert sha1(str(len(marathon_plot.layer[0].encoding.x['shorthand'])).encode(\"utf-8\")+b\"e4362\").hexdigest() == \"839d138b1eeed4328365ef5af63e42c0910bb888\", \"length of marathon_plot.layer[0].encoding.x['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[0].encoding.x['shorthand'].lower()).encode(\"utf-8\")+b\"e4362\").hexdigest() == \"c6293c84c9e09e66386aeb65a91fcd8df6601e09\", \"value of marathon_plot.layer[0].encoding.x['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[0].encoding.x['shorthand']).encode(\"utf-8\")+b\"e4362\").hexdigest() == \"c6293c84c9e09e66386aeb65a91fcd8df6601e09\", \"correct string value of marathon_plot.layer[0].encoding.x['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(marathon_plot.layer[0].encoding.y['shorthand'])).encode(\"utf-8\")+b\"e4363\").hexdigest() == \"3fd3774342c69f8858f9acea94a03c9890a18a93\", \"type of marathon_plot.layer[0].encoding.y['shorthand'] is not str. marathon_plot.layer[0].encoding.y['shorthand'] should be an str\"\nassert sha1(str(len(marathon_plot.layer[0].encoding.y['shorthand'])).encode(\"utf-8\")+b\"e4363\").hexdigest() == \"c5b64aeb2742f503eb3854087c4f836b06acede1\", \"length of marathon_plot.layer[0].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[0].encoding.y['shorthand'].lower()).encode(\"utf-8\")+b\"e4363\").hexdigest() == \"06f9ff5b96ee6e75cd8cf966d5552fe7f717f260\", \"value of marathon_plot.layer[0].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[0].encoding.y['shorthand']).encode(\"utf-8\")+b\"e4363\").hexdigest() == \"06f9ff5b96ee6e75cd8cf966d5552fe7f717f260\", \"correct string value of marathon_plot.layer[0].encoding.y['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(marathon_plot.layer[1].encoding.y['shorthand'])).encode(\"utf-8\")+b\"e4364\").hexdigest() == \"14b5ec8e3ca9e9418bdbbaa77a9b3aa179999fe9\", \"type of marathon_plot.layer[1].encoding.y['shorthand'] is not str. marathon_plot.layer[1].encoding.y['shorthand'] should be an str\"\nassert sha1(str(len(marathon_plot.layer[1].encoding.y['shorthand'])).encode(\"utf-8\")+b\"e4364\").hexdigest() == \"6f6fc84ebe98dc81fb989889721610b969b2e700\", \"length of marathon_plot.layer[1].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[1].encoding.y['shorthand'].lower()).encode(\"utf-8\")+b\"e4364\").hexdigest() == \"6ae5bc9df9fd334f0eac6345e13a01b9dd019844\", \"value of marathon_plot.layer[1].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[1].encoding.y['shorthand']).encode(\"utf-8\")+b\"e4364\").hexdigest() == \"6ae5bc9df9fd334f0eac6345e13a01b9dd019844\", \"correct string value of marathon_plot.layer[1].encoding.y['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(isinstance(marathon_plot.layer[0].encoding.x['title'], str))).encode(\"utf-8\")+b\"e4365\").hexdigest() == \"6d1dfcd98beb4541c755ed9ee5b65dbd667070f0\", \"type of isinstance(marathon_plot.layer[0].encoding.x['title'], str) is not bool. isinstance(marathon_plot.layer[0].encoding.x['title'], str) should be a bool\"\nassert sha1(str(isinstance(marathon_plot.layer[0].encoding.x['title'], str)).encode(\"utf-8\")+b\"e4365\").hexdigest() == \"7b15eabe489e4ffa5a44043c97d017234a7e0a0a\", \"boolean value of isinstance(marathon_plot.layer[0].encoding.x['title'], str) is not correct\"\n\nassert sha1(str(type(isinstance(marathon_plot.layer[0].encoding.y['title'], str))).encode(\"utf-8\")+b\"e4366\").hexdigest() == \"f0651e9d8742d2b0750aea688fcf11ea2e3383f8\", \"type of isinstance(marathon_plot.layer[0].encoding.y['title'], str) is not bool. isinstance(marathon_plot.layer[0].encoding.y['title'], str) should be a bool\"\nassert sha1(str(isinstance(marathon_plot.layer[0].encoding.y['title'], str)).encode(\"utf-8\")+b\"e4366\").hexdigest() == \"0e91055a5f12d74e8593f359e143862b6a8fc193\", \"boolean value of isinstance(marathon_plot.layer[0].encoding.y['title'], str) is not correct\"\n\nprint('Success!')\n\nQuestion 1.5  {points: 1}\nGreat! We can now see the line of best fit on the graph. Now let‚Äôs calculate the RMSPE using the test data. To get to this point, first, use the lm object to make predictions on the test data. Then, add the column of predictions to the marathon_testing data frame using the assign function. Name the resulting data frame test_preds and the new column predictions.\nAfterwards, calculate the RMSPE using the mean_squared_error function.\nAssign the RMSPE score to an object called lm_rmspe.\n\n# ___ = ___.assign(\n#     predictions=___.predict(___)\n# )\n\n# ___ = ___(___, ___)**(1/2)\n\n# your code here\nraise NotImplementedError\nlm_rmspe\n\n\nfrom hashlib import sha1\nassert sha1(str(type(test_preds is None)).encode(\"utf-8\")+b\"3ebdc\").hexdigest() == \"29ebee7ab2061555cdd2621507b3792dbb886297\", \"type of test_preds is None is not bool. test_preds is None should be a bool\"\nassert sha1(str(test_preds is None).encode(\"utf-8\")+b\"3ebdc\").hexdigest() == \"6a7c108f74c9bf5ddfe1618a204e71dd5069e8c5\", \"boolean value of test_preds is None is not correct\"\n\nassert sha1(str(type(test_preds)).encode(\"utf-8\")+b\"3ebdd\").hexdigest() == \"763191835b51c258b842454c271700f9cdfea3bf\", \"type of type(test_preds) is not correct\"\n\nassert sha1(str(type(test_preds.shape)).encode(\"utf-8\")+b\"3ebde\").hexdigest() == \"89d3f1293bc4be750513c8cdb8c60056333d8f96\", \"type of test_preds.shape is not tuple. test_preds.shape should be a tuple\"\nassert sha1(str(len(test_preds.shape)).encode(\"utf-8\")+b\"3ebde\").hexdigest() == \"bc721a860c2268ce910d4702796d17031d8ea8a8\", \"length of test_preds.shape is not correct\"\nassert sha1(str(sorted(map(str, test_preds.shape))).encode(\"utf-8\")+b\"3ebde\").hexdigest() == \"1a83b659bfa801824e9221c8426149a4b5fa861b\", \"values of test_preds.shape are not correct\"\nassert sha1(str(test_preds.shape).encode(\"utf-8\")+b\"3ebde\").hexdigest() == \"bd984a5c94d60104a3e575235235426ccfbc98c7\", \"order of elements of test_preds.shape is not correct\"\n\nassert sha1(str(type(sum(test_preds.predictions))).encode(\"utf-8\")+b\"3ebdf\").hexdigest() == \"a072e028d9a3b80e8f68ddb270a40eb499596870\", \"type of sum(test_preds.predictions) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(test_preds.predictions), 2)).encode(\"utf-8\")+b\"3ebdf\").hexdigest() == \"71c296aa4d1218d1231b125f36f9a6c915f67cf1\", \"value of sum(test_preds.predictions) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(round(lm_rmspe, 1))).encode(\"utf-8\")+b\"3ebe2\").hexdigest() == 'e566caf8a3b27dc42c29f121d257bc3db3506298', \"type of round(lm_rmspe, 1) is not correct\"\nassert sha1(str(round(lm_rmspe, 1)).encode(\"utf-8\")+b\"3ebe2\").hexdigest() == \"a6d4449e0d5e3251aa0d7523dcbda18946bf141d\", \"value of round(lm_rmspe, 1) is not correct\"\n\nprint('Success!')\n\nQuestion 1.5.1  {points: 1}\nNow, let‚Äôs visualize the model predictions as a straight line overlaid on the test data. First, create a scatterplot to assess the relationship between race time (time_hrs) and maximum distance ran per week during training (max) on the testing data. Use mark_circle with an opacity of 0.4 to avoid overplotting. Then add a line to the plot corresponding to the predictions (predictions) from the fit linear regression model. Remember to do whatever is necessary to make this an effective visualization.\nAssign the plot to an object called marathon_plot_test.\n\n# marathon_plot = ___\n\n# your code here\nraise NotImplementedError\nmarathon_plot_test\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon_plot_test is None)).encode(\"utf-8\")+b\"61e8f\").hexdigest() == \"ee748f5ffeeccfa151a95c1c8e40fb2e51b1ce9f\", \"type of marathon_plot_test is None is not bool. marathon_plot_test is None should be a bool\"\nassert sha1(str(marathon_plot_test is None).encode(\"utf-8\")+b\"61e8f\").hexdigest() == \"f71b2edba5243e8d1a90ce0d7e7b37557a0f0052\", \"boolean value of marathon_plot_test is None is not correct\"\n\nassert sha1(str(type(len(marathon_plot_test.layer))).encode(\"utf-8\")+b\"61e90\").hexdigest() == \"6d39d35690606462cf06c5a978d8b727d3090082\", \"type of len(marathon_plot_test.layer) is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(len(marathon_plot_test.layer)).encode(\"utf-8\")+b\"61e90\").hexdigest() == \"421355b186989ec09a7f6e161cda4600cd1021bb\", \"value of len(marathon_plot_test.layer) is not correct\"\n\nassert sha1(str(type(marathon_plot_test.layer[0].mark)).encode(\"utf-8\")+b\"61e91\").hexdigest() == \"3246755d74b7833a9ea578910cdf8696d3fce524\", \"type of marathon_plot_test.layer[0].mark is not correct\"\nassert sha1(str(marathon_plot_test.layer[0].mark).encode(\"utf-8\")+b\"61e91\").hexdigest() == \"bf51585cca690c54f425c1a947e05ea8faa39710\", \"value of marathon_plot_test.layer[0].mark is not correct\"\n\nassert sha1(str(type(marathon_plot_test.layer[1].mark)).encode(\"utf-8\")+b\"61e92\").hexdigest() == \"fed14b1460cbd668b78fe2a24b76c721a7b6ef35\", \"type of marathon_plot_test.layer[1].mark is not correct\"\nassert sha1(str(marathon_plot_test.layer[1].mark).encode(\"utf-8\")+b\"61e92\").hexdigest() == \"7c3f41c9edb9129aef9b6afbb5afbd53b5a21bc3\", \"value of marathon_plot_test.layer[1].mark is not correct\"\n\nassert sha1(str(type(marathon_plot_test.layer[0].encoding.x['shorthand'])).encode(\"utf-8\")+b\"61e93\").hexdigest() == \"b36d5e994a7b12c3f08e6d34610ef7745b04a68b\", \"type of marathon_plot_test.layer[0].encoding.x['shorthand'] is not str. marathon_plot_test.layer[0].encoding.x['shorthand'] should be an str\"\nassert sha1(str(len(marathon_plot_test.layer[0].encoding.x['shorthand'])).encode(\"utf-8\")+b\"61e93\").hexdigest() == \"6ab52032148d76cb4c992137ba98a5642ccd1c07\", \"length of marathon_plot_test.layer[0].encoding.x['shorthand'] is not correct\"\nassert sha1(str(marathon_plot_test.layer[0].encoding.x['shorthand'].lower()).encode(\"utf-8\")+b\"61e93\").hexdigest() == \"f5d25df889e84991486b73bd90133cc33805a2c7\", \"value of marathon_plot_test.layer[0].encoding.x['shorthand'] is not correct\"\nassert sha1(str(marathon_plot_test.layer[0].encoding.x['shorthand']).encode(\"utf-8\")+b\"61e93\").hexdigest() == \"f5d25df889e84991486b73bd90133cc33805a2c7\", \"correct string value of marathon_plot_test.layer[0].encoding.x['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(marathon_plot_test.layer[0].encoding.y['shorthand'])).encode(\"utf-8\")+b\"61e94\").hexdigest() == \"ddef04a4b677f36a2461ae87bd64c145cbe414e7\", \"type of marathon_plot_test.layer[0].encoding.y['shorthand'] is not str. marathon_plot_test.layer[0].encoding.y['shorthand'] should be an str\"\nassert sha1(str(len(marathon_plot_test.layer[0].encoding.y['shorthand'])).encode(\"utf-8\")+b\"61e94\").hexdigest() == \"d12e59210898a0cbdd59886ed5b66fe72ef419a5\", \"length of marathon_plot_test.layer[0].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot_test.layer[0].encoding.y['shorthand'].lower()).encode(\"utf-8\")+b\"61e94\").hexdigest() == \"0528e9c8beb5841dd4f6ea3e120aa2ea6851f6d3\", \"value of marathon_plot_test.layer[0].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot_test.layer[0].encoding.y['shorthand']).encode(\"utf-8\")+b\"61e94\").hexdigest() == \"0528e9c8beb5841dd4f6ea3e120aa2ea6851f6d3\", \"correct string value of marathon_plot_test.layer[0].encoding.y['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(marathon_plot_test.layer[1].encoding.y['shorthand'])).encode(\"utf-8\")+b\"61e95\").hexdigest() == \"393f83ca4126abac28e3721499e74cbc8eec49f5\", \"type of marathon_plot_test.layer[1].encoding.y['shorthand'] is not str. marathon_plot_test.layer[1].encoding.y['shorthand'] should be an str\"\nassert sha1(str(len(marathon_plot_test.layer[1].encoding.y['shorthand'])).encode(\"utf-8\")+b\"61e95\").hexdigest() == \"cf6648e5023cea85b35e732f848817cbef50a2ea\", \"length of marathon_plot_test.layer[1].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot_test.layer[1].encoding.y['shorthand'].lower()).encode(\"utf-8\")+b\"61e95\").hexdigest() == \"482407e92cdb21525edc25dc9759ecd8f28ac4b0\", \"value of marathon_plot_test.layer[1].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot_test.layer[1].encoding.y['shorthand']).encode(\"utf-8\")+b\"61e95\").hexdigest() == \"482407e92cdb21525edc25dc9759ecd8f28ac4b0\", \"correct string value of marathon_plot_test.layer[1].encoding.y['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(isinstance(marathon_plot_test.layer[0].encoding.x['title'], str))).encode(\"utf-8\")+b\"61e96\").hexdigest() == \"4e9a552197c0d9f091c287c51186481faa373b84\", \"type of isinstance(marathon_plot_test.layer[0].encoding.x['title'], str) is not bool. isinstance(marathon_plot_test.layer[0].encoding.x['title'], str) should be a bool\"\nassert sha1(str(isinstance(marathon_plot_test.layer[0].encoding.x['title'], str)).encode(\"utf-8\")+b\"61e96\").hexdigest() == \"b5a959a717c4d36b796c0351445d67ceba59555b\", \"boolean value of isinstance(marathon_plot_test.layer[0].encoding.x['title'], str) is not correct\"\n\nassert sha1(str(type(isinstance(marathon_plot_test.layer[0].encoding.y['title'], str))).encode(\"utf-8\")+b\"61e97\").hexdigest() == \"69d55630d9b08b127c64a06a01079ec5fd719e2c\", \"type of isinstance(marathon_plot_test.layer[0].encoding.y['title'], str) is not bool. isinstance(marathon_plot_test.layer[0].encoding.y['title'], str) should be a bool\"\nassert sha1(str(isinstance(marathon_plot_test.layer[0].encoding.y['title'], str)).encode(\"utf-8\")+b\"61e97\").hexdigest() == \"9669df5114cc0166cef2d5b5f35d9333a937d24f\", \"boolean value of isinstance(marathon_plot_test.layer[0].encoding.y['title'], str) is not correct\"\n\nprint('Success!')\n\nQuestion 1.6  {points: 1}\nCompare the RMSPE of k-nn regression (0.616 from last worksheet) to that of simple linear regression. Which is greater?\nA. Simple linear regression has a greater RMSPE\nB. \\(k\\)-nn regression has a greater RMSPE\nC. Neither, they are identical\nSave the letter of your answer to a variable named answer1_6. Make sure you put quotations around the letter and pay attention to case.\n\n# your code here\nraise NotImplementedError\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer1_6)).encode(\"utf-8\")+b\"7d5bf\").hexdigest() == \"3cebb18cc78a764b9b957667aa3b539e088a53b6\", \"type of answer1_6 is not str. answer3_6 should be an str\"\nassert sha1(str(len(answer1_6)).encode(\"utf-8\")+b\"7d5bf\").hexdigest() == \"e2ea38993eafe6e4258dd8f2732bc8f10bf05850\", \"length of answer1_6 is not correct\"\nassert sha1(str(answer1_6.lower()).encode(\"utf-8\")+b\"7d5bf\").hexdigest() == \"d8fc4778f9ae37aeb0d7eebc142c30f17a58afcf\", \"value of answer1_6 is not correct\"\nassert sha1(str(answer1_6).encode(\"utf-8\")+b\"7d5bf\").hexdigest() == \"3469bf05b66975e09572d8f6cebca168c20a4543\", \"correct string value of answer1_6 but incorrect case of letters\"\n\nprint('Success!')\n\nQuestion 1.7  {points: 1}\nWhich model does a better job of predicting on the test dataset?\nA. Simple linear regression\nB. \\(k\\)-nn regression\nC. Neither, they are identical\nSave the letter of your answer to a variable named answer1_7. Make sure you put quotations around the letter and pay attention to case.\n\n# your code here\nraise NotImplementedError\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer1_7)).encode(\"utf-8\")+b\"c4b77\").hexdigest() == \"cbde8d789af13720b9730aa64643b32c579e43c8\", \"type of answer1_7 is not str. answer1_7 should be an str\"\nassert sha1(str(len(answer1_7)).encode(\"utf-8\")+b\"c4b77\").hexdigest() == \"1f1de87eb3b5d616cdc5148f63387a030af2dcdd\", \"length of answer1_7 is not correct\"\nassert sha1(str(answer1_7.lower()).encode(\"utf-8\")+b\"c4b77\").hexdigest() == \"9500e6ffe1848679b170175d4752de72899e0f9e\", \"value of answer1_7 is not correct\"\nassert sha1(str(answer1_7).encode(\"utf-8\")+b\"c4b77\").hexdigest() == \"e7041b0f0cc00781dddf503ef1693bd99029eedf\", \"correct string value of answer1_7 but incorrect case of letters\"\n\nprint('Success!')\n\nGiven that the linear regression model is a straight line, we can write our model as a mathematical equation. We can get the two numbers we need for this from the coef_ and intercept_ attributes from lm_fit.\n\n# run this cell\nprint(f\"The coefficient for the linear regression is {lm_fit.coef_[0]:0.3f}.\")\nprint(f\"The intercept for the linear regression is {lm_fit.intercept_:0.3f}.\")\n\nQuestion 1.8.1  {points: 1}\nWhich of the following mathematical equations represents the model based on the numbers output in the cell above?\nA. \\(Predicted \\ race \\ time \\ (in \\ hours) = 4.851 - 0.022  \\times max \\ (in \\ miles)\\)\nB. \\(Predicted \\ race \\ time \\ (in \\ hours) = -0.022 + 4.851 \\times max \\ (in \\ miles)\\)\nC. \\(Predicted \\ max \\ (in \\ miles) = 4.851 - 0.022 \\times  \\ race \\ time \\ (in \\ hours)\\)\nD. \\(Predicted \\ max \\ (in \\ miles) = -0.022 + 4.851 \\times  \\ race \\ time \\ (in \\ hours)\\)\nSave the letter of your answer to a variable named answer1_8_1. Make sure you put quotations around the letter and pay attention to case.\n\n# your code here\nraise NotImplementedError\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer1_8_1)).encode(\"utf-8\")+b\"5b6e9\").hexdigest() == \"c1e898538331c6feb698ad544c8e708eb101f335\", \"type of answer3_8_1 is not str. answer3_8_1 should be an str\"\nassert sha1(str(len(answer1_8_1)).encode(\"utf-8\")+b\"5b6e9\").hexdigest() == \"4f4756a152ba2c274ee3b194dbe295ac57e849ac\", \"length of answer3_8_1 is not correct\"\nassert sha1(str(answer1_8_1.lower()).encode(\"utf-8\")+b\"5b6e9\").hexdigest() == \"11099d2bab2f6a29a949f290697d5e5906cece6b\", \"value of answer3_8_1 is not correct\"\nassert sha1(str(answer1_8_1).encode(\"utf-8\")+b\"5b6e9\").hexdigest() == \"8a5fd0b1b4b71ea33d160ad2d610f6af5c67f963\", \"correct string value of answer3_8_1 but incorrect case of letters\"\n\nprint('Success!')"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_regression1-optional/py_worksheet_regression1.html",
    "href": "materials/worksheets/py_worksheet_regression1-optional/py_worksheet_regression1.html",
    "title": "Worksheet 8 - Regression I (OPTIONAL)",
    "section": "",
    "text": "After completing this week‚Äôs lecture and tutorial work, you will be able to: - Recognize situations where a simple regression analysis would be appropriate for making predictions. - Explain the k-nearest neighbour (\\(k\\)-nn) regression algorithm and describe how it differs from \\(k\\)-nn classification. - Interpret the output of a \\(k\\)-nn regression. - In a dataset with two variables, perform k-nearest neighbour regression in Python using scikit-learn to predict the values for a test dataset. - Using Python, execute hyperparameter tuning in Python to choose the number of neighbours. - Using Python, evaluate \\(k\\)-nn regression prediction accuracy using a test data set and an appropriate metric (root mean squared error). - In the context of \\(k\\)-nn regression, compare and contrast goodness of fit and prediction properties (RMSE versus RMSPE). - Describe advantages and disadvantages of the \\(k\\)-nearest neighbour regression approach.\nThis tutorial covers parts of Chapter 7 of the online textbook. You should read this chapter before attempting this assignment. Any place you see ___, you must fill in the function, variable, or data to complete the code. Substitute the raise NotImplementedError with your completed code and answers then proceed to run the cell.\n\n### Run this cell before continuing.\nimport altair as alt\nimport numpy as np\nimport pandas as pd\nfrom sklearn import set_config\nfrom sklearn.model_selection import GridSearchCV, cross_validate, train_test_split\nfrom sklearn.neighbors import KNeighborsRegressor\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import mean_squared_error\n\n# Simplify working with large datasets in Altair\nalt.data_transformers.disable_max_rows()\n\n# Output dataframes instead of arrays\nset_config(transform_output=\"pandas\")\n\nQuestion 0.0  {points: 1}\nTo predict a value of \\(Y\\) for a new observation using \\(k\\)-nn regression, we identify the \\(k\\)-nearest neighbours and then:\nA. Assign it the median of the \\(k\\)-nearest neighbours as the predicted value\nB. Assign it the mean of the \\(k\\)-nearest neighbours as the predicted value\nC. Assign it the mode of the \\(k\\)-nearest neighbours as the predicted value\nD. Assign it the majority vote of the \\(k\\)-nearest neighbours as the predicted value\nSave the letter of the answer you think is correct to a variable named answer0_0. Make sure your answer is an uppercase letter and is surrounded by quotation marks (e.g.¬†\"F\").\n\n# your code here\nraise NotImplementedError\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer0_0)).encode(\"utf-8\")+b\"dcefd\").hexdigest() == \"3e545b3f6befc9fb348e77db7f2040e82e9bcbb7\", \"type of answer0_0 is not str. answer0_0 should be an str\"\nassert sha1(str(len(answer0_0)).encode(\"utf-8\")+b\"dcefd\").hexdigest() == \"107f1edd22c2860f5c219827900a4ddae78b3686\", \"length of answer0_0 is not correct\"\nassert sha1(str(answer0_0.lower()).encode(\"utf-8\")+b\"dcefd\").hexdigest() == \"d18bedfe24fae0dd4438932704ba3bd5d6bd4f7d\", \"value of answer0_0 is not correct\"\nassert sha1(str(answer0_0).encode(\"utf-8\")+b\"dcefd\").hexdigest() == \"0216e5aab479cd7c4e52506d6e7a964513305bd0\", \"correct string value of answer0_0 but incorrect case of letters\"\n\nprint('Success!')"
  },
  {
    "objectID": "materials/worksheets/py_worksheet_regression1-optional/py_worksheet_regression1.html#marathon-training",
    "href": "materials/worksheets/py_worksheet_regression1-optional/py_worksheet_regression1.html#marathon-training",
    "title": "Worksheet 8 - Regression I (OPTIONAL)",
    "section": "Marathon Training",
    "text": "Marathon Training\n\nSource: https://media.giphy.com/media/nUN6InE2CodRm/giphy.gif\nWhat predicts which athletes will perform better than others? Specifically, we are interested in marathon runners, and looking at how the maximum distance ran per week (in miles) during race training predicts the time it takes a runner to finish the race. For this, we will be looking at the marathon.csv file in the data/ folder.\nQuestion 1.0  {points: 1}\nLoad the data and assign it to an object called marathon.\n\n# your code here\nraise NotImplementedError\nmarathon\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon is None)).encode(\"utf-8\")+b\"30457\").hexdigest() == \"26d5aef6e71dd1f2188f7132ba3c7c26c732d4db\", \"type of marathon is None is not bool. marathon is None should be a bool\"\nassert sha1(str(marathon is None).encode(\"utf-8\")+b\"30457\").hexdigest() == \"598dc6a0d372aa6b4fab47451f4061e3c8d8d3ee\", \"boolean value of marathon is None is not correct\"\n\nassert sha1(str(type(marathon)).encode(\"utf-8\")+b\"30458\").hexdigest() == \"81b9d38b9594935ea28437a78a119c664b8e271a\", \"type of type(marathon) is not correct\"\n\nassert sha1(str(type(marathon.shape)).encode(\"utf-8\")+b\"30459\").hexdigest() == \"fc9069c39d96d09c086a2b82cb34971a576bcec5\", \"type of marathon.shape is not tuple. marathon.shape should be a tuple\"\nassert sha1(str(len(marathon.shape)).encode(\"utf-8\")+b\"30459\").hexdigest() == \"619cbada2e7f2f961d90ed765b5d118334e79c30\", \"length of marathon.shape is not correct\"\nassert sha1(str(sorted(map(str, marathon.shape))).encode(\"utf-8\")+b\"30459\").hexdigest() == \"efe8921e7ce06759f11980cddc7ae55db277e49c\", \"values of marathon.shape are not correct\"\nassert sha1(str(marathon.shape).encode(\"utf-8\")+b\"30459\").hexdigest() == \"e3f7896715d8c8a8f7ada1fd2c5213c678367660\", \"order of elements of marathon.shape is not correct\"\n\nassert sha1(str(type(\"time_hrs\" in marathon.columns)).encode(\"utf-8\")+b\"3045a\").hexdigest() == \"3a3de902ed3e89879d57fc4eff706e656659352b\", \"type of \\\"time_hrs\\\" in marathon.columns is not bool. \\\"time_hrs\\\" in marathon.columns should be a bool\"\nassert sha1(str(\"time_hrs\" in marathon.columns).encode(\"utf-8\")+b\"3045a\").hexdigest() == \"f7e1f0c320e623dd359e1bd60d7a2017c4aef608\", \"boolean value of \\\"time_hrs\\\" in marathon.columns is not correct\"\n\nassert sha1(str(type(\"max\" in marathon.columns)).encode(\"utf-8\")+b\"3045b\").hexdigest() == \"dcbf21f70e6bbc9a4f84d3f0c06f12d13aafa0ac\", \"type of \\\"max\\\" in marathon.columns is not bool. \\\"max\\\" in marathon.columns should be a bool\"\nassert sha1(str(\"max\" in marathon.columns).encode(\"utf-8\")+b\"3045b\").hexdigest() == \"24b9f6b32bda0c76fd2aab9ff718c8c441f6a57b\", \"boolean value of \\\"max\\\" in marathon.columns is not correct\"\n\nprint('Success!')\n\nQuestion 2.0  {points: 1}\nWe want to predict race time (in hours) (time_hrs) given a particular value of maximum distance ran per week (in miles) during race training (max). Let‚Äôs take a subset of size 50 individuals of our marathon data and assign it to an object called marathon_50. With this subset, plot a scatterplot (using mark_circle) to assess the relationship between these two variables. Put time_hrs on the y-axis and max on the x-axis. Discuss, with a classmate, the relationship between race time and maximum distance ran per week during training based on the scatterplot you create below.\nHint: To take a subset of your data you can use the sample function\nAssign your plot to an object called answer2.\n\n# ___ = ___.sample(___, random_state=300) # Do not change the random_state\n\n\nanswer2 = alt.Chart(marathon_50).mark_circle().encode(\n    x=alt.X(\"max\").title(\"Max Distance Ran per Week During Training (miles)\"),\n    y=alt.Y(\"time_hrs\")\n        .title(\"Race Time (hours)\")\n        .scale(zero=False)\n)\n\nanswer2\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer2 is None)).encode(\"utf-8\")+b\"9767\").hexdigest() == \"c9f213a0f76bf1899a7c7ab41bd64020e00a5d8a\", \"type of answer2 is None is not bool. answer2 is None should be a bool\"\nassert sha1(str(answer2 is None).encode(\"utf-8\")+b\"9767\").hexdigest() == \"07c6d302a12aea10f94ce4ac438ed8846da04ee4\", \"boolean value of answer2 is None is not correct\"\n\nassert sha1(str(type(marathon_50.shape)).encode(\"utf-8\")+b\"9768\").hexdigest() == \"1dc6a7e0dc1faf456fc0a56183f1a383ab13ea95\", \"type of marathon_50.shape is not tuple. marathon_50.shape should be a tuple\"\nassert sha1(str(len(marathon_50.shape)).encode(\"utf-8\")+b\"9768\").hexdigest() == \"2211b0a1f1461259f232290064bd4f32d781712d\", \"length of marathon_50.shape is not correct\"\nassert sha1(str(sorted(map(str, marathon_50.shape))).encode(\"utf-8\")+b\"9768\").hexdigest() == \"2102806f043d7c36dcd6b39270f2bc3bf06645c2\", \"values of marathon_50.shape are not correct\"\nassert sha1(str(marathon_50.shape).encode(\"utf-8\")+b\"9768\").hexdigest() == \"38fe5c44247a3db3a62933578c3250c807ac8a1c\", \"order of elements of marathon_50.shape is not correct\"\n\nassert sha1(str(type(answer2.data.equals(marathon_50))).encode(\"utf-8\")+b\"9769\").hexdigest() == \"4cf4607212e9a4c28c631904ff116572eab419e5\", \"type of answer2.data.equals(marathon_50) is not bool. answer2.data.equals(marathon_50) should be a bool\"\nassert sha1(str(answer2.data.equals(marathon_50)).encode(\"utf-8\")+b\"9769\").hexdigest() == \"bbab45c34d4ff267cf8e57a05d36d09aa94cc953\", \"boolean value of answer2.data.equals(marathon_50) is not correct\"\n\nassert sha1(str(type(answer2.encoding.x['shorthand'])).encode(\"utf-8\")+b\"976a\").hexdigest() == \"839b1f6e497ebbed31fb8df0322b128a7b581e7b\", \"type of answer2.encoding.x['shorthand'] is not str. answer2.encoding.x['shorthand'] should be an str\"\nassert sha1(str(len(answer2.encoding.x['shorthand'])).encode(\"utf-8\")+b\"976a\").hexdigest() == \"bbd3ee6c2cefcc8f64a4b15489f070e4e7360127\", \"length of answer2.encoding.x['shorthand'] is not correct\"\nassert sha1(str(answer2.encoding.x['shorthand'].lower()).encode(\"utf-8\")+b\"976a\").hexdigest() == \"5488fa8c72460ec31da324fd60582d6a75e894ac\", \"value of answer2.encoding.x['shorthand'] is not correct\"\nassert sha1(str(answer2.encoding.x['shorthand']).encode(\"utf-8\")+b\"976a\").hexdigest() == \"5488fa8c72460ec31da324fd60582d6a75e894ac\", \"correct string value of answer2.encoding.x['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(answer2.encoding.y['shorthand'])).encode(\"utf-8\")+b\"976b\").hexdigest() == \"ad11bd6cff76d9856350485bf290e058bf89f9e0\", \"type of answer2.encoding.y['shorthand'] is not str. answer2.encoding.y['shorthand'] should be an str\"\nassert sha1(str(len(answer2.encoding.y['shorthand'])).encode(\"utf-8\")+b\"976b\").hexdigest() == \"7e31068cc71027470db684645a245618ecc12f0b\", \"length of answer2.encoding.y['shorthand'] is not correct\"\nassert sha1(str(answer2.encoding.y['shorthand'].lower()).encode(\"utf-8\")+b\"976b\").hexdigest() == \"afd8e5f4040c0e6a927a56dd3222c5cb14c29b23\", \"value of answer2.encoding.y['shorthand'] is not correct\"\nassert sha1(str(answer2.encoding.y['shorthand']).encode(\"utf-8\")+b\"976b\").hexdigest() == \"afd8e5f4040c0e6a927a56dd3222c5cb14c29b23\", \"correct string value of answer2.encoding.y['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(answer2.mark)).encode(\"utf-8\")+b\"976c\").hexdigest() == \"3623b4c339e9c6ee9fdc6fad96976a7d1a2d9557\", \"type of answer2.mark is not str. answer2.mark should be an str\"\nassert sha1(str(len(answer2.mark)).encode(\"utf-8\")+b\"976c\").hexdigest() == \"77446053854ce07f9a468e3c4253ee227343be8c\", \"length of answer2.mark is not correct\"\nassert sha1(str(answer2.mark.lower()).encode(\"utf-8\")+b\"976c\").hexdigest() == \"5b87400edb7ee707ab95967718e9b221d24e92e2\", \"value of answer2.mark is not correct\"\nassert sha1(str(answer2.mark).encode(\"utf-8\")+b\"976c\").hexdigest() == \"5b87400edb7ee707ab95967718e9b221d24e92e2\", \"correct string value of answer2.mark but incorrect case of letters\"\n\nassert sha1(str(type(isinstance(answer2.encoding.x['title'], str))).encode(\"utf-8\")+b\"976d\").hexdigest() == \"851319552403a87bee34ca83d924c7a895eb0db0\", \"type of isinstance(answer2.encoding.x['title'], str) is not bool. isinstance(answer2.encoding.x['title'], str) should be a bool\"\nassert sha1(str(isinstance(answer2.encoding.x['title'], str)).encode(\"utf-8\")+b\"976d\").hexdigest() == \"e82182bc48c146515fd8a30abc08ff860fa54ee5\", \"boolean value of isinstance(answer2.encoding.x['title'], str) is not correct\"\n\nassert sha1(str(type(isinstance(answer2.encoding.y['title'], str))).encode(\"utf-8\")+b\"976e\").hexdigest() == \"265762b7f33189b160c25ee74148700738439490\", \"type of isinstance(answer2.encoding.y['title'], str) is not bool. isinstance(answer2.encoding.y['title'], str) should be a bool\"\nassert sha1(str(isinstance(answer2.encoding.y['title'], str)).encode(\"utf-8\")+b\"976e\").hexdigest() == \"8bb5960c415644b45508b0818b1eda7297426e4f\", \"boolean value of isinstance(answer2.encoding.y['title'], str) is not correct\"\n\nprint('Success!')\n\nQuestion 3.0  {points: 1}\nSuppose we want to predict the race time for someone who ran a maximum distance of 100 miles per week during training. In the chart we created in the previous question, we can see that no one has run a maximum distance of exactly 100 miles per week. How can we predict with this data? We can use \\(k\\)-nn regression! To do this we get the \\(Y\\) values (target/response variable) of the nearest \\(k\\) values and then take their average and use that as the prediction.\nFor this question perform \\(k\\)-nn regression manually to predict the race time based on the average value of the 4 runners (‚Äúneighbors‚Äù) closest to running 100 miles per week during training.\nFill in the scaffolding below and assign your answer to an object named answer3.\n\n# Run this cell to see a visualization of the 4 nearest neighbours to 100 miles / week\n\nrule = alt.Chart().mark_rule().encode(x=alt.datum(100))\n\nlines = alt.Chart(\n    pd.DataFrame({\n        \"x\": [110, 104, 90, 86],\n        \"y\": [2.63, 2.8, 3.27, 2.44]\n    })\n).mark_line(color=\"orange\", size=2).encode(\n    x=\"x\",\n    x2=alt.datum(100),  # we use `x2` to set a constant second x-coordinate at 100 for all the lines\n    y=\"y\",\n)\n\nlines + rule + answer2\n\n\n# ___ = (\n#     marathon_50\n#     .___(diff=(100 - ___).abs())  # Compute the absolute distance to 100 miles for each runner\n#     .___(4, ___)\n#     [___]\n#     .mean()\n# )\n\n# your code here\nraise NotImplementedError\nanswer3\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer3)).encode(\"utf-8\")+b\"7bdb3\").hexdigest() == \"3a71bdfd3d857a0c621cb9c0eca46cd2d17f7a25\", \"type of answer3 is not correct\"\nassert sha1(str(answer3).encode(\"utf-8\")+b\"7bdb3\").hexdigest() == \"37f5342ce74ffaa4f9a707df207bb80d2cfefc4f\", \"value of answer3 is not correct\"\n\nprint('Success!')\n\nQuestion 4.0  {points: 1}\nFor this question, let‚Äôs instead predict the race time based on the 2 closest neighbors to the 100 miles per week during training.\nAssign your answer to an object named answer4.\n\n# your code here\nraise NotImplementedError\nanswer4\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer4)).encode(\"utf-8\")+b\"91a96\").hexdigest() == \"56be2360e19074080ea1ee864973930e01b1feb8\", \"type of answer4 is not correct\"\nassert sha1(str(answer4).encode(\"utf-8\")+b\"91a96\").hexdigest() == \"d87f739886a2763fa87919ecfd5616a4cc832881\", \"value of answer4 is not correct\"\n\nprint('Success!')\n\nQuestion 5.0  {points: 1}\nSo far you have calculated the \\(k\\) nearest neighbors predictions manually based on values of \\(k\\) we have told you to use. However, last week we learned how to use a better method to choose the best \\(k\\) for classification.\nBased on what you learned last week and what you have learned about \\(k\\)-nn regression so far this week, which method would you use to choose the \\(k\\) (in the situation where we don‚Äôt tell you which \\(k\\) to use)?\n\n\nChoose the \\(k\\) that excludes most outliers\n\n\nChoose the \\(k\\) with the lowest training error\n\n\nChoose the \\(k\\) with the lowest cross-validation error\n\n\nChoose the \\(k\\) that includes the most data points\n\n\nChoose the \\(k\\) with the lowest testing error\n\n\nAssign your answer to an object called answer5. Make sure your answer is an uppercase letter and is surrounded by quotation marks (e.g.¬†\"F\").\n\n# your code here\nraise NotImplementedError\nanswer5\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer5)).encode(\"utf-8\")+b\"37693\").hexdigest() == \"90111e24734de91c15169da5902a3788de0a8444\", \"type of answer5 is not str. answer5 should be an str\"\nassert sha1(str(len(answer5)).encode(\"utf-8\")+b\"37693\").hexdigest() == \"fd218df3c1aeccee91b16c5edb3164742b012b62\", \"length of answer5 is not correct\"\nassert sha1(str(answer5.lower()).encode(\"utf-8\")+b\"37693\").hexdigest() == \"4f99d9a8de2f5a0e124277c1be1e248dce2816c2\", \"value of answer5 is not correct\"\nassert sha1(str(answer5).encode(\"utf-8\")+b\"37693\").hexdigest() == \"57eb3673a1f7ddb554643fa32e78e43ee5424edb\", \"correct string value of answer5 but incorrect case of letters\"\n\nprint('Success!')\n\nQuestion 6.0  {points: 1}\nWe have just seen how to perform k-nn regression manually, now we will apply it to the whole dataset using the scikit-learn package. To do so, we will first need to create the training and test datasets. Split the data to use 75% as your training set. Store the training data as marathon_training and the test set as marathon_testing. Remember we won‚Äôt touch the test dataset until the end.\nNext, set the time_hrs column as the target (y) and max column as the input feature (X). Store the features as X_train and X_test and targets as y_train and y_test respectively for the marathon_training and marathon_testing. Remember that it is easier to work with input features as a data frame rather than a series, so make sure to extract the single input feature as a data frame by passing the column name inside a list.\nAssign your answers to objects named marathon_training, marathon_testing, X_train, y_train, X_test, and y_test.\n\n# ___, ___ = train_test_split(\n#     ___,\n#     test_size=___,\n#     random_state=2000,  # Do not change the random_state\n# )\n# X_train = ___[___]  # A single column data frame\n# y_train = ___[___]  # A series\n\n# X_test = ___[___]  # A single column data frame\n# y_test = ___[___]  # A series\n\n# your code here\nraise NotImplementedError\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon_training is None)).encode(\"utf-8\")+b\"e7ecd\").hexdigest() == \"23389e9a6137f9af868ed3d5dcb5563fa02cf9ee\", \"type of marathon_training is None is not bool. marathon_training is None should be a bool\"\nassert sha1(str(marathon_training is None).encode(\"utf-8\")+b\"e7ecd\").hexdigest() == \"a85ea51e13d13be27411312c98c5d8d08427748f\", \"boolean value of marathon_training is None is not correct\"\n\nassert sha1(str(type(marathon_training.shape)).encode(\"utf-8\")+b\"e7ece\").hexdigest() == \"5c9a6007e66cd4aeb4e09f7e1fbad9430720c874\", \"type of marathon_training.shape is not tuple. marathon_training.shape should be a tuple\"\nassert sha1(str(len(marathon_training.shape)).encode(\"utf-8\")+b\"e7ece\").hexdigest() == \"4371251b32814c5ec901659b3f7243b8f06201eb\", \"length of marathon_training.shape is not correct\"\nassert sha1(str(sorted(map(str, marathon_training.shape))).encode(\"utf-8\")+b\"e7ece\").hexdigest() == \"8c5dccfad110d40e6e2dd0939e314507b72c82ba\", \"values of marathon_training.shape are not correct\"\nassert sha1(str(marathon_training.shape).encode(\"utf-8\")+b\"e7ece\").hexdigest() == \"79b9d73983831ec1ad4b9a030e13f40e5e631303\", \"order of elements of marathon_training.shape is not correct\"\n\nassert sha1(str(type(sum(marathon_training.age))).encode(\"utf-8\")+b\"e7ecf\").hexdigest() == \"6dd9106e51faadb152c13f46748de9b7631041f4\", \"type of sum(marathon_training.age) is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(sum(marathon_training.age)).encode(\"utf-8\")+b\"e7ecf\").hexdigest() == \"2e875c992a00e64a049679c247546552107e4806\", \"value of sum(marathon_training.age) is not correct\"\n\nassert sha1(str(type(marathon_testing is None)).encode(\"utf-8\")+b\"e7ed0\").hexdigest() == \"eeab11eee8b5ac43daead049c08370a1d6bd29e1\", \"type of marathon_testing is None is not bool. marathon_testing is None should be a bool\"\nassert sha1(str(marathon_testing is None).encode(\"utf-8\")+b\"e7ed0\").hexdigest() == \"45fc996440f56862fa729a598efb3e94ad2cbcba\", \"boolean value of marathon_testing is None is not correct\"\n\nassert sha1(str(type(marathon_testing.shape)).encode(\"utf-8\")+b\"e7ed1\").hexdigest() == \"580e794a2ad10c9c374bc994cb416f4825c1abc2\", \"type of marathon_testing.shape is not tuple. marathon_testing.shape should be a tuple\"\nassert sha1(str(len(marathon_testing.shape)).encode(\"utf-8\")+b\"e7ed1\").hexdigest() == \"0cfe48ec1593a68181d07cf5f9f1868014b33c5f\", \"length of marathon_testing.shape is not correct\"\nassert sha1(str(sorted(map(str, marathon_testing.shape))).encode(\"utf-8\")+b\"e7ed1\").hexdigest() == \"cce555187808a48e1408af0bb536e79e8a2225a5\", \"values of marathon_testing.shape are not correct\"\nassert sha1(str(marathon_testing.shape).encode(\"utf-8\")+b\"e7ed1\").hexdigest() == \"fbf8329576ea0be968fbabcd4c5dd25a6d17c93a\", \"order of elements of marathon_testing.shape is not correct\"\n\nassert sha1(str(type(sum(marathon_testing.age))).encode(\"utf-8\")+b\"e7ed2\").hexdigest() == \"3d8e616c9608ebb5fa199e74614b680d59572017\", \"type of sum(marathon_testing.age) is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(sum(marathon_testing.age)).encode(\"utf-8\")+b\"e7ed2\").hexdigest() == \"a666611338ec9b1d7c1df5146282bf710f1d54f6\", \"value of sum(marathon_testing.age) is not correct\"\n\nassert sha1(str(type(X_train.columns.values)).encode(\"utf-8\")+b\"e7ed3\").hexdigest() == \"d2af8b1f3ac36ff6af2a760a8b5cfa0388a5a272\", \"type of X_train.columns.values is not correct\"\nassert sha1(str(X_train.columns.values).encode(\"utf-8\")+b\"e7ed3\").hexdigest() == \"17be56c6e47e3d10712619e99b61a6d767fd5666\", \"value of X_train.columns.values is not correct\"\n\nassert sha1(str(type(X_train.shape)).encode(\"utf-8\")+b\"e7ed4\").hexdigest() == \"414b7eb138475c852d35f49fc6d280cb0f9a2a9f\", \"type of X_train.shape is not tuple. X_train.shape should be a tuple\"\nassert sha1(str(len(X_train.shape)).encode(\"utf-8\")+b\"e7ed4\").hexdigest() == \"73a0b26b8110b3197945c70b0650286285cec8d3\", \"length of X_train.shape is not correct\"\nassert sha1(str(sorted(map(str, X_train.shape))).encode(\"utf-8\")+b\"e7ed4\").hexdigest() == \"d74001495311d9550e27e96f7c560f5ed899dc2a\", \"values of X_train.shape are not correct\"\nassert sha1(str(X_train.shape).encode(\"utf-8\")+b\"e7ed4\").hexdigest() == \"f434b7539cfe664a9765b7bbb07e4709fc2491da\", \"order of elements of X_train.shape is not correct\"\n\nassert sha1(str(type(y_train.name)).encode(\"utf-8\")+b\"e7ed5\").hexdigest() == \"07fb7ee407cccab8c19809282e20aecb7bb62185\", \"type of y_train.name is not str. y_train.name should be an str\"\nassert sha1(str(len(y_train.name)).encode(\"utf-8\")+b\"e7ed5\").hexdigest() == \"c159bd913e413006f4be6da2dfb303dd974e4bbb\", \"length of y_train.name is not correct\"\nassert sha1(str(y_train.name.lower()).encode(\"utf-8\")+b\"e7ed5\").hexdigest() == \"a622136689ba01beab477abec3b4b37aa5e2f515\", \"value of y_train.name is not correct\"\nassert sha1(str(y_train.name).encode(\"utf-8\")+b\"e7ed5\").hexdigest() == \"a622136689ba01beab477abec3b4b37aa5e2f515\", \"correct string value of y_train.name but incorrect case of letters\"\n\nassert sha1(str(type(y_train.shape)).encode(\"utf-8\")+b\"e7ed6\").hexdigest() == \"22627a8f279315114f3a5f91de95da0d83389d79\", \"type of y_train.shape is not tuple. y_train.shape should be a tuple\"\nassert sha1(str(len(y_train.shape)).encode(\"utf-8\")+b\"e7ed6\").hexdigest() == \"c61d6dd0518678d74f5f69117e206324490517c6\", \"length of y_train.shape is not correct\"\nassert sha1(str(sorted(map(str, y_train.shape))).encode(\"utf-8\")+b\"e7ed6\").hexdigest() == \"775174c861c6ab54c4c08abf24b2bfebdb30af3f\", \"values of y_train.shape are not correct\"\nassert sha1(str(y_train.shape).encode(\"utf-8\")+b\"e7ed6\").hexdigest() == \"cead78c49de35c73a190c737d2bb46ff4e2fec23\", \"order of elements of y_train.shape is not correct\"\n\nassert sha1(str(type(X_test.columns.values)).encode(\"utf-8\")+b\"e7ed7\").hexdigest() == \"22fe9ec90a423d6060f49aa6d7a76ce3d3974080\", \"type of X_test.columns.values is not correct\"\nassert sha1(str(X_test.columns.values).encode(\"utf-8\")+b\"e7ed7\").hexdigest() == \"7754708b959b4274773a259f79fd376b28310eac\", \"value of X_test.columns.values is not correct\"\n\nassert sha1(str(type(X_test.shape)).encode(\"utf-8\")+b\"e7ed8\").hexdigest() == \"f0858d2513b6eee63f326fcebe57b013cd31df36\", \"type of X_test.shape is not tuple. X_test.shape should be a tuple\"\nassert sha1(str(len(X_test.shape)).encode(\"utf-8\")+b\"e7ed8\").hexdigest() == \"bd7fc6f3096017ac86fb06841d97ddd854492ed0\", \"length of X_test.shape is not correct\"\nassert sha1(str(sorted(map(str, X_test.shape))).encode(\"utf-8\")+b\"e7ed8\").hexdigest() == \"ef154c5dedbd48b6b6a3232c68a2fea5c9f7be4b\", \"values of X_test.shape are not correct\"\nassert sha1(str(X_test.shape).encode(\"utf-8\")+b\"e7ed8\").hexdigest() == \"3a6cfb0fce7e27384ffd615b58fb5cbd20a3d82b\", \"order of elements of X_test.shape is not correct\"\n\nassert sha1(str(type(y_test.name)).encode(\"utf-8\")+b\"e7ed9\").hexdigest() == \"72df4c655d030df71555b431f22397a7e42c0e38\", \"type of y_test.name is not str. y_test.name should be an str\"\nassert sha1(str(len(y_test.name)).encode(\"utf-8\")+b\"e7ed9\").hexdigest() == \"f164546779f465e2b62365d3ab3737c47eebf4d6\", \"length of y_test.name is not correct\"\nassert sha1(str(y_test.name.lower()).encode(\"utf-8\")+b\"e7ed9\").hexdigest() == \"3327e8ccb2ac8ed8cf1dad70018d6f95c820d712\", \"value of y_test.name is not correct\"\nassert sha1(str(y_test.name).encode(\"utf-8\")+b\"e7ed9\").hexdigest() == \"3327e8ccb2ac8ed8cf1dad70018d6f95c820d712\", \"correct string value of y_test.name but incorrect case of letters\"\n\nassert sha1(str(type(y_test.shape)).encode(\"utf-8\")+b\"e7eda\").hexdigest() == \"3caf58a1ec02a722090ad103cb12c17948c05ea8\", \"type of y_test.shape is not tuple. y_test.shape should be a tuple\"\nassert sha1(str(len(y_test.shape)).encode(\"utf-8\")+b\"e7eda\").hexdigest() == \"6bee5d9b7be7422e0080aec785993d4b1645979b\", \"length of y_test.shape is not correct\"\nassert sha1(str(sorted(map(str, y_test.shape))).encode(\"utf-8\")+b\"e7eda\").hexdigest() == \"b4518ece20f13e8647767347afffe9dbd285baf1\", \"values of y_test.shape are not correct\"\nassert sha1(str(y_test.shape).encode(\"utf-8\")+b\"e7eda\").hexdigest() == \"5ff9b39d3ce50b07b91aa77be609c2ec942f2dc3\", \"order of elements of y_test.shape is not correct\"\n\nprint('Success!')\n\nQuestion 7.0  {points: 1}\nNext, we‚Äôll use cross-validation on our training data to choose \\(k\\). In \\(k\\)-nn classification, we used accuracy to see how well our predictions matched the true labels. In the context of \\(k\\)-nn regression, we will use RMSPE as the scoring instead. Interpreting the RMSPE value can be tricky but generally speaking, if the prediction values are very close to the true values, the RMSPE will be small. Conversely, if the prediction values are not very close to the true values, the RMSPE will be quite large.\nLet‚Äôs perform a cross-validation and choose the optimal \\(k\\)!\nFirst, create a pipeline for \\(k\\)-nn.¬†We are still using the \\(k\\)-nearest neighbours algorithm, and we will also use the StandardScaler to standardize the numerical values. Store your pipeline in an object called marathon_pipe. Finally, perform a cross-validation with 5 folds using the cross_validate function. Remember that since the cross_validate function always maximizes its ‚Äúscore‚Äù, and here we‚Äôre using RMSPE (lower is better!), we need to specify that we‚Äôre using the negative RMSPE (\"neg_root_mean_squared_error\").\nStore the output of the cross validation as a data frame in an object called marathon_cv.\n\n# ___ = make_pipeline(\n#     ___,\n#     ___,\n# )\n#\n# marathon_cv = pd.___(\n#     cross_validate(\n#         ___,\n#         ___,\n#         ___,\n#         scoring=___,\n#         return_train_score=True,\n#     )\n# )\n\n# your code here\nraise NotImplementedError\nmarathon_cv\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon_pipe is None)).encode(\"utf-8\")+b\"8864c\").hexdigest() == \"25299b052f7ab2931046737631887a8cc568dbdc\", \"type of marathon_pipe is None is not bool. marathon_pipe is None should be a bool\"\nassert sha1(str(marathon_pipe is None).encode(\"utf-8\")+b\"8864c\").hexdigest() == \"e30f3e578a40c11694672cc29b9e8ed48e9b5b0a\", \"boolean value of marathon_pipe is None is not correct\"\n\nassert sha1(str(type(marathon_pipe.steps[1][1].n_neighbors)).encode(\"utf-8\")+b\"8864d\").hexdigest() == \"d547f76ed04d14a405bffd75b858fcadc01626b2\", \"type of marathon_pipe.steps[1][1].n_neighbors is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(marathon_pipe.steps[1][1].n_neighbors).encode(\"utf-8\")+b\"8864d\").hexdigest() == \"06ffe53eaaff553f1311c56f2367fab086ff823e\", \"value of marathon_pipe.steps[1][1].n_neighbors is not correct\"\n\nassert sha1(str(type(marathon_pipe.steps[1][1].weights)).encode(\"utf-8\")+b\"8864e\").hexdigest() == \"58751697270ec924b2f324e1b5544996472be14f\", \"type of marathon_pipe.steps[1][1].weights is not str. marathon_pipe.steps[1][1].weights should be an str\"\nassert sha1(str(len(marathon_pipe.steps[1][1].weights)).encode(\"utf-8\")+b\"8864e\").hexdigest() == \"6cd5d1937d5b4571f3f6a7a4880af49e992de8a5\", \"length of marathon_pipe.steps[1][1].weights is not correct\"\nassert sha1(str(marathon_pipe.steps[1][1].weights.lower()).encode(\"utf-8\")+b\"8864e\").hexdigest() == \"ab385b8efd1b981d6c0200273e19c124f3e24308\", \"value of marathon_pipe.steps[1][1].weights is not correct\"\nassert sha1(str(marathon_pipe.steps[1][1].weights).encode(\"utf-8\")+b\"8864e\").hexdigest() == \"ab385b8efd1b981d6c0200273e19c124f3e24308\", \"correct string value of marathon_pipe.steps[1][1].weights but incorrect case of letters\"\n\nassert sha1(str(type(marathon_pipe.steps[0][1])).encode(\"utf-8\")+b\"8864f\").hexdigest() == \"974eac74a0ad1ee3ad51d33c86e4f23b9caac296\", \"type of marathon_pipe.steps[0][1] is not correct\"\nassert sha1(str(marathon_pipe.steps[0][1]).encode(\"utf-8\")+b\"8864f\").hexdigest() == \"88499ff4e2ed2a47e400d341106fb5b49551ed08\", \"value of marathon_pipe.steps[0][1] is not correct\"\n\nassert sha1(str(type(marathon_cv is None)).encode(\"utf-8\")+b\"88650\").hexdigest() == \"82c0b965cf5966540442e3581313923f152295a1\", \"type of marathon_cv is None is not bool. marathon_cv is None should be a bool\"\nassert sha1(str(marathon_cv is None).encode(\"utf-8\")+b\"88650\").hexdigest() == \"e0832f10224a7c3b8fc8349d63cbcc366639d036\", \"boolean value of marathon_cv is None is not correct\"\n\nassert sha1(str(type(len(marathon_cv['train_score']))).encode(\"utf-8\")+b\"88651\").hexdigest() == \"2da35ca4faddbf2b4b47152b40d1fbb51614153a\", \"type of len(marathon_cv['train_score']) is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(len(marathon_cv['train_score'])).encode(\"utf-8\")+b\"88651\").hexdigest() == \"c03676f0aa4939eab9beb8cdd1e1ad156ceff2c0\", \"value of len(marathon_cv['train_score']) is not correct\"\n\nassert sha1(str(type(sum(marathon_cv['train_score']))).encode(\"utf-8\")+b\"88652\").hexdigest() == \"1f1dd6525f2a541022058c1c5c49ef08440be730\", \"type of sum(marathon_cv['train_score']) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(marathon_cv['train_score']), 2)).encode(\"utf-8\")+b\"88652\").hexdigest() == \"5839a4484a5996becf1142a0c824e072abf9ae74\", \"value of sum(marathon_cv['train_score']) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(sum(marathon_cv['test_score']))).encode(\"utf-8\")+b\"88653\").hexdigest() == \"b2d3d500fa919b6f72c5a9bfbac6ddf39984c89e\", \"type of sum(marathon_cv['test_score']) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(marathon_cv['test_score']), 2)).encode(\"utf-8\")+b\"88653\").hexdigest() == \"ceafaaed8afb31ab587e60437edb7aee28aed3e5\", \"value of sum(marathon_cv['test_score']) is not correct (rounded to 2 decimal places)\"\n\nprint('Success!')\n\nQuestion 8.0  {points: 1}\nThe major difference compared to other models from Chapters 6 and 7 is that we are running a regression rather than a classification. Using KNeighborsRegressor essentially tells scikit-learn that we need to use different metrics (neg_root_mean_squared_error rather than accuracy) for tuning and evaluation.\nNow, let‚Äôs use the neg_root_mean_squared_error to find the best setting for \\(k\\) from our model. Let‚Äôs test 200 values of \\(k\\).\nFirst, create a parameter grid called param_grid that contains values of range 1 to 200.\nNext, tune your model such that it tests all the values in range(1, 201, 1) using GridSearchCV function with cv=5 and n_jobs=-1 and save the tuned model as marathon_tuned. Finally, fit the tuned model to the training dataset and save the cv_results_ in a dataframe.\nAssign your answer to an object called marathon_results.\n\nnp.random.seed(2019) # DO NOT CHANGE\n\n# param_grid = _____\n# marathon_tuned = GridSearchCV(___, ___, ___, ___, ___)\n# marathon_results = pd.DataFrame(____.fit(____, ____).____)\n\n# your code here\nraise NotImplementedError\nmarathon_results\n\n\nfrom hashlib import sha1\nassert sha1(str(type(param_grid is None)).encode(\"utf-8\")+b\"d182e\").hexdigest() == \"ec7bcbea68f702395cdd5e67180936ae258a3f3c\", \"type of param_grid is None is not bool. param_grid is None should be a bool\"\nassert sha1(str(param_grid is None).encode(\"utf-8\")+b\"d182e\").hexdigest() == \"3cf3edd9eddd1b5c4500aa5b52869832b40083d9\", \"boolean value of param_grid is None is not correct\"\n\nassert sha1(str(type(param_grid)).encode(\"utf-8\")+b\"d182f\").hexdigest() == \"ace9aac86250e076a5706a6c94d179a856ffdd1e\", \"type of type(param_grid) is not correct\"\n\nassert sha1(str(type(\"kneighborsregressor__n_neighbors\" in param_grid)).encode(\"utf-8\")+b\"d1830\").hexdigest() == \"ff29e4faf0e45be91ef5484ace002565aebc17a8\", \"type of \\\"kneighborsregressor__n_neighbors\\\" in param_grid is not bool. \\\"kneighborsregressor__n_neighbors\\\" in param_grid should be a bool\"\nassert sha1(str(\"kneighborsregressor__n_neighbors\" in param_grid).encode(\"utf-8\")+b\"d1830\").hexdigest() == \"423cc17212d6b16b3a09484a00636ed40da12d0c\", \"boolean value of \\\"kneighborsregressor__n_neighbors\\\" in param_grid is not correct\"\n\nassert sha1(str(type(sum(i for i in param_grid['kneighborsregressor__n_neighbors']))).encode(\"utf-8\")+b\"d1831\").hexdigest() == \"e79769dca25d75ac1efdfd501a1a3e50a1248982\", \"type of sum(i for i in param_grid['kneighborsregressor__n_neighbors']) is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(sum(i for i in param_grid['kneighborsregressor__n_neighbors'])).encode(\"utf-8\")+b\"d1831\").hexdigest() == \"3062f138a1709066561977581ee37b9da7187b8b\", \"value of sum(i for i in param_grid['kneighborsregressor__n_neighbors']) is not correct\"\n\nassert sha1(str(type(marathon_tuned is None)).encode(\"utf-8\")+b\"d1832\").hexdigest() == \"9f763278e96c032f901645614bcc433e19b6da21\", \"type of marathon_tuned is None is not bool. marathon_tuned is None should be a bool\"\nassert sha1(str(marathon_tuned is None).encode(\"utf-8\")+b\"d1832\").hexdigest() == \"802f7ddda999c610b46d5eefeaad353b41db1f11\", \"boolean value of marathon_tuned is None is not correct\"\n\nassert sha1(str(type(marathon_tuned.n_splits_)).encode(\"utf-8\")+b\"d1833\").hexdigest() == \"4ae49a96c27611edbdc55e4b6a0acdb6a0f4e361\", \"type of marathon_tuned.n_splits_ is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(marathon_tuned.n_splits_).encode(\"utf-8\")+b\"d1833\").hexdigest() == \"03197f439ff046e0849de2e1ea68e5abf3a3227a\", \"value of marathon_tuned.n_splits_ is not correct\"\n\nassert sha1(str(type(marathon_tuned.estimator[0])).encode(\"utf-8\")+b\"d1834\").hexdigest() == \"d6e10402eebb0cf168b578048a88cb545603e32a\", \"type of marathon_tuned.estimator[0] is not correct\"\nassert sha1(str(marathon_tuned.estimator[0]).encode(\"utf-8\")+b\"d1834\").hexdigest() == \"f5465c5fbaa6f3239fc28a1ff25004895b6c5876\", \"value of marathon_tuned.estimator[0] is not correct\"\n\nassert sha1(str(type(marathon_tuned.estimator[1])).encode(\"utf-8\")+b\"d1835\").hexdigest() == \"16467dbeabfbbbb3e3f104b63615a61965d962b2\", \"type of marathon_tuned.estimator[1] is not correct\"\nassert sha1(str(marathon_tuned.estimator[1]).encode(\"utf-8\")+b\"d1835\").hexdigest() == \"bf022c71f2b7bd9757a0f4c333efd82fa9d5a235\", \"value of marathon_tuned.estimator[1] is not correct\"\n\nassert sha1(str(type(marathon_tuned.param_grid == param_grid)).encode(\"utf-8\")+b\"d1836\").hexdigest() == \"576f7dc516eea23c2e820127a7892ceea3d0dab5\", \"type of marathon_tuned.param_grid == param_grid is not bool. marathon_tuned.param_grid == param_grid should be a bool\"\nassert sha1(str(marathon_tuned.param_grid == param_grid).encode(\"utf-8\")+b\"d1836\").hexdigest() == \"681a7a81f3b2eb025a9461956a79a884370c9eed\", \"boolean value of marathon_tuned.param_grid == param_grid is not correct\"\n\nassert sha1(str(type(marathon_results is None)).encode(\"utf-8\")+b\"d1837\").hexdigest() == \"8689f96913286ecd30d823e848b7eb97d738c848\", \"type of marathon_results is None is not bool. marathon_results is None should be a bool\"\nassert sha1(str(marathon_results is None).encode(\"utf-8\")+b\"d1837\").hexdigest() == \"0d219c756c386807c0464fa0cee1b865a1200bac\", \"boolean value of marathon_results is None is not correct\"\n\nassert sha1(str(type(marathon_results)).encode(\"utf-8\")+b\"d1838\").hexdigest() == \"18ba9e44f8dde45008fd1011b189d83f547d79f3\", \"type of type(marathon_results) is not correct\"\n\nassert sha1(str(type(marathon_results.shape)).encode(\"utf-8\")+b\"d1839\").hexdigest() == \"21ab468813730121894ce75777b2e1fd48fdb5da\", \"type of marathon_results.shape is not tuple. marathon_results.shape should be a tuple\"\nassert sha1(str(len(marathon_results.shape)).encode(\"utf-8\")+b\"d1839\").hexdigest() == \"ad46a3a70676d9eb487222097e1246978dd107a0\", \"length of marathon_results.shape is not correct\"\nassert sha1(str(sorted(map(str, marathon_results.shape))).encode(\"utf-8\")+b\"d1839\").hexdigest() == \"702ab7880f169feb4a954839cfefe6ea051b42d1\", \"values of marathon_results.shape are not correct\"\nassert sha1(str(marathon_results.shape).encode(\"utf-8\")+b\"d1839\").hexdigest() == \"ac943869f441904a6bb3e649e3086382f6496051\", \"order of elements of marathon_results.shape is not correct\"\n\nassert sha1(str(type(sum(marathon_results.param_kneighborsregressor__n_neighbors))).encode(\"utf-8\")+b\"d183a\").hexdigest() == \"46aa9236ef14c7d42d2b7d92052c5c94af6cab15\", \"type of sum(marathon_results.param_kneighborsregressor__n_neighbors) is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(sum(marathon_results.param_kneighborsregressor__n_neighbors)).encode(\"utf-8\")+b\"d183a\").hexdigest() == \"61a6b58502c1d2d00fb7a6a65c20cae775b189ff\", \"value of sum(marathon_results.param_kneighborsregressor__n_neighbors) is not correct\"\n\nassert sha1(str(type(sum(marathon_results.mean_test_score))).encode(\"utf-8\")+b\"d183b\").hexdigest() == \"eb6784ad9e0df0d3b20b0857d501db1797afe75c\", \"type of sum(marathon_results.mean_test_score) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(marathon_results.mean_test_score), 2)).encode(\"utf-8\")+b\"d183b\").hexdigest() == \"5c2e32ca9aacc4f5726277288252ac363fcd924d\", \"value of sum(marathon_results.mean_test_score) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(sum(marathon_results.std_test_score))).encode(\"utf-8\")+b\"d183c\").hexdigest() == \"a4c7c7e034abaadcaf56057d19893a773dbf8fb1\", \"type of sum(marathon_results.std_test_score) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(marathon_results.std_test_score), 2)).encode(\"utf-8\")+b\"d183c\").hexdigest() == \"3000c4e4327bea85d84632c37db03bc1d008b2c0\", \"value of sum(marathon_results.std_test_score) is not correct (rounded to 2 decimal places)\"\n\nprint('Success!')\n\nQuestion 8.1  {points: 1}\nGreat! Now find the number of neighbors that will serve as our best \\(k\\) value by calling the best_params_ attribute of the model marathon_tuned. Your answer should simply be a dictionary with one key-value pair.\nAlso, find the score for the best model by calling the best_score_ attribute of the model marathon_tuned. Make sure to convert the negative RMSPE score we used for cross-validation into a positive RMSPE score for reporting by using a - sign.\nAssign your best parameters to an object called marathon_min, and assign your best RMSPE to an object called marathon_best_RMSPE.\n\n# ___ = ___.best_params_\n# ___ = -___.best_score_\n\n# your code here\nraise NotImplementedError\nmarathon_min\n\n\nmarathon_best_RMSPE\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon_min is None)).encode(\"utf-8\")+b\"9ae42\").hexdigest() == \"2feff5d755380f5a1f50804a0c4948d723261eda\", \"type of marathon_min is None is not bool. marathon_min is None should be a bool\"\nassert sha1(str(marathon_min is None).encode(\"utf-8\")+b\"9ae42\").hexdigest() == \"5015b9976a1f2e2f2fa109305796f1e1702ba164\", \"boolean value of marathon_min is None is not correct\"\n\nassert sha1(str(type(marathon_min)).encode(\"utf-8\")+b\"9ae43\").hexdigest() == \"b4658974ee290076b30642296bffc395bf445d21\", \"type of type(marathon_min) is not correct\"\n\nassert sha1(str(type(marathon_min)).encode(\"utf-8\")+b\"9ae44\").hexdigest() == \"3040f94c545ff413539332503528deab08084a62\", \"type of marathon_min is not dict. marathon_min should be a dict\"\nassert sha1(str(len(list(marathon_min.keys()))).encode(\"utf-8\")+b\"9ae44\").hexdigest() == \"84224507b5177db8e9c88f5abd8824ece22645b8\", \"number of keys of marathon_min is not correct\"\nassert sha1(str(sorted(map(str, marathon_min.keys()))).encode(\"utf-8\")+b\"9ae44\").hexdigest() == \"edf882d0536918e0a683172498fcad8c63f6af3c\", \"keys of marathon_min are not correct\"\nassert sha1(str(sorted(map(str, marathon_min.values()))).encode(\"utf-8\")+b\"9ae44\").hexdigest() == \"c3bca7dfbca0e41a87d4ff3e43c335504e37caeb\", \"correct keys, but values of marathon_min are not correct\"\nassert sha1(str(marathon_min).encode(\"utf-8\")+b\"9ae44\").hexdigest() == \"80961d32128e4ca9746e99318dd97c9ed04c317f\", \"correct keys and values, but incorrect correspondence in keys and values of marathon_min\"\n\nassert sha1(str(type(marathon_best_RMSPE is None)).encode(\"utf-8\")+b\"9ae45\").hexdigest() == \"487be9299591e548ea7dcedef4c4e650814148d2\", \"type of marathon_best_RMSPE is None is not bool. marathon_best_RMSPE is None should be a bool\"\nassert sha1(str(marathon_best_RMSPE is None).encode(\"utf-8\")+b\"9ae45\").hexdigest() == \"84ef8bfc80a388930431187a4d0640f62e727b78\", \"boolean value of marathon_best_RMSPE is None is not correct\"\n\nassert sha1(str(type(marathon_best_RMSPE)).encode(\"utf-8\")+b\"9ae46\").hexdigest() == \"78a416ab0e296d01fb1307a654bf9b70b1337868\", \"type of marathon_best_RMSPE is not correct\"\nassert sha1(str(marathon_best_RMSPE).encode(\"utf-8\")+b\"9ae46\").hexdigest() == \"8785f764d752095decf87a8dd24909d0016992f7\", \"value of marathon_best_RMSPE is not correct\"\n\nprint('Success!')\n\nQuestion 8.2  {points: 1}\nTo assess how well our model might do at predicting on unseen data, we will assess its RMSPE on the test data.\nWe will use the predict function to make predictions on the test data and store the predictions marathon_prediction. Remember that GridSearchCV automatically refits the model with the best found parameters, so you can use the predict method of the marathon_tuned variable for this step.\nFinally, we will compute the RMSPE on the test data using the mean_squared_error function. Don‚Äôt forget to take the square root to obtain the RMSPE!\nNote: scikit-learn also has a score function for the KNeighborsRegressor. The score function returns the coefficient of determination (often called \\(R^2\\)) of the fit, not the RMSPE.\nAssign your answer in an object called marathon_summary.\n\nnp.random.seed(1234) # DO NOT CHANGE\n\n# ___ = ___.___(___)\n# ___ = mean_squared_error(___, ___)**(1/2)\n\n\n# your code here\nraise NotImplementedError\nmarathon_summary\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon_prediction is None)).encode(\"utf-8\")+b\"5e675\").hexdigest() == \"e171ec8a4f6e825d47e43ba2c8d7e4962ff2f8b4\", \"type of marathon_prediction is None is not bool. marathon_prediction is None should be a bool\"\nassert sha1(str(marathon_prediction is None).encode(\"utf-8\")+b\"5e675\").hexdigest() == \"c76b30dacb294c54dc2932240aa7fa4c23543c56\", \"boolean value of marathon_prediction is None is not correct\"\n\nassert sha1(str(type(marathon_prediction)).encode(\"utf-8\")+b\"5e676\").hexdigest() == \"be3ffc123e07105d4089655588fb6d71383eb08d\", \"type of type(marathon_prediction) is not correct\"\n\nassert sha1(str(type(marathon_prediction.sum())).encode(\"utf-8\")+b\"5e677\").hexdigest() == \"d3da4b9915f115587058740bd3c406c49cbf5b2c\", \"type of marathon_prediction.sum() is not correct\"\nassert sha1(str(marathon_prediction.sum()).encode(\"utf-8\")+b\"5e677\").hexdigest() == \"8c10d2be9c82e2bdbdcd44f3fbb35f6c102d0119\", \"value of marathon_prediction.sum() is not correct\"\n\nassert sha1(str(type(marathon_summary is None)).encode(\"utf-8\")+b\"5e678\").hexdigest() == \"1581c288216e96bfb8d0fcc29cf60c18dd92909b\", \"type of marathon_summary is None is not bool. marathon_summary is None should be a bool\"\nassert sha1(str(marathon_summary is None).encode(\"utf-8\")+b\"5e678\").hexdigest() == \"6f8e105f98933eb6b68dbbb0f78058a8ac9dd80a\", \"boolean value of marathon_summary is None is not correct\"\n\nassert sha1(str(type(marathon_summary)).encode(\"utf-8\")+b\"5e679\").hexdigest() == \"ba12bad71525a497b68612abadf62fd2a05b9230\", \"type of marathon_summary is not correct\"\nassert sha1(str(marathon_summary).encode(\"utf-8\")+b\"5e679\").hexdigest() == \"ecbf8a32ee6fde067052e0cf254aaf3b674d001f\", \"value of marathon_summary is not correct\"\n\nprint('Success!')\n\nWhat does this RMSPE mean? RMSPE is measured in the units of the target/response variable, so it can sometimes be a bit hard to interpret. In this case, we have a helpful reference to compare against: we know that a typical marathon race time is somewhere between 3 - 5 hours. So this model allows us to predict a runner‚Äôs race time up to about +/-0.6 of an hour, or +/- 36 minutes. Relative the total race time, this margin of error is not fantastic, but not terrible either. We can certainly use the model to determine roughly whether an athlete will have a bad, good, or excellent race time, but probably cannot reliably distinguish between athletes of a similar caliber.\nFor now, let‚Äôs consider this approach to thinking about RMSPE from our testing data set: as long as it‚Äôs not significantly worse than the cross-validation RMSPE of our best model (Question 8.1), then we can say that we‚Äôre not doing too much worse on the test data than we did on the training data. In future courses on statistical/machine learning, you will learn more about how to interpret RMSPE from testing data and other ways to assess models.\nQuestion 8.3 {points: 1}\nThe RMSPE from our testing data set is much worse than the cross-validation RMSPE of our best model.\nAssign your answer to an object named answer8_3. Make sure your answer is either True or False.\n\n# your code here\nraise NotImplementedError\n\n\nfrom hashlib import sha1\nassert sha1(str(type(answer8_3)).encode(\"utf-8\")+b\"a3e08\").hexdigest() == \"b07290d0d5a5f7304386a6085d09604c57fe55d4\", \"type of answer8_3 is not bool. answer8_3 should be a bool\"\nassert sha1(str(answer8_3).encode(\"utf-8\")+b\"a3e08\").hexdigest() == \"0fd0dee1f68a3e7794645e623f2b2be2db15b5cf\", \"boolean value of answer8_3 is not correct\"\n\nprint('Success!')\n\nQuestion 9.0  {points: 1}\nLet‚Äôs visualize what the relationship between max and time_hrs looks like with our best \\(k\\) value to ultimately explore how the \\(k\\) value affects \\(k\\)-nn regression.\nTo do so, use the predict function on marathon_tuned to use the model with the best \\(K\\) value to create predictions for the marathon_training data. Then, add the column of predictions to the marathon_training data frame using the assign function. Name the resulting data frame marathon_preds and the new column predictions.\nNext, create a scatterplot with the marathon time (y-axis) against the maximum distance run per week (x-axis) from marathon_preds. Use mark_circle with an opacity of 0.4 to avoid overplotting. Assign your plot to a variable called marathon_plot. Plot the predictions as a black line over the data points. Remember the fundamentals of effective visualizations such as having a human-readable axes titles.\nAssign the data frame from the first part to a variable called marathon_preds, and the plot to a variable called marathon_plot.\n\nnp.random.seed(2019) # DO NOT CHANGE\n\n# marathon_preds = ____.assign(\n#     predictions= _____.predict(____)\n# )\n# marathon_plot = ___\n\n# your code here\nraise NotImplementedError\nmarathon_plot\n\n\nfrom hashlib import sha1\nassert sha1(str(type(marathon_preds is None)).encode(\"utf-8\")+b\"80ef7\").hexdigest() == \"feb8d8685b9e26c54c06aaf7f0f281aee880c614\", \"type of marathon_preds is None is not bool. marathon_preds is None should be a bool\"\nassert sha1(str(marathon_preds is None).encode(\"utf-8\")+b\"80ef7\").hexdigest() == \"bc57fae1eae5ffdeeeada5122d0bb66260bd0ac6\", \"boolean value of marathon_preds is None is not correct\"\n\nassert sha1(str(type(marathon_preds)).encode(\"utf-8\")+b\"80ef8\").hexdigest() == \"5246d7fd78d900c1aaed511af4b93a395c8f8f6b\", \"type of type(marathon_preds) is not correct\"\n\nassert sha1(str(type(marathon_preds.shape)).encode(\"utf-8\")+b\"80ef9\").hexdigest() == \"47500ac86a3aa4df2352b61411ba2c643b26a21b\", \"type of marathon_preds.shape is not tuple. marathon_preds.shape should be a tuple\"\nassert sha1(str(len(marathon_preds.shape)).encode(\"utf-8\")+b\"80ef9\").hexdigest() == \"c1dee5594a1047ae527ce7ff6fd93c09f5d7087f\", \"length of marathon_preds.shape is not correct\"\nassert sha1(str(sorted(map(str, marathon_preds.shape))).encode(\"utf-8\")+b\"80ef9\").hexdigest() == \"45e6ce598dd4b9a99a59cd85e2bc95e4e6dcfa1d\", \"values of marathon_preds.shape are not correct\"\nassert sha1(str(marathon_preds.shape).encode(\"utf-8\")+b\"80ef9\").hexdigest() == \"8b0e8a50ed15369143176e9e9a444fb85a94925f\", \"order of elements of marathon_preds.shape is not correct\"\n\nassert sha1(str(type(\"predictions\" in marathon_preds.columns)).encode(\"utf-8\")+b\"80efa\").hexdigest() == \"bee6c28399c272e11c7b36d6af56c340b73f5de9\", \"type of \\\"predictions\\\" in marathon_preds.columns is not bool. \\\"predictions\\\" in marathon_preds.columns should be a bool\"\nassert sha1(str(\"predictions\" in marathon_preds.columns).encode(\"utf-8\")+b\"80efa\").hexdigest() == \"bb01defbd41c2fca442d129ecde3d06ba69c793e\", \"boolean value of \\\"predictions\\\" in marathon_preds.columns is not correct\"\n\nassert sha1(str(type(sum(marathon_preds.predictions))).encode(\"utf-8\")+b\"80efb\").hexdigest() == \"6694cadf894375ec79d08d843730bfa2ebeaa247\", \"type of sum(marathon_preds.predictions) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(marathon_preds.predictions), 2)).encode(\"utf-8\")+b\"80efb\").hexdigest() == \"14d7241b6832fe96cee98179e0bfbab800123337\", \"value of sum(marathon_preds.predictions) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(sum(marathon_preds.time_hrs))).encode(\"utf-8\")+b\"80efc\").hexdigest() == \"32fcb9d092fe59373b115cd2156579052d4bb724\", \"type of sum(marathon_preds.time_hrs) is not float. Please make sure it is float and not np.float64, etc. You can cast your value into a float using float()\"\nassert sha1(str(round(sum(marathon_preds.time_hrs), 2)).encode(\"utf-8\")+b\"80efc\").hexdigest() == \"de864616f527a3484c98bc8e5ce5448442b3c180\", \"value of sum(marathon_preds.time_hrs) is not correct (rounded to 2 decimal places)\"\n\nassert sha1(str(type(marathon_plot is None)).encode(\"utf-8\")+b\"80efd\").hexdigest() == \"7802ca930a377d22b91bda34749b3473ae40ce6b\", \"type of marathon_plot is None is not bool. marathon_plot is None should be a bool\"\nassert sha1(str(marathon_plot is None).encode(\"utf-8\")+b\"80efd\").hexdigest() == \"6080493d69f4752d4f838318c797543ab4092182\", \"boolean value of marathon_plot is None is not correct\"\n\nassert sha1(str(type(len(marathon_plot.layer))).encode(\"utf-8\")+b\"80efe\").hexdigest() == \"f5cd3e76aff8db41831d68252d099f01b5af0eeb\", \"type of len(marathon_plot.layer) is not int. Please make sure it is int and not np.int64, etc. You can cast your value into an int using int()\"\nassert sha1(str(len(marathon_plot.layer)).encode(\"utf-8\")+b\"80efe\").hexdigest() == \"791ae34b7ef2c822983fb1c67241cccbe65ce087\", \"value of len(marathon_plot.layer) is not correct\"\n\nassert sha1(str(type(marathon_plot.layer[0].mark)).encode(\"utf-8\")+b\"80eff\").hexdigest() == \"31988f4df3bdd784d531d340494800d13f512ec8\", \"type of marathon_plot.layer[0].mark is not correct\"\nassert sha1(str(marathon_plot.layer[0].mark).encode(\"utf-8\")+b\"80eff\").hexdigest() == \"833d54d5fea79d6426472768c3753a1d3e2aab10\", \"value of marathon_plot.layer[0].mark is not correct\"\n\nassert sha1(str(type(marathon_plot.layer[1].mark)).encode(\"utf-8\")+b\"80f00\").hexdigest() == \"afb1d5a9e3ef12f0c2f446d06cc34948eac7babc\", \"type of marathon_plot.layer[1].mark is not correct\"\nassert sha1(str(marathon_plot.layer[1].mark).encode(\"utf-8\")+b\"80f00\").hexdigest() == \"50a72f4524c38645971c4b6a9df41dc1257a95c3\", \"value of marathon_plot.layer[1].mark is not correct\"\n\nassert sha1(str(type(marathon_plot.layer[0].encoding.x['shorthand'])).encode(\"utf-8\")+b\"80f01\").hexdigest() == \"6a6854dca69a83d48caec2cba6e1338a14a346fb\", \"type of marathon_plot.layer[0].encoding.x['shorthand'] is not str. marathon_plot.layer[0].encoding.x['shorthand'] should be an str\"\nassert sha1(str(len(marathon_plot.layer[0].encoding.x['shorthand'])).encode(\"utf-8\")+b\"80f01\").hexdigest() == \"e63a8532d269c7f5a36c4d9e504de2fe4993dd7f\", \"length of marathon_plot.layer[0].encoding.x['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[0].encoding.x['shorthand'].lower()).encode(\"utf-8\")+b\"80f01\").hexdigest() == \"1bd0afc1bf2c4a34122b26e13c975a1f3463b0b9\", \"value of marathon_plot.layer[0].encoding.x['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[0].encoding.x['shorthand']).encode(\"utf-8\")+b\"80f01\").hexdigest() == \"1bd0afc1bf2c4a34122b26e13c975a1f3463b0b9\", \"correct string value of marathon_plot.layer[0].encoding.x['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(marathon_plot.layer[0].encoding.y['shorthand'])).encode(\"utf-8\")+b\"80f02\").hexdigest() == \"f9dc36ce988a73cb1cb0b471255c1e10e4d91094\", \"type of marathon_plot.layer[0].encoding.y['shorthand'] is not str. marathon_plot.layer[0].encoding.y['shorthand'] should be an str\"\nassert sha1(str(len(marathon_plot.layer[0].encoding.y['shorthand'])).encode(\"utf-8\")+b\"80f02\").hexdigest() == \"6ce890fc97b51c036be327421ff4134099ff5209\", \"length of marathon_plot.layer[0].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[0].encoding.y['shorthand'].lower()).encode(\"utf-8\")+b\"80f02\").hexdigest() == \"5afe1d7a1dd51c71a80027335b5a7b623548ea9e\", \"value of marathon_plot.layer[0].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[0].encoding.y['shorthand']).encode(\"utf-8\")+b\"80f02\").hexdigest() == \"5afe1d7a1dd51c71a80027335b5a7b623548ea9e\", \"correct string value of marathon_plot.layer[0].encoding.y['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(marathon_plot.layer[1].encoding.y['shorthand'])).encode(\"utf-8\")+b\"80f03\").hexdigest() == \"32deb9ef407143db608af31b29a3adedbc08ca59\", \"type of marathon_plot.layer[1].encoding.y['shorthand'] is not str. marathon_plot.layer[1].encoding.y['shorthand'] should be an str\"\nassert sha1(str(len(marathon_plot.layer[1].encoding.y['shorthand'])).encode(\"utf-8\")+b\"80f03\").hexdigest() == \"457b359edc893e20adf144c86cf19d1a75746764\", \"length of marathon_plot.layer[1].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[1].encoding.y['shorthand'].lower()).encode(\"utf-8\")+b\"80f03\").hexdigest() == \"91b908c0622ce400d6464a25c58cb64b9b250011\", \"value of marathon_plot.layer[1].encoding.y['shorthand'] is not correct\"\nassert sha1(str(marathon_plot.layer[1].encoding.y['shorthand']).encode(\"utf-8\")+b\"80f03\").hexdigest() == \"91b908c0622ce400d6464a25c58cb64b9b250011\", \"correct string value of marathon_plot.layer[1].encoding.y['shorthand'] but incorrect case of letters\"\n\nassert sha1(str(type(isinstance(marathon_plot.layer[0].encoding.x['title'], str))).encode(\"utf-8\")+b\"80f04\").hexdigest() == \"6a9334f3b0f6f1f0d22d19bec2755550c05f1b9b\", \"type of isinstance(marathon_plot.layer[0].encoding.x['title'], str) is not bool. isinstance(marathon_plot.layer[0].encoding.x['title'], str) should be a bool\"\nassert sha1(str(isinstance(marathon_plot.layer[0].encoding.x['title'], str)).encode(\"utf-8\")+b\"80f04\").hexdigest() == \"3902db8b41319e78ddf41fae51a6625a43b54f01\", \"boolean value of isinstance(marathon_plot.layer[0].encoding.x['title'], str) is not correct\"\n\nassert sha1(str(type(isinstance(marathon_plot.layer[0].encoding.y['title'], str))).encode(\"utf-8\")+b\"80f05\").hexdigest() == \"523124c5efd969114f88146347e99ccc8593d726\", \"type of isinstance(marathon_plot.layer[0].encoding.y['title'], str) is not bool. isinstance(marathon_plot.layer[0].encoding.y['title'], str) should be a bool\"\nassert sha1(str(isinstance(marathon_plot.layer[0].encoding.y['title'], str)).encode(\"utf-8\")+b\"80f05\").hexdigest() == \"43ecd7181832f23dda45839dbbd29bdbaabcd0b5\", \"boolean value of isinstance(marathon_plot.layer[0].encoding.y['title'], str) is not correct\"\n\nprint('Success!')"
  },
  {
    "objectID": "materials/slides/classification2.html#session-learning-objectives",
    "href": "materials/slides/classification2.html#session-learning-objectives",
    "title": "Classification II: evaluation & tuning",
    "section": "Session learning objectives",
    "text": "Session learning objectives\n\n\n\n\n\n\nBy the end of the session, learners will be able to do the following:\n\nDescribe what training, validation, and test data sets are and how they are used in classification.\nSplit data into training, validation, and test data sets.\nDescribe what a random seed is and its importance in reproducible data analysis.\nSet the random seed in Python using the numpy.random.seed function.\nDescribe and interpret accuracy, precision, recall, and confusion matrices.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#session-learning-objectives-contd",
    "href": "materials/slides/classification2.html#session-learning-objectives-contd",
    "title": "Classification II: evaluation & tuning",
    "section": "Session learning objectives cont‚Äôd",
    "text": "Session learning objectives cont‚Äôd\nBy the end of the session, learners will be able to do the following:\n\nEvaluate classification accuracy, precision, and recall in Python using a test set, a single validation set, and cross-validation.\nProduce a confusion matrix in Python.\nChoose the number of neighbors in a K-nearest neighbors classifier by maximizing estimated cross-validation accuracy.\nDescribe underfitting and overfitting, and relate it to the number of neighbors in K-nearest neighbors classification.\nDescribe the advantages and disadvantages of the K-nearest neighbors classification algorithm.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#evaluating-performance",
    "href": "materials/slides/classification2.html#evaluating-performance",
    "title": "Classification II: evaluation & tuning",
    "section": "Evaluating performance",
    "text": "Evaluating performance\n\nSometimes our classifier might make the wrong prediction.\nA classifier does not need to be right 100% of the time to be useful, though we don‚Äôt want the classifier to make too many wrong predictions.\nHow do we measure how ‚Äúgood‚Äù our classifier is?",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#data-splitting",
    "href": "materials/slides/classification2.html#data-splitting",
    "title": "Classification II: evaluation & tuning",
    "section": "Data splitting",
    "text": "Data splitting\n\nThe trick is to split the data into a training set and test set.\nOnly the training set when building the classifier.\nTo evaluate the performance of the classifier, we first set aside the labels from the test set, and then use the classifier to predict the labels in the test set.\nIf our predictions match the actual labels for the observations in the test set, then we have some confidence that our classifier might also accurately predict the class labels for new observations without known class labels.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#splitting-the-data-into-training-and-testing-sets",
    "href": "materials/slides/classification2.html#splitting-the-data-into-training-and-testing-sets",
    "title": "Classification II: evaluation & tuning",
    "section": "Splitting the data into training and testing sets",
    "text": "Splitting the data into training and testing sets",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#prediction-accuracy",
    "href": "materials/slides/classification2.html#prediction-accuracy",
    "title": "Classification II: evaluation & tuning",
    "section": "Prediction accuracy",
    "text": "Prediction accuracy",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#is-knowing-accuracy-enough",
    "href": "materials/slides/classification2.html#is-knowing-accuracy-enough",
    "title": "Classification II: evaluation & tuning",
    "section": "Is knowing accuracy enough?",
    "text": "Is knowing accuracy enough?\n\nExample accuracy calculation:\n\n\\[\\mathrm{accuracy} = \\frac{\\mathrm{number \\; of  \\; correct  \\; predictions}}{\\mathrm{total \\;  number \\;  of  \\; predictions}} = \\frac{58}{65} = 0.892\\]\n\nPrediction accuracy only tells us how often the classifier makes mistakes in general, but does not tell us anything about the kinds of mistakes the classifier makes.\nThe confusion matrix tells a more complete story.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#example-confusion-matrix-for-the-breast-cancer-data",
    "href": "materials/slides/classification2.html#example-confusion-matrix-for-the-breast-cancer-data",
    "title": "Classification II: evaluation & tuning",
    "section": "Example confusion matrix for the breast cancer data:",
    "text": "Example confusion matrix for the breast cancer data:\n\n\n\n\n\n\n\n\n\nPredicted Malignant\nPredicted Benign\n\n\n\n\nActually Malignant\n1\n3\n\n\nActually Benign\n4\n57\n\n\n\n\nTrue Positive: A malignant observation that was classified as malignant (top left).\nFalse Positive: A benign observation that was classified as malignant (bottom left).\nTrue Negative: A benign observation that was classified as benign (bottom right).\nFalse Negative: A malignant observation that was classified as benign (top right).",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#precision-recall",
    "href": "materials/slides/classification2.html#precision-recall",
    "title": "Classification II: evaluation & tuning",
    "section": "Precision & recall",
    "text": "Precision & recall\n\nPrecision quantifies how many of the positive predictions the classifier made were actually positive.\n\n\\[\\mathrm{precision} = \\frac{\\mathrm{number \\; of  \\; correct \\; positive \\; predictions}}{\\mathrm{total \\;  number \\;  of \\; positive  \\; predictions}}\\]\n\nRecall quantifies how many of the positive observations in the test set were identified as positive.\n\n\\[\\mathrm{recall} = \\frac{\\mathrm{number \\; of  \\; correct  \\; positive \\; predictions}}{\\mathrm{total \\;  number \\;  of  \\; positive \\; test \\; set \\; observations}}\\]",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#precision-and-recall-for-the-breast-cancer-data-set-example",
    "href": "materials/slides/classification2.html#precision-and-recall-for-the-breast-cancer-data-set-example",
    "title": "Classification II: evaluation & tuning",
    "section": "Precision and recall for the breast cancer data set example",
    "text": "Precision and recall for the breast cancer data set example\n\n\n\n\n\n\n\n\n\nPredicted Malignant\nPredicted Benign\n\n\n\n\nActually Malignant\n1\n3\n\n\nActually Benign\n4\n57\n\n\n\n\\[\\mathrm{precision} = \\frac{1}{1+4} = 0.20, \\quad \\mathrm{recall} = \\frac{1}{1+3} = 0.25\\]\n\nSo even with an accuracy of 89%, the precision and recall of the classifier were both relatively low. For this data analysis context, recall is particularly important: if someone has a malignant tumor, we certainly want to identify it. A recall of just 25% would likely be unacceptable!",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#randomness-and-seeds",
    "href": "materials/slides/classification2.html#randomness-and-seeds",
    "title": "Classification II: evaluation & tuning",
    "section": "Randomness and seeds",
    "text": "Randomness and seeds\n\nOur data analyses will often involve the use of randomness\nWe use randomness any time we need to make a decision in our analysis that needs to be fair, unbiased, and not influenced by human input (e.g., splitting into training and test sets).\nHowever, the use of randomness runs counter to one of the main tenets of good data analysis practice: reproducibility‚Ä¶\nThe trick is that in Python‚Äîand other programming languages‚Äîrandomness is not actually random! Instead, Python uses a random number generator that produces a sequence of numbers that are completely determined by a seed value.\nOnce you set the seed value, everything after that point may look random, but is actually totally reproducible.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#setting-the-seed-in-python",
    "href": "materials/slides/classification2.html#setting-the-seed-in-python",
    "title": "Classification II: evaluation & tuning",
    "section": "Setting the seed in Python",
    "text": "Setting the seed in Python\nLet‚Äôs say we want to make a series object containing the integers from 0 to 9. And then we want to randomly pick 10 numbers from that list, but we want it to be reproducible.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#setting-the-seed-in-python-contd",
    "href": "materials/slides/classification2.html#setting-the-seed-in-python-contd",
    "title": "Classification II: evaluation & tuning",
    "section": "Setting the seed in Python (cont‚Äôd)",
    "text": "Setting the seed in Python (cont‚Äôd)\nReminder of the list of numbers we just generated:\n\n\n\n\n\n\n\nIf we run the sample method again, we will get a fresh batch of 10 numbers that also look random.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#setting-the-seed-in-python-contd-1",
    "href": "materials/slides/classification2.html#setting-the-seed-in-python-contd-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Setting the seed in Python (cont‚Äôd)",
    "text": "Setting the seed in Python (cont‚Äôd)\nLet‚Äôs regenerate original set of 10 random numbers by setting the seed to 1:\n\n\n\n\n\n\n\nIf we choose a different value for the seed‚Äîsay, 4235‚Äîwe obtain a different sequence of random numbers:",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#back-to-the-breast-cancer-data-set-example",
    "href": "materials/slides/classification2.html#back-to-the-breast-cancer-data-set-example",
    "title": "Classification II: evaluation & tuning",
    "section": "Back to the breast cancer data set example",
    "text": "Back to the breast cancer data set example\nLoad packages and set seed:",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#create-the-train-test-split",
    "href": "materials/slides/classification2.html#create-the-train-test-split",
    "title": "Classification II: evaluation & tuning",
    "section": "Create the train / test split",
    "text": "Create the train / test split\n\nBefore fitting any models, or doing exploratory data analysis, it is critical that you split the data into training and test sets.\nTypically, the training set is between 50% and 95% of the data, while the test set is the remaining 5% to 50%.\nThe train_test_split function from scikit-learn handles the procedure of splitting the data for us.\nUse shuffle=True to remove the influence of order in the data set.\nSet the stratify parameter to be the response variable to ensure the same proportion of each class ends up in both the training and testing sets.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#splitting-the-breast-cancer-data-set",
    "href": "materials/slides/classification2.html#splitting-the-breast-cancer-data-set",
    "title": "Classification II: evaluation & tuning",
    "section": "Splitting the breast cancer data set",
    "text": "Splitting the breast cancer data set\n\nSplit the data so 75% are in the training set, and 25% in the test set\nData are shuffled\nSplit is stratified on the Class variable",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#checking-the-splits",
    "href": "materials/slides/classification2.html#checking-the-splits",
    "title": "Classification II: evaluation & tuning",
    "section": "Checking the splits",
    "text": "Checking the splits\n\nLet‚Äôs look at the training and test splits (in practice you look at both)\nWe can see our class proportions were roughly preserved when we split the data.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#preprocessing-with-data-splitting",
    "href": "materials/slides/classification2.html#preprocessing-with-data-splitting",
    "title": "Classification II: evaluation & tuning",
    "section": "Preprocessing with data splitting",
    "text": "Preprocessing with data splitting\n\nMany machine learning models are sensitive to the scale of the predictors, and even if not, comparison of importance of features for prediction after fitting requires scaling.\nWhen preprocessing the data (scaling is part of this), it is critical that we use only the training set in creating the mathematical function to do this.\nIf this is not done, we will get overly optimistic test accuracy, as our test data will have influenced our model.\nAfter creating the preprocessing function, we can then apply it separately to both the training and test data sets.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#preprocessing-with-scikit-learn",
    "href": "materials/slides/classification2.html#preprocessing-with-scikit-learn",
    "title": "Classification II: evaluation & tuning",
    "section": "Preprocessing with scikit-learn",
    "text": "Preprocessing with scikit-learn\n\nscikit-learn helps us handle this properly as long as we wrap our analysis steps in a Pipeline.\nSpecifically, we construct and prepare the preprocessor using make_column_transformer, specifying the type of tranformation we want to apply, as well as which columns to apply it to:",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#train-the-classifier",
    "href": "materials/slides/classification2.html#train-the-classifier",
    "title": "Classification II: evaluation & tuning",
    "section": "Train the classifier",
    "text": "Train the classifier\n\nNow we can create our K-nearest neighbors classifier with only the training set.\nFor simplicity, we will just choose \\(K\\) = 3, and use only the concavity and smoothness predictors.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#predict-the-labels-in-the-test-set",
    "href": "materials/slides/classification2.html#predict-the-labels-in-the-test-set",
    "title": "Classification II: evaluation & tuning",
    "section": "Predict the labels in the test set",
    "text": "Predict the labels in the test set\nNow that we have a K-nearest neighbors classifier object, we can use it to predict the class labels for our test set:",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#evaluate-performance",
    "href": "materials/slides/classification2.html#evaluate-performance",
    "title": "Classification II: evaluation & tuning",
    "section": "Evaluate performance",
    "text": "Evaluate performance\nTo evaluate the model, we will look at:\n\naccuracy\nprecision\nrecall\nconfusion matrix\ncompare to baseline model (majority classifier)\n\nAll of these together, will help us develop a fuller picture of how the model is performing, as opposed to only evaluating the model based on a single metric or table.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#accuracy",
    "href": "materials/slides/classification2.html#accuracy",
    "title": "Classification II: evaluation & tuning",
    "section": "Accuracy",
    "text": "Accuracy",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#precision",
    "href": "materials/slides/classification2.html#precision",
    "title": "Classification II: evaluation & tuning",
    "section": "Precision",
    "text": "Precision",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#recall",
    "href": "materials/slides/classification2.html#recall",
    "title": "Classification II: evaluation & tuning",
    "section": "Recall",
    "text": "Recall",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#confusion-matrix",
    "href": "materials/slides/classification2.html#confusion-matrix",
    "title": "Classification II: evaluation & tuning",
    "section": "Confusion matrix",
    "text": "Confusion matrix\n\nThe Pandas crosstab function takes two arguments: the actual labels first, then the predicted labels second.\nNote that crosstab orders its columns alphabetically, but the positive label is still Malignant, even if it is not in the top left corner as in the table shown earlier.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#critically-analyze-performance",
    "href": "materials/slides/classification2.html#critically-analyze-performance",
    "title": "Classification II: evaluation & tuning",
    "section": "Critically analyze performance",
    "text": "Critically analyze performance\n\nIs 90% accuracy, a precision of 83% and a recall of 91% good enough?\nTo get a sense of scale, we often compare our model to a baseline model. In the case of classification, this would be the majority classifier (always guesses the majority class label from the training data).\nFor the breast cancer training data, the baseline classifier‚Äôs accuracy would be 63%",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#critically-analyze-performance-contd",
    "href": "materials/slides/classification2.html#critically-analyze-performance-contd",
    "title": "Classification II: evaluation & tuning",
    "section": "Critically analyze performance (cont‚Äôd)",
    "text": "Critically analyze performance (cont‚Äôd)\n\nSo we do see that our model is doing a LOT better than the baseline, which is great, but considering our application domain is in cancer diagnosis, we still have a ways to go‚Ä¶\nAnalyzing model performance really depends on your application!",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#tuning-the-classifier",
    "href": "materials/slides/classification2.html#tuning-the-classifier",
    "title": "Classification II: evaluation & tuning",
    "section": "Tuning the classifier",
    "text": "Tuning the classifier\n\nMost predictive models in statistics and machine learning have parameters (a number you have to pick in advance that determines some aspect of how the model behaves).\nFor our working example, \\(K\\)-nearest neighbors classification algorithm, \\(K\\) is a parameter that we have to pick that determines how many neighbors participate in the class vote.\nHow do we choose \\(K\\), or any parameter for other models?\nData splitting!",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#validation-set",
    "href": "materials/slides/classification2.html#validation-set",
    "title": "Classification II: evaluation & tuning",
    "section": "Validation set",
    "text": "Validation set\n\nCannot use the test set to choose the parameter!\nBut we can split the training set into two partitions, a traning set and a validation set.\nFor each parameter value we want to assess, we can fit on the training set, and evaluate on the validation set.\nThen after we find the best value for our parameter, we can refit the model with the best parameter on the entire training set and then evaluate our model on the test set.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#validation-set-1",
    "href": "materials/slides/classification2.html#validation-set-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Validation set",
    "text": "Validation set",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#can-we-do-better",
    "href": "materials/slides/classification2.html#can-we-do-better",
    "title": "Classification II: evaluation & tuning",
    "section": "Can we do better?",
    "text": "Can we do better?\n\nDepending on how we split the data into the training and validation sets, we might get a lucky split (or an unlucky one) that doesn‚Äôt give us a good estimate of the model‚Äôs true accuracy.\nIn many cases, we can do better by making many splits, and averaging the accuracy scores to get a better estimate.\nWe call this cross-validation.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#cross-validation-with-five-folds",
    "href": "materials/slides/classification2.html#cross-validation-with-five-folds",
    "title": "Classification II: evaluation & tuning",
    "section": "Cross-validation with five folds",
    "text": "Cross-validation with five folds",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#cross-validation-in-scikit-learn",
    "href": "materials/slides/classification2.html#cross-validation-in-scikit-learn",
    "title": "Classification II: evaluation & tuning",
    "section": "Cross-validation in scikit-learn",
    "text": "Cross-validation in scikit-learn\n\nUse the scikit-learn cross_validate function.\nNeed to specify:\n\na modelling Pipeline as the estimator argument,\nthe number of folds as the cv argument,\nthe training data predictors as the X argument\nthe labels as the y arguments.\n\nNote that the cross_validate function handles stratifying the classes in each train and validate fold automatically.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#cross-validation-in-scikit-learn-contd",
    "href": "materials/slides/classification2.html#cross-validation-in-scikit-learn-contd",
    "title": "Classification II: evaluation & tuning",
    "section": "Cross-validation in scikit-learn (cont‚Äôd)",
    "text": "Cross-validation in scikit-learn (cont‚Äôd)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#cross-validation-in-scikit-learn-contd-1",
    "href": "materials/slides/classification2.html#cross-validation-in-scikit-learn-contd-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Cross-validation in scikit-learn (cont‚Äôd)",
    "text": "Cross-validation in scikit-learn (cont‚Äôd)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#parameter-value-selection",
    "href": "materials/slides/classification2.html#parameter-value-selection",
    "title": "Classification II: evaluation & tuning",
    "section": "Parameter value selection",
    "text": "Parameter value selection\n\nSince cross-validation helps us evaluate the accuracy of our classifier, we can use cross-validation to calculate an accuracy for each value of our parameter, here \\(K\\), in a reasonable range.\nThen we pick the value of \\(K\\) that gives us the best accuracy, and refit the model with our parameter on the training data, and then evaluate on the test data.\nThe scikit-learn package collection provides built-in functionality, named GridSearchCV, to automatically handle the details for us.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#parameter-value-selection-1",
    "href": "materials/slides/classification2.html#parameter-value-selection-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Parameter value selection",
    "text": "Parameter value selection",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#parameter-value-selection-2",
    "href": "materials/slides/classification2.html#parameter-value-selection-2",
    "title": "Classification II: evaluation & tuning",
    "section": "Parameter value selection",
    "text": "Parameter value selection\nNow we use the fit method on the GridSearchCV object to begin the tuning process.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#parameter-value-selection-3",
    "href": "materials/slides/classification2.html#parameter-value-selection-3",
    "title": "Classification II: evaluation & tuning",
    "section": "Parameter value selection",
    "text": "Parameter value selection",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#visualize-paramter-value-selection",
    "href": "materials/slides/classification2.html#visualize-paramter-value-selection",
    "title": "Classification II: evaluation & tuning",
    "section": "Visualize paramter value selection",
    "text": "Visualize paramter value selection\n\naccuracy_vs_k = (\n    alt.Chart(accuracies_grid)\n    .mark_line(point=True)\n    .encode(\n        x=alt.X(\"n_neighbors\")\n        .title(\"Neighbors\"),\n        y=alt.Y(\"mean_test_score\")\n        .scale(zero=False)\n        .title(\"Accuracy estimate\")\n    )\n)",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#visualize-paramter-value-selection-1",
    "href": "materials/slides/classification2.html#visualize-paramter-value-selection-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Visualize paramter value selection",
    "text": "Visualize paramter value selection",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#best-parameter-value",
    "href": "materials/slides/classification2.html#best-parameter-value",
    "title": "Classification II: evaluation & tuning",
    "section": "Best parameter value",
    "text": "Best parameter value\nWe can also obtain the number of neighbours with the highest accuracy programmatically by accessing the best_params_ attribute of the fit GridSearchCV object.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#best-parameter-value-1",
    "href": "materials/slides/classification2.html#best-parameter-value-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Best parameter value",
    "text": "Best parameter value\nDo we use \\(K\\) = 36?\nGenerally, when selecting a parameters, we are looking for a value where:\n\nwe get roughly optimal accuracy\nchanging the value to a nearby one doesn‚Äôt change the accuracy too much\nthe cost of training the model is not prohibitive",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#best-parameter-value-2",
    "href": "materials/slides/classification2.html#best-parameter-value-2",
    "title": "Classification II: evaluation & tuning",
    "section": "Best parameter value",
    "text": "Best parameter value",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#underoverfitting",
    "href": "materials/slides/classification2.html#underoverfitting",
    "title": "Classification II: evaluation & tuning",
    "section": "Under/Overfitting",
    "text": "Under/Overfitting\n\nWhat happens if we keep increasing the number of neighbors \\(K\\)?\nThe cross-validation accuracy estimate actually starts to decrease!",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#evaluating-on-the-test-set",
    "href": "materials/slides/classification2.html#evaluating-on-the-test-set",
    "title": "Classification II: evaluation & tuning",
    "section": "Evaluating on the test set",
    "text": "Evaluating on the test set\n\nBefore we evaluate on the test set, we need to refit the model using the best parameter(s) on the entire training set\nLuckily, scikit-learn does it for us automatically!\nTo make predictions and assess the estimated accuracy of the best model on the test data, we can use the score and predict methods of the fit GridSearchCV object.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#evaluating-on-the-test-set-1",
    "href": "materials/slides/classification2.html#evaluating-on-the-test-set-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Evaluating on the test set",
    "text": "Evaluating on the test set\nHow well might our classifier do on unseen data?\nTo find out we can then pass those predictions to the precision, recall, and crosstab functions to assess the estimated precision and recall, and print a confusion matrix.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#accuracy-1",
    "href": "materials/slides/classification2.html#accuracy-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Accuracy",
    "text": "Accuracy",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#precision-1",
    "href": "materials/slides/classification2.html#precision-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Precision",
    "text": "Precision",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#recall-1",
    "href": "materials/slides/classification2.html#recall-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Recall",
    "text": "Recall",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#confusion-matrix-1",
    "href": "materials/slides/classification2.html#confusion-matrix-1",
    "title": "Classification II: evaluation & tuning",
    "section": "Confusion matrix",
    "text": "Confusion matrix",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#summary",
    "href": "materials/slides/classification2.html#summary",
    "title": "Classification II: evaluation & tuning",
    "section": "Summary",
    "text": "Summary",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#k-nearest-neighbors-classification-algorithm",
    "href": "materials/slides/classification2.html#k-nearest-neighbors-classification-algorithm",
    "title": "Classification II: evaluation & tuning",
    "section": "K-nearest neighbors classification algorithm",
    "text": "K-nearest neighbors classification algorithm\nStrengths: K-nearest neighbors classification\n\nis a simple, intuitive algorithm,\nrequires few assumptions about what the data must look like, and\nworks for binary (two-class) and multi-class (more than 2 classes) classification problems.\n\nWeaknesses: K-nearest neighbors classification\n\nbecomes very slow as the training data gets larger,\nmay not perform well with a large number of predictors, and\nmay not perform well when classes are imbalanced.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#other-classification-algorithms",
    "href": "materials/slides/classification2.html#other-classification-algorithms",
    "title": "Classification II: evaluation & tuning",
    "section": "Other classification algorithms",
    "text": "Other classification algorithms\n\nscikit-learn classification documentation: https://scikit-learn.org/stable/supervised_learning.html",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#additional-resources",
    "href": "materials/slides/classification2.html#additional-resources",
    "title": "Classification II: evaluation & tuning",
    "section": "Additional resources",
    "text": "Additional resources\n\nThe Classification II: evaluation & tuning chapter of Data Science: A First Introduction (Python Edition) by Tiffany Timbers, Trevor Campbell, Melissa Lee, Joel Ostblom, Lindsey Heagy contains all the content presented here with a detailed narrative.\nThe scikit-learn website is an excellent reference for more details on, and advanced usage of, the functions and packages in the past two chapters. Aside from that, it also offers many useful tutorials to get you started.\nAn Introduction to Statistical Learning provides a great next stop in the process of learning about classification. Chapter 4 discusses additional basic techniques for classification that we do not cover, such as logistic regression, linear discriminant analysis, and naive Bayes.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/classification2.html#references",
    "href": "materials/slides/classification2.html#references",
    "title": "Classification II: evaluation & tuning",
    "section": "References",
    "text": "References\nEvelyn Martin Lansdowne Beale, Maurice George Kendall, and David Mann. The discarding of variables in multivariate analysis. Biometrika, 54(3-4):357‚Äì366, 1967.\nNorman Draper and Harry Smith. Applied Regression Analysis. Wiley, 1966.\nM. Eforymson. Stepwise regression‚Äîa backward and forward look. In Eastern Regional Meetings of the Institute of Mathematical Statistics. 1966.\nRonald Hocking and R. N. Leslie. Selection of the best subset in regression analysis. Technometrics, 9(4):531‚Äì540, 1967.\nGareth James, Daniela Witten, Trevor Hastie, and Robert Tibshirani. An Introduction to Statistical Learning. Springer, 1st edition, 2013. URL: https://www.statlearning.com/.\nWes McKinney. Python for data analysis: Data wrangling with Pandas, NumPy, and IPython. ‚Äù O‚ÄôReilly Media, Inc.‚Äù, 2012.\nWilliam Nick Street, William Wolberg, and Olvi Mangasarian. Nuclear feature extraction for breast tumor diagnosis. In International Symposium on Electronic Imaging: Science and Technology. 1993.",
    "crumbs": [
      "Home",
      "Slides",
      "Classification II: evaluation & tuning"
    ]
  },
  {
    "objectID": "materials/slides/intro.html#introductions",
    "href": "materials/slides/intro.html#introductions",
    "title": "Welcome",
    "section": "Introductions",
    "text": "Introductions\n\n\n\nTiffany Timbers\nUniversity of British Columbia\n\n\nDaniel Chen\nUniversity of British Columbia"
  },
  {
    "objectID": "materials/slides/intro.html#introduce-yourself",
    "href": "materials/slides/intro.html#introduce-yourself",
    "title": "Welcome",
    "section": "Introduce yourself",
    "text": "Introduce yourself\nWe wont go around the room, but take the next couple of minutes to introduce yourself to your neighbors.\nSome suggested topics:\n\nWhat is your name\nWhere you are coming from\nWhy you are interested in learning ML in Python"
  },
  {
    "objectID": "materials/slides/intro.html#materials",
    "href": "materials/slides/intro.html#materials",
    "title": "Welcome",
    "section": "Materials",
    "text": "Materials\n\n\nWebsite:\n\nhttps://posit-conf-2024.github.io/ml-python/\n\n\nGitHub:\n\nhttps://github.com/posit-conf-2024/ml-python"
  },
  {
    "objectID": "materials/slides/intro.html#schedule",
    "href": "materials/slides/intro.html#schedule",
    "title": "Welcome",
    "section": "Schedule",
    "text": "Schedule\n\n\n\n\n\n\n\nTime\nActivity\n\n\n\n\n09:00 - 10:30\nSession 1 - Introduction to workshop and intro to machine learning (via Classification I)\n\n\n10:30 - 11:00\nCoffee break\n\n\n11:00 - 12:30\nSession 2 - Classification II\n\n\n12:30 - 13:30\nLunch break\n\n\n13:30 - 15:00\nSession 3 - Regression\n\n\n15:00 - 15:30\nCoffee break\n\n\n15:30 - 17:00\nSession 4 - Tree-based and ensemble methods"
  },
  {
    "objectID": "materials/slides/intro.html#wifi",
    "href": "materials/slides/intro.html#wifi",
    "title": "Welcome",
    "section": "WiFi",
    "text": "WiFi\n\n\nUsername:\n\nPosit Conf 2024\n\nPassword:\n\nconf2024\n\n\n\nIf you have any difficulty with your connection please let us (myself and or the TAs) know so we can escalate issues if needed."
  },
  {
    "objectID": "materials/slides/intro.html#code-of-conduct",
    "href": "materials/slides/intro.html#code-of-conduct",
    "title": "Welcome",
    "section": "Code of Conduct",
    "text": "Code of Conduct\nThe Code of Conduct can be found at posit.co/code-of-conduct.\nPlease review it carefully.\nYou can report Code of Conduct violations in person, by email, or by phone.\nPlease see the policy linked above for contact information."
  },
  {
    "objectID": "materials/slides/intro.html#other-useful-info",
    "href": "materials/slides/intro.html#other-useful-info",
    "title": "Welcome",
    "section": "Other useful info",
    "text": "Other useful info\n\nThere are gender-neutral bathrooms located on floors 3, 4, 5, 6, and 7.\nThe meditation and prayer room is Room 503, it is available Mon & Tues 7am - 7pm, and Wed 7am - 5pm.\nThe lactation room is located in 509, with the same timings as above.\nParticipants who do not wish to be photographed have red lanyards; please note everyone‚Äôs lanyard colors before taking a photo and respect their choices."
  },
  {
    "objectID": "materials/slides/intro.html#asking-for-help-stickies",
    "href": "materials/slides/intro.html#asking-for-help-stickies",
    "title": "Welcome",
    "section": "Asking for help (Stickies)",
    "text": "Asking for help (Stickies)\n\n\n\n\n\nI‚Äôm working\n\n\n\n\n\nI‚Äôm stuck\n\n\n\n\n\nI‚Äôm done"
  },
  {
    "objectID": "materials/slides/intro.html#other-communication-discord",
    "href": "materials/slides/intro.html#other-communication-discord",
    "title": "Welcome",
    "section": "Other communication (Discord)",
    "text": "Other communication (Discord)\nYou should have received an email with an invitation and instructions for joining the conference‚Äôs discord server.\nThis workshop has a private channel under Workshops,\n\n#workshop-ml-python\n\nThis is a great place to ask questions, post resources, memes, or most anything else before, during, and after the workshop."
  },
  {
    "objectID": "materials/slides/intro.html#rstudio-cloud",
    "href": "materials/slides/intro.html#rstudio-cloud",
    "title": "Welcome",
    "section": "RStudio Cloud",
    "text": "RStudio Cloud\nLink in your welcome email (from last night!) and/or discord (pinned/first comment)\nOnce you have joined you‚Äôre ready to go! We will work with these at the end of each lecture component.\n\n\n\n\n\n\nwhich should then create a copy of all materials and launch a cloud session for you."
  },
  {
    "objectID": "materials/slides/intro.html#cloud-session",
    "href": "materials/slides/intro.html#cloud-session",
    "title": "Welcome",
    "section": "Cloud session",
    "text": "Cloud session\nIf everything is working you should see something very close to the following,"
  },
  {
    "objectID": "LICENSE.html#creative-commons-attribution-sharealike-4.0-international-public-license",
    "href": "LICENSE.html#creative-commons-attribution-sharealike-4.0-international-public-license",
    "title": "Attribution-ShareAlike 4.0 International",
    "section": "Creative Commons Attribution-ShareAlike 4.0 International Public License",
    "text": "Creative Commons Attribution-ShareAlike 4.0 International Public License\nBy exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-ShareAlike 4.0 International Public License (‚ÄúPublic License‚Äù). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.\n\nSection 1 ‚Äì Definitions.\n\nAdapted Material means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.\nAdapter‚Äôs License means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License.\nBY-SA Compatible License means a license listed at creativecommons.org/compatiblelicenses, approved by Creative Commons as essentially the equivalent of this Public License.\nCopyright and Similar Rights means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.\nEffective Technological Measures means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.\nExceptions and Limitations means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.\nLicense Elements means the license attributes listed in the name of a Creative Commons Public License. The License Elements of this Public License are Attribution and ShareAlike.\nLicensed Material means the artistic or literary work, database, or other material to which the Licensor applied this Public License.\nLicensed Rights means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.\nLicensor means the individual(s) or entity(ies) granting rights under this Public License.\nShare means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.\nSui Generis Database Rights means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.\nYou means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.\n\n\n\nSection 2 ‚Äì Scope.\n\nLicense grant.\n\nSubject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:\nA. reproduce and Share the Licensed Material, in whole or in part; and\nB. produce, reproduce, and Share Adapted Material.\nExceptions and Limitations. For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.\nTerm. The term of this Public License is specified in Section 6(a).\nMedia and formats; technical modifications allowed. The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material.\nDownstream recipients.\nA. Offer from the Licensor ‚Äì Licensed Material. Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.\nB. __Additional offer from the Licensor ‚Äì Adapted Material. Every recipient of Adapted Material from You automatically receives an offer from the Licensor to exercise the Licensed Rights in the Adapted Material under the conditions of the Adapter‚Äôs License You apply.\nC. No downstream restrictions. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.\nNo endorsement. Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).\n\nOther rights.\n\nMoral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.\nPatent and trademark rights are not licensed under this Public License.\nTo the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties.\n\n\n\n\nSection 3 ‚Äì License Conditions.\nYour exercise of the Licensed Rights is expressly made subject to the following conditions.\n\nAttribution.\n\nIf You Share the Licensed Material (including in modified form), You must:\nA. retain the following if it is supplied by the Licensor with the Licensed Material:\n\nidentification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);\na copyright notice;\na notice that refers to this Public License;\na notice that refers to the disclaimer of warranties;\na URI or hyperlink to the Licensed Material to the extent reasonably practicable;\n\nB. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and\nC. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.\nYou may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.\nIf requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.\n\nShareAlike.\n\nIn addition to the conditions in Section 3(a), if You Share Adapted Material You produce, the following conditions also apply.\n\nThe Adapter‚Äôs License You apply must be a Creative Commons license with the same License Elements, this version or later, or a BY-SA Compatible License.\nYou must include the text of, or the URI or hyperlink to, the Adapter‚Äôs License You apply. You may satisfy this condition in any reasonable manner based on the medium, means, and context in which You Share Adapted Material.\nYou may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, Adapted Material that restrict exercise of the rights granted under the Adapter‚Äôs License You apply.\n\n\n\nSection 4 ‚Äì Sui Generis Database Rights.\nWhere the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:\n\nfor the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database;\nif You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material, including for purposes of Section 3(b); and\nYou must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.\n\n\nSection 5 ‚Äì Disclaimer of Warranties and Limitation of Liability.\n\nUnless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.\nTo the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.\nThe disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.\n\n\n\nSection 6 ‚Äì Term and Termination.\n\nThis Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.\nWhere Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:\n\nautomatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or\nupon express reinstatement by the Licensor.\n\nFor the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.\nFor the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.\nSections 1, 5, 6, 7, and 8 survive termination of this Public License.\n\n\n\nSection 7 ‚Äì Other Terms and Conditions.\n\nThe Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.\nAny arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.t stated herein are separate from and independent of the terms and conditions of this Public License.\n\n\n\nSection 8 ‚Äì Interpretation.\n\nFor the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.\nTo the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.\nNo term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.\nNothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.\n\n\nCreative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the ‚ÄúLicensor.‚Äù Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at creativecommons.org/policies, Creative Commons does not authorize the use of the trademark ‚ÄúCreative Commons‚Äù or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.\nCreative Commons may be contacted at creativecommons.org"
  }
]